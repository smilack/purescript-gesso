{
  "version": 3,
  "sources": ["../../../output/Control.Bind/foreign.js", "../../../output/Control.Apply/foreign.js", "../../../.spago/p/prelude-6.0.1/src/Control/Semigroupoid.purs", "../../../.spago/p/prelude-6.0.1/src/Control/Category.purs", "../../../.spago/p/prelude-6.0.1/src/Data/Boolean.purs", "../../../.spago/p/prelude-6.0.1/src/Data/Function.purs", "../../../output/Data.Functor/foreign.js", "../../../output/Data.Unit/foreign.js", "../../../.spago/p/prelude-6.0.1/src/Data/Functor.purs", "../../../.spago/p/prelude-6.0.1/src/Control/Applicative.purs", "../../../.spago/p/prelude-6.0.1/src/Control/Bind.purs", "../../../output/Effect.Aff/foreign.js", "../../../.spago/p/prelude-6.0.1/src/Control/Monad.purs", "../../../output/Data.Semigroup/foreign.js", "../../../.spago/p/prelude-6.0.1/src/Data/Semigroup.purs", "../../../.spago/p/control-6.0.0/src/Control/Alt.purs", "../../../output/Data.Bounded/foreign.js", "../../../output/Data.Ord/foreign.js", "../../../output/Data.Eq/foreign.js", "../../../.spago/p/prelude-6.0.1/src/Data/Eq.purs", "../../../.spago/p/prelude-6.0.1/src/Data/Ordering.purs", "../../../.spago/p/prelude-6.0.1/src/Data/Ord.purs", "../../../.spago/p/prelude-6.0.1/src/Data/Bounded.purs", "../../../output/Data.Show/foreign.js", "../../../.spago/p/prelude-6.0.1/src/Data/Show.purs", "../../../.spago/p/maybe-6.0.0/src/Data/Maybe.purs", "../../../.spago/p/either-6.1.0/src/Data/Either.purs", "../../../output/Effect/foreign.js", "../../../.spago/p/prelude-6.0.1/src/Data/Monoid.purs", "../../../.spago/p/effect-4.0.0/src/Effect.purs", "../../../output/Effect.Exception/foreign.js", "../../../.spago/p/exceptions-6.1.0/src/Effect/Exception.purs", "../../../.spago/p/transformers-6.1.0/src/Control/Monad/Error/Class.purs", "../../../.spago/p/identity-6.0.0/src/Data/Identity.purs", "../../../output/Effect.Ref/foreign.js", "../../../.spago/p/refs-6.0.0/src/Effect/Ref.purs", "../../../.spago/p/tailrec-6.1.0/src/Control/Monad/Rec/Class.purs", "../../../output/Unsafe.Coerce/foreign.js", "../../../output/Data.HeytingAlgebra/foreign.js", "../../../.spago/p/prelude-6.0.1/src/Data/HeytingAlgebra.purs", "../../../.spago/p/tuples-7.0.0/src/Data/Tuple.purs", "../../../.spago/p/transformers-6.1.0/src/Control/Monad/State/Class.purs", "../../../.spago/p/effect-4.0.0/src/Effect/Class.purs", "../../../.spago/p/transformers-6.1.0/src/Control/Monad/Writer/Class.purs", "../../../.spago/p/control-6.0.0/src/Control/Plus.purs", "../../../.spago/p/safe-coerce-2.0.0/src/Safe/Coerce.purs", "../../../.spago/p/transformers-6.1.0/src/Control/Monad/Writer/Trans.purs", "../../../.spago/p/profunctor-6.0.1/src/Data/Profunctor.purs", "../../../.spago/p/parallel-7.0.0/src/Control/Parallel/Class.purs", "../../../output/Data.Foldable/foreign.js", "../../../.spago/p/bifunctors-6.0.0/src/Data/Bifunctor.purs", "../../../.spago/p/maybe-6.0.0/src/Data/Maybe/First.purs", "../../../.spago/p/foldable-traversable-6.0.0/src/Data/Traversable.purs", "../../../.spago/p/parallel-7.0.0/src/Control/Parallel.purs", "../../../output/Effect.Unsafe/foreign.js", "../../../output/Partial.Unsafe/foreign.js", "../../../output/Partial/foreign.js", "../../../.spago/p/partial-4.0.0/src/Partial.purs", "../../../.spago/p/partial-4.0.0/src/Partial/Unsafe.purs", "../../../.spago/p/aff-8.0.0/src/Effect/Aff/Class.purs", "../../../.spago/p/foldable-traversable-6.0.0/src/Data/Semigroup/Foldable.purs", "../../../.spago/p/nonempty-7.0.0/src/Data/NonEmpty.purs", "../../../.spago/p/lists-7.0.0/src/Data/List/Types.purs", "../../../.spago/p/css-6.0.0/src/CSS/String.purs", "../../../output/Data.Array/foreign.js", "../../../output/Data.Function.Uncurried/foreign.js", "../../../output/Data.Int/foreign.js", "../../../output/Data.Number/foreign.js", "../../../output/Data.String.CodePoints/foreign.js", "../../../.spago/p/control-6.0.0/src/Control/Alternative.purs", "../../../.spago/p/profunctor-6.0.1/src/Data/Profunctor/Strong.purs", "../../../.spago/p/css-6.0.0/src/CSS/Common.purs", "../../../.spago/p/exists-6.0.0/src/Data/Exists.purs", "../../../.spago/p/these-6.0.0/src/Data/These.purs", "../../../output/Effect.Console/foreign.js", "../../../src/Gesso/AspectRatio.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/Query/Input.purs", "../../../output/Data.Nullable/foreign.js", "../../../.spago/p/nullable-6.0.0/src/Data/Nullable.purs", "../../../.spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Machine.purs", "../../../output/Halogen.VDom.Util/foreign.js", "../../../output/Foreign.Object.ST/foreign.js", "../../../.spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Util.purs", "../../../output/Web.DOM.Element/foreign.js", "../../../output/Web.DOM.ParentNode/foreign.js", "../../../.spago/p/web-dom-6.0.0/src/Web/DOM/Element.purs", "../../../output/Foreign/foreign.js", "../../../.spago/p/lists-7.0.0/src/Data/List.purs", "../../../.spago/p/lists-7.0.0/src/Data/List/NonEmpty.purs", "../../../output/Foreign.Object/foreign.js", "../../../.spago/p/foreign-object-4.1.0/src/Foreign/Object.purs", "../../../output/Web.Event.EventTarget/foreign.js", "../../../.spago/p/halogen-7.0.0/src/Halogen/HTML/Core.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/HTML/Properties.purs", "../../../src/Gesso/Application.purs", "../../../output/Graphics.Canvas/foreign.js", "../../../.spago/p/canvas-6.0.0/src/Graphics/Canvas.purs", "../../../output/Web.DOM.NonElementParentNode/foreign.js", "../../../.spago/p/web-dom-6.0.0/src/Web/DOM/NonElementParentNode.purs", "../../../output/Web.HTML/foreign.js", "../../../output/Web.HTML.HTMLDocument/foreign.js", "../../../.spago/p/web-html-4.1.0/src/Web/HTML/HTMLDocument/ReadyState.purs", "../../../output/Web.HTML.HTMLElement/foreign.js", "../../../.spago/p/web-html-4.1.0/src/Web/HTML/HTMLElement.purs", "../../../output/Effect.Uncurried/foreign.js", "../../../output/Web.HTML.Window/foreign.js", "../../../.spago/p/web-html-4.1.0/src/Web/HTML/Window.purs", "../../../src/Gesso/Canvas/Element.purs", "../../../.spago/p/web-html-4.1.0/src/Web/HTML/Event/EventTypes.purs", "../../../output/Gesso.Time/foreign.js", "../../../src/Gesso/Time.purs", "../../../.spago/p/free-7.1.0/src/Data/Coyoneda.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/Data/Slot.purs", "../../../.spago/p/catenable-lists-7.0.0/src/Data/CatQueue.purs", "../../../.spago/p/catenable-lists-7.0.0/src/Data/CatList.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/Query/ChildQuery.purs", "../../../output/Unsafe.Reference/foreign.js", "../../../.spago/p/unsafe-reference-5.0.0/src/Unsafe/Reference.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/Query/HalogenQ.purs", "../../../.spago/p/halogen-vdom-8.0.0/src/Halogen/VDom/Thunk.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/HTML/Elements.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/Query/Event.purs", "../../../src/Gesso/Canvas.purs", "../../../.spago/p/fork-6.0.0/src/Control/Monad/Fork/Class.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/Aff/Driver/State.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/Aff/Driver/Eval.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/Aff/Driver.purs", "../../../.spago/p/halogen-7.0.0/src/Halogen/Aff/Util.purs", "../../../output/Web.DOM.Node/foreign.js", "../src/Main.purs", "<stdin>"],
  "sourcesContent": ["export const arrayBind = function (arr) {\n  return function (f) {\n    var result = [];\n    for (var i = 0, l = arr.length; i < l; i++) {\n      Array.prototype.push.apply(result, f(arr[i]));\n    }\n    return result;\n  };\n};\n", "export const arrayApply = function (fs) {\n  return function (xs) {\n    var l = fs.length;\n    var k = xs.length;\n    var result = new Array(l*k);\n    var n = 0;\n    for (var i = 0; i < l; i++) {\n      var f = fs[i];\n      for (var j = 0; j < k; j++) {\n        result[n++] = f(xs[j]);\n      }\n    }\n    return result;\n  };\n};\n", "module Control.Semigroupoid where\n\n-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not\n-- | require an identity element `identity`, just composable morphisms.\n-- |\n-- | `Semigroupoid`s must satisfy the following law:\n-- |\n-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n-- |\n-- | One example of a `Semigroupoid` is the function type constructor `(->)`,\n-- | with `(<<<)` defined as function composition.\nclass Semigroupoid :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a where\n  compose :: forall b c d. a c d -> a b c -> a b d\n\ninstance semigroupoidFn :: Semigroupoid (->) where\n  compose f g x = f (g x)\n\ninfixr 9 compose as <<<\n\n-- | Forwards composition, or `compose` with its arguments reversed.\ncomposeFlipped :: forall a b c d. Semigroupoid a => a b c -> a c d -> a b d\ncomposeFlipped f g = compose g f\n\ninfixr 9 composeFlipped as >>>\n", "module Control.Category\n  ( class Category\n  , identity\n  , module Control.Semigroupoid\n  ) where\n\nimport Control.Semigroupoid (class Semigroupoid, compose, (<<<), (>>>))\n\n-- | `Category`s consist of objects and composable morphisms between them, and\n-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\n-- | must have an identity element.\n-- |\n-- | Instances must satisfy the following law in addition to the\n-- | `Semigroupoid` law:\n-- |\n-- | - Identity: `identity <<< p = p <<< identity = p`\nclass Category :: forall k. (k -> k -> Type) -> Constraint\nclass Semigroupoid a <= Category a where\n  identity :: forall t. a t t\n\ninstance categoryFn :: Category (->) where\n  identity x = x\n", "module Data.Boolean where\n\n-- | An alias for `true`, which can be useful in guard clauses:\n-- |\n-- | ```purescript\n-- | max x y | x >= y    = x\n-- |         | otherwise = y\n-- | ```\notherwise :: Boolean\notherwise = true\n", "module Data.Function\n  ( flip\n  , const\n  , apply\n  , ($)\n  , applyFlipped\n  , (#)\n  , applyN\n  , on\n  , module Control.Category\n  ) where\n\nimport Control.Category (identity, compose, (<<<), (>>>))\nimport Data.Boolean (otherwise)\nimport Data.Ord ((<=))\nimport Data.Ring ((-))\n\n-- | Given a function that takes two arguments, applies the arguments\n-- | to the function in a swapped order.\n-- |\n-- | ```purescript\n-- | flip append \"1\" \"2\" == append \"2\" \"1\" == \"21\"\n-- |\n-- | const 1 \"two\" == 1\n-- |\n-- | flip const 1 \"two\" == const \"two\" 1 == \"two\"\n-- | ```\nflip :: forall a b c. (a -> b -> c) -> b -> a -> c\nflip f b a = f a b\n\n-- | Returns its first argument and ignores its second.\n-- |\n-- | ```purescript\n-- | const 1 \"hello\" = 1\n-- | ```\n-- |\n-- | It can also be thought of as creating a function that ignores its argument:\n-- |\n-- | ```purescript\n-- | const 1 = \\_ -> 1\n-- | ```\nconst :: forall a b. a -> b -> a\nconst a _ = a\n\n-- | Applies a function to an argument. This is primarily used as the operator\n-- | `($)` which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a chain of composed functions to a value.\napply :: forall a b. (a -> b) -> a -> b\napply f x = f x\n\n-- | Applies a function to an argument: the reverse of `(#)`.\n-- |\n-- | ```purescript\n-- | length $ groupBy productCategory $ filter isInStock $ products\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying chain of composed functions to\n-- | a value:\n-- |\n-- | ```purescript\n-- | length <<< groupBy productCategory <<< filter isInStock $ products\n-- | ```\ninfixr 0 apply as $\n\n-- | Applies an argument to a function. This is primarily used as the `(#)`\n-- | operator, which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a value to a chain of composed functions.\napplyFlipped :: forall a b. a -> (a -> b) -> b\napplyFlipped x f = f x\n\n-- | Applies an argument to a function: the reverse of `($)`.\n-- |\n-- | ```purescript\n-- | products # filter isInStock # groupBy productCategory # length\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying a value to a chain of composed\n-- | functions:\n-- |\n-- | ```purescript\n-- | products # filter isInStock >>> groupBy productCategory >>> length\n-- | ```\ninfixl 1 applyFlipped as #\n\n-- | `applyN f n` applies the function `f` to its argument `n` times.\n-- |\n-- | If n is less than or equal to 0, the function is not applied.\n-- |\n-- | ```purescript\n-- | applyN (_ + 1) 10 0 == 10\n-- | ```\napplyN :: forall a. (a -> a) -> Int -> a -> a\napplyN f = go\n  where\n  go n acc\n    | n <= 0 = acc\n    | otherwise = go (n - 1) (f acc)\n\n-- | The `on` function is used to change the domain of a binary operator.\n-- |\n-- | For example, we can create a function which compares two records based on the values of their `x` properties:\n-- |\n-- | ```purescript\n-- | compareX :: forall r. { x :: Number | r } -> { x :: Number | r } -> Ordering\n-- | compareX = compare `on` _.x\n-- | ```\non :: forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c\non f g x y = g x `f` g y\n", "export const arrayMap = function (f) {\n  return function (arr) {\n    var l = arr.length;\n    var result = new Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(arr[i]);\n    }\n    return result;\n  };\n};\n", "export const unit = undefined;\n", "module Data.Functor\n  ( class Functor\n  , map\n  , (<$>)\n  , mapFlipped\n  , (<#>)\n  , void\n  , voidRight\n  , (<$)\n  , voidLeft\n  , ($>)\n  , flap\n  , (<@>)\n  ) where\n\nimport Data.Function (const, compose)\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Functor` is a type constructor which supports a mapping operation\n-- | `map`.\n-- |\n-- | `map` can be used to turn functions `a -> b` into functions\n-- | `f a -> f b` whose argument and return types use the type constructor `f`\n-- | to represent some computational context.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Identity: `map identity = identity`\n-- | - Composition: `map (f <<< g) = map f <<< map g`\nclass Functor f where\n  map :: forall a b. (a -> b) -> f a -> f b\n\ninfixl 4 map as <$>\n\n-- | `mapFlipped` is `map` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | [1, 2, 3] <#> \\n -> n * n\n-- | ```\nmapFlipped :: forall f a b. Functor f => f a -> (a -> b) -> f b\nmapFlipped fa f = f <$> fa\n\ninfixl 1 mapFlipped as <#>\n\ninstance functorFn :: Functor ((->) r) where\n  map = compose\n\ninstance functorArray :: Functor Array where\n  map = arrayMap\n\ninstance functorProxy :: Functor Proxy where\n  map _ _ = Proxy\n\nforeign import arrayMap :: forall a b. (a -> b) -> Array a -> Array b\n\n-- | The `void` function is used to ignore the type wrapped by a\n-- | [`Functor`](#functor), replacing it with `Unit` and keeping only the type\n-- | information provided by the type constructor itself.\n-- |\n-- | `void` is often useful when using `do` notation to change the return type\n-- | of a monadic computation:\n-- |\n-- | ```purescript\n-- | main = forE 1 10 \\n -> void do\n-- |   print n\n-- |   print (n * n)\n-- | ```\nvoid :: forall f a. Functor f => f a -> f Unit\nvoid = map (const unit)\n\n-- | Ignore the return value of a computation, using the specified return value\n-- | instead.\nvoidRight :: forall f a b. Functor f => a -> f b -> f a\nvoidRight x = map (const x)\n\ninfixl 4 voidRight as <$\n\n-- | A version of `voidRight` with its arguments flipped.\nvoidLeft :: forall f a b. Functor f => f a -> b -> f b\nvoidLeft f x = const x <$> f\n\ninfixl 4 voidLeft as $>\n\n-- | Apply a value in a computational context to a value in no context.\n-- |\n-- | Generalizes `flip`.\n-- |\n-- | ```purescript\n-- | longEnough :: String -> Bool\n-- | hasSymbol :: String -> Bool\n-- | hasDigit :: String -> Bool\n-- | password :: String\n-- |\n-- | validate :: String -> Array Bool\n-- | validate = flap [longEnough, hasSymbol, hasDigit]\n-- | ```\n-- |\n-- | ```purescript\n-- | flap (-) 3 4 == 1\n-- | threeve <$> Just 1 <@> 'a' <*> Just true == Just (threeve 1 'a' true)\n-- | ```\nflap :: forall f a b. Functor f => f (a -> b) -> a -> f b\nflap ff x = map (\\f -> f x) ff\n\ninfixl 4 flap as <@>\n", "module Control.Applicative\n  ( class Applicative\n  , pure\n  , liftA1\n  , unless\n  , when\n  , module Control.Apply\n  , module Data.Functor\n  ) where\n\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit, unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Applicative` type class extends the [`Apply`](#apply) type class\n-- | with a `pure` function, which can be used to create values of type `f a`\n-- | from values of type `a`.\n-- |\n-- | Where [`Apply`](#apply) provides the ability to lift functions of two or\n-- | more arguments to functions whose arguments are wrapped using `f`, and\n-- | [`Functor`](#functor) provides the ability to lift functions of one\n-- | argument, `pure` can be seen as the function which lifts functions of\n-- | _zero_ arguments. That is, `Applicative` functors support a lifting\n-- | operation for any number of function arguments.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Identity: `(pure identity) <*> v = v`\n-- | - Composition: `pure (<<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n-- | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n-- | - Interchange: `u <*> (pure y) = (pure (_ $ y)) <*> u`\nclass Apply f <= Applicative f where\n  pure :: forall a. a -> f a\n\ninstance applicativeFn :: Applicative ((->) r) where\n  pure x _ = x\n\ninstance applicativeArray :: Applicative Array where\n  pure x = [ x ]\n\ninstance applicativeProxy :: Applicative Proxy where\n  pure _ = Proxy\n\n-- | `liftA1` provides a default implementation of `(<$>)` for any\n-- | [`Applicative`](#applicative) functor, without using `(<$>)` as provided\n-- | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\n-- | relationship.\n-- |\n-- | `liftA1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftA1\n-- | ```\nliftA1 :: forall f a b. Applicative f => (a -> b) -> f a -> f b\nliftA1 f a = pure f <*> a\n\n-- | Perform an applicative action when a condition is true.\nwhen :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nwhen true m = m\nwhen false _ = pure unit\n\n-- | Perform an applicative action unless a condition is true.\nunless :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nunless false m = m\nunless true _ = pure unit\n", "module Control.Bind\n  ( class Bind\n  , bind\n  , (>>=)\n  , bindFlipped\n  , (=<<)\n  , class Discard\n  , discard\n  , join\n  , composeKleisli\n  , (>=>)\n  , composeKleisliFlipped\n  , (<=<)\n  , ifM\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Category (identity)\n\nimport Data.Function (flip)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bind` type class extends the [`Apply`](#apply) type class with a\n-- | \"bind\" operation `(>>=)` which composes computations in sequence, using\n-- | the return value of one computation to determine the next computation.\n-- |\n-- | The `>>=` operator can also be expressed using `do` notation, as follows:\n-- |\n-- | ```purescript\n-- | x >>= f = do y <- x\n-- |              f y\n-- | ```\n-- |\n-- | where the function argument of `f` is given the name `y`.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Associativity: `(x >>= f) >>= g = x >>= (\\k -> f k >>= g)`\n-- | - Apply Superclass: `apply f x = f >>= \\f\u2019 -> map f\u2019 x`\n-- |\n-- | Associativity tells us that we can regroup operations which use `do`\n-- | notation so that we can unambiguously write, for example:\n-- |\n-- | ```purescript\n-- | do x <- m1\n-- |    y <- m2 x\n-- |    m3 x y\n-- | ```\nclass Apply m <= Bind m where\n  bind :: forall a b. m a -> (a -> m b) -> m b\n\ninfixl 1 bind as >>=\n\n-- | `bindFlipped` is `bind` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | print =<< random\n-- | ```\nbindFlipped :: forall m a b. Bind m => (a -> m b) -> m a -> m b\nbindFlipped = flip bind\n\ninfixr 1 bindFlipped as =<<\n\ninstance bindFn :: Bind ((->) r) where\n  bind m f x = f (m x) x\n\n-- | The `bind`/`>>=` function for `Array` works by applying a function to\n-- | each element in the array, and flattening the results into a single,\n-- | new array.\n-- |\n-- | Array's `bind`/`>>=` works like a nested for loop. Each `bind` adds\n-- | another level of nesting in the loop. For example:\n-- | ```\n-- | foo :: Array String\n-- | foo =\n-- |   [\"a\", \"b\"] >>= \\eachElementInArray1 ->\n-- |     [\"c\", \"d\"] >>= \\eachElementInArray2\n-- |       pure (eachElementInArray1 <> eachElementInArray2)\n-- |\n-- | -- In other words...\n-- | foo\n-- | -- ... is the same as...\n-- | [ (\"a\" <> \"c\"), (\"a\" <> \"d\"), (\"b\" <> \"c\"), (\"b\" <> \"d\") ]\n-- | -- which simplifies to...\n-- | [ \"ac\", \"ad\", \"bc\", \"bd\" ]\n-- | ```\ninstance bindArray :: Bind Array where\n  bind = arrayBind\n\nforeign import arrayBind :: forall a b. Array a -> (a -> Array b) -> Array b\n\ninstance bindProxy :: Bind Proxy where\n  bind _ _ = Proxy\n\n-- | A class for types whose values can safely be discarded\n-- | in a `do` notation block.\n-- |\n-- | An example is the `Unit` type, since there is only one\n-- | possible value which can be returned.\nclass Discard a where\n  discard :: forall f b. Bind f => f a -> (a -> f b) -> f b\n\ninstance discardUnit :: Discard Unit where\n  discard = bind\n\ninstance discardProxy :: Discard (Proxy a) where\n  discard = bind\n\n-- | Collapse two applications of a monadic type constructor into one.\njoin :: forall a m. Bind m => m (m a) -> m a\njoin m = m >>= identity\n\n-- | Forwards Kleisli composition.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Data.Array (head, tail)\n-- |\n-- | third = tail >=> tail >=> head\n-- | ```\ncomposeKleisli :: forall a b c m. Bind m => (a -> m b) -> (b -> m c) -> a -> m c\ncomposeKleisli f g a = f a >>= g\n\ninfixr 1 composeKleisli as >=>\n\n-- | Backwards Kleisli composition.\ncomposeKleisliFlipped :: forall a b c m. Bind m => (b -> m c) -> (a -> m b) -> a -> m c\ncomposeKleisliFlipped f g a = f =<< g a\n\ninfixr 1 composeKleisliFlipped as <=<\n\n-- | Execute a monadic action if a condition holds.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = ifM ((< 0.5) <$> random)\n-- |          (trace \"Heads\")\n-- |          (trace \"Tails\")\n-- | ```\nifM :: forall a m. Bind m => m Boolean -> m a -> m a -> m a\nifM cond t f = cond >>= \\cond' -> if cond' then t else f\n", "/* globals setImmediate, clearImmediate, setTimeout, clearTimeout */\n/* eslint-disable no-unused-vars, no-prototype-builtins, no-use-before-define, no-unused-labels, no-param-reassign */\nvar Aff = function () {\n  // A unique value for empty.\n  var EMPTY = {};\n\n  /*\n\n  An awkward approximation. We elide evidence we would otherwise need in PS for\n  efficiency sake.\n\n  data Aff eff a\n    = Pure a\n    | Throw Error\n    | Catch (Aff eff a) (Error -> Aff eff a)\n    | Sync (Eff eff a)\n    | Async ((Either Error a -> Eff eff Unit) -> Eff eff (Canceler eff))\n    | forall b. Bind (Aff eff b) (b -> Aff eff a)\n    | forall b. Bracket (Aff eff b) (BracketConditions eff b) (b -> Aff eff a)\n    | forall b. Fork Boolean (Aff eff b) ?(Fiber eff b -> a)\n    | Sequential (ParAff aff a)\n\n  */\n  var PURE    = \"Pure\";\n  var THROW   = \"Throw\";\n  var CATCH   = \"Catch\";\n  var SYNC    = \"Sync\";\n  var ASYNC   = \"Async\";\n  var BIND    = \"Bind\";\n  var BRACKET = \"Bracket\";\n  var FORK    = \"Fork\";\n  var SEQ     = \"Sequential\";\n\n  /*\n\n  data ParAff eff a\n    = forall b. Map (b -> a) (ParAff eff b)\n    | forall b. Apply (ParAff eff (b -> a)) (ParAff eff b)\n    | Alt (ParAff eff a) (ParAff eff a)\n    | ?Par (Aff eff a)\n\n  */\n  var MAP   = \"Map\";\n  var APPLY = \"Apply\";\n  var ALT   = \"Alt\";\n\n  // Various constructors used in interpretation\n  var CONS      = \"Cons\";      // Cons-list, for stacks\n  var RESUME    = \"Resume\";    // Continue indiscriminately\n  var RELEASE   = \"Release\";   // Continue with bracket finalizers\n  var FINALIZER = \"Finalizer\"; // A non-interruptible effect\n  var FINALIZED = \"Finalized\"; // Marker for finalization\n  var FORKED    = \"Forked\";    // Reference to a forked fiber, with resumption stack\n  var FIBER     = \"Fiber\";     // Actual fiber reference\n  var THUNK     = \"Thunk\";     // Primed effect, ready to invoke\n\n  function Aff(tag, _1, _2, _3) {\n    this.tag = tag;\n    this._1  = _1;\n    this._2  = _2;\n    this._3  = _3;\n  }\n\n  function AffCtr(tag) {\n    var fn = function (_1, _2, _3) {\n      return new Aff(tag, _1, _2, _3);\n    };\n    fn.tag = tag;\n    return fn;\n  }\n\n  function nonCanceler(error) {\n    return new Aff(PURE, void 0);\n  }\n\n  function runEff(eff) {\n    try {\n      eff();\n    } catch (error) {\n      setTimeout(function () {\n        throw error;\n      }, 0);\n    }\n  }\n\n  function runSync(left, right, eff) {\n    try {\n      return right(eff());\n    } catch (error) {\n      return left(error);\n    }\n  }\n\n  function runAsync(left, eff, k) {\n    try {\n      return eff(k)();\n    } catch (error) {\n      k(left(error))();\n      return nonCanceler;\n    }\n  }\n\n  var Scheduler = function () {\n    var limit    = 1024;\n    var size     = 0;\n    var ix       = 0;\n    var queue    = new Array(limit);\n    var draining = false;\n\n    function drain() {\n      var thunk;\n      draining = true;\n      while (size !== 0) {\n        size--;\n        thunk     = queue[ix];\n        queue[ix] = void 0;\n        ix        = (ix + 1) % limit;\n        thunk();\n      }\n      draining = false;\n    }\n\n    return {\n      isDraining: function () {\n        return draining;\n      },\n      enqueue: function (cb) {\n        var i, tmp;\n        if (size === limit) {\n          tmp = draining;\n          drain();\n          draining = tmp;\n        }\n\n        queue[(ix + size) % limit] = cb;\n        size++;\n\n        if (!draining) {\n          drain();\n        }\n      }\n    };\n  }();\n\n  function Supervisor(util) {\n    var fibers  = {};\n    var fiberId = 0;\n    var count   = 0;\n\n    return {\n      register: function (fiber) {\n        var fid = fiberId++;\n        fiber.onComplete({\n          rethrow: true,\n          handler: function (result) {\n            return function () {\n              count--;\n              delete fibers[fid];\n            };\n          }\n        })();\n        fibers[fid] = fiber;\n        count++;\n      },\n      isEmpty: function () {\n        return count === 0;\n      },\n      killAll: function (killError, cb) {\n        return function () {\n          if (count === 0) {\n            return cb();\n          }\n\n          var killCount = 0;\n          var kills     = {};\n\n          function kill(fid) {\n            kills[fid] = fibers[fid].kill(killError, function (result) {\n              return function () {\n                delete kills[fid];\n                killCount--;\n                if (util.isLeft(result) && util.fromLeft(result)) {\n                  setTimeout(function () {\n                    throw util.fromLeft(result);\n                  }, 0);\n                }\n                if (killCount === 0) {\n                  cb();\n                }\n              };\n            })();\n          }\n\n          for (var k in fibers) {\n            if (fibers.hasOwnProperty(k)) {\n              killCount++;\n              kill(k);\n            }\n          }\n\n          fibers  = {};\n          fiberId = 0;\n          count   = 0;\n\n          return function (error) {\n            return new Aff(SYNC, function () {\n              for (var k in kills) {\n                if (kills.hasOwnProperty(k)) {\n                  kills[k]();\n                }\n              }\n            });\n          };\n        };\n      }\n    };\n  }\n\n  // Fiber state machine\n  var SUSPENDED   = 0; // Suspended, pending a join.\n  var CONTINUE    = 1; // Interpret the next instruction.\n  var STEP_BIND   = 2; // Apply the next bind.\n  var STEP_RESULT = 3; // Handle potential failure from a result.\n  var PENDING     = 4; // An async effect is running.\n  var RETURN      = 5; // The current stack has returned.\n  var COMPLETED   = 6; // The entire fiber has completed.\n\n  function Fiber(util, supervisor, aff) {\n    // Monotonically increasing tick, increased on each asynchronous turn.\n    var runTick = 0;\n\n    // The current branch of the state machine.\n    var status = SUSPENDED;\n\n    // The current point of interest for the state machine branch.\n    var step      = aff;  // Successful step\n    var fail      = null; // Failure step\n    var interrupt = null; // Asynchronous interrupt\n\n    // Stack of continuations for the current fiber.\n    var bhead = null;\n    var btail = null;\n\n    // Stack of attempts and finalizers for error recovery. Every `Cons` is also\n    // tagged with current `interrupt` state. We use this to track which items\n    // should be ignored or evaluated as a result of a kill.\n    var attempts = null;\n\n    // A special state is needed for Bracket, because it cannot be killed. When\n    // we enter a bracket acquisition or finalizer, we increment the counter,\n    // and then decrement once complete.\n    var bracketCount = 0;\n\n    // Each join gets a new id so they can be revoked.\n    var joinId  = 0;\n    var joins   = null;\n    var rethrow = true;\n\n    // Each invocation of `run` requires a tick. When an asynchronous effect is\n    // resolved, we must check that the local tick coincides with the fiber\n    // tick before resuming. This prevents multiple async continuations from\n    // accidentally resuming the same fiber. A common example may be invoking\n    // the provided callback in `makeAff` more than once, but it may also be an\n    // async effect resuming after the fiber was already cancelled.\n    function run(localRunTick) {\n      var tmp, result, attempt;\n      while (true) {\n        tmp       = null;\n        result    = null;\n        attempt   = null;\n\n        switch (status) {\n        case STEP_BIND:\n          status = CONTINUE;\n          try {\n            step   = bhead(step);\n            if (btail === null) {\n              bhead = null;\n            } else {\n              bhead = btail._1;\n              btail = btail._2;\n            }\n          } catch (e) {\n            status = RETURN;\n            fail   = util.left(e);\n            step   = null;\n          }\n          break;\n\n        case STEP_RESULT:\n          if (util.isLeft(step)) {\n            status = RETURN;\n            fail   = step;\n            step   = null;\n          } else if (bhead === null) {\n            status = RETURN;\n          } else {\n            status = STEP_BIND;\n            step   = util.fromRight(step);\n          }\n          break;\n\n        case CONTINUE:\n          switch (step.tag) {\n          case BIND:\n            if (bhead) {\n              btail = new Aff(CONS, bhead, btail);\n            }\n            bhead  = step._2;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case PURE:\n            if (bhead === null) {\n              status = RETURN;\n              step   = util.right(step._1);\n            } else {\n              status = STEP_BIND;\n              step   = step._1;\n            }\n            break;\n\n          case SYNC:\n            status = STEP_RESULT;\n            step   = runSync(util.left, util.right, step._1);\n            break;\n\n          case ASYNC:\n            status = PENDING;\n            step   = runAsync(util.left, step._1, function (result) {\n              return function () {\n                if (runTick !== localRunTick) {\n                  return;\n                }\n                runTick++;\n                Scheduler.enqueue(function () {\n                  // It's possible to interrupt the fiber between enqueuing and\n                  // resuming, so we need to check that the runTick is still\n                  // valid.\n                  if (runTick !== localRunTick + 1) {\n                    return;\n                  }\n                  status = STEP_RESULT;\n                  step   = result;\n                  run(runTick);\n                });\n              };\n            });\n            return;\n\n          case THROW:\n            status = RETURN;\n            fail   = util.left(step._1);\n            step   = null;\n            break;\n\n          // Enqueue the Catch so that we can call the error handler later on\n          // in case of an exception.\n          case CATCH:\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead    = null;\n            btail    = null;\n            status   = CONTINUE;\n            step     = step._1;\n            break;\n\n          // Enqueue the Bracket so that we can call the appropriate handlers\n          // after resource acquisition.\n          case BRACKET:\n            bracketCount++;\n            if (bhead === null) {\n              attempts = new Aff(CONS, step, attempts, interrupt);\n            } else {\n              attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n            }\n            bhead  = null;\n            btail  = null;\n            status = CONTINUE;\n            step   = step._1;\n            break;\n\n          case FORK:\n            status = STEP_RESULT;\n            tmp    = Fiber(util, supervisor, step._2);\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n            if (step._1) {\n              tmp.run();\n            }\n            step = util.right(tmp);\n            break;\n\n          case SEQ:\n            status = CONTINUE;\n            step   = sequential(util, supervisor, step._1);\n            break;\n          }\n          break;\n\n        case RETURN:\n          bhead = null;\n          btail = null;\n          // If the current stack has returned, and we have no other stacks to\n          // resume or finalizers to run, the fiber has halted and we can\n          // invoke all join callbacks. Otherwise we need to resume.\n          if (attempts === null) {\n            status = COMPLETED;\n            step   = interrupt || fail || step;\n          } else {\n            // The interrupt status for the enqueued item.\n            tmp      = attempts._3;\n            attempt  = attempts._1;\n            attempts = attempts._2;\n\n            switch (attempt.tag) {\n            // We cannot recover from an unmasked interrupt. Otherwise we should\n            // continue stepping, or run the exception handler if an exception\n            // was raised.\n            case CATCH:\n              // We should compare the interrupt status as well because we\n              // only want it to apply if there has been an interrupt since\n              // enqueuing the catch.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                status = RETURN;\n              } else if (fail) {\n                status = CONTINUE;\n                step   = attempt._2(util.fromLeft(fail));\n                fail   = null;\n              }\n              break;\n\n            // We cannot resume from an unmasked interrupt or exception.\n            case RESUME:\n              // As with Catch, we only want to ignore in the case of an\n              // interrupt since enqueing the item.\n              if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {\n                status = RETURN;\n              } else {\n                bhead  = attempt._1;\n                btail  = attempt._2;\n                status = STEP_BIND;\n                step   = util.fromRight(step);\n              }\n              break;\n\n            // If we have a bracket, we should enqueue the handlers,\n            // and continue with the success branch only if the fiber has\n            // not been interrupted. If the bracket acquisition failed, we\n            // should not run either.\n            case BRACKET:\n              bracketCount--;\n              if (fail === null) {\n                result   = util.fromRight(step);\n                // We need to enqueue the Release with the same interrupt\n                // status as the Bracket that is initiating it.\n                attempts = new Aff(CONS, new Aff(RELEASE, attempt._2, result), attempts, tmp);\n                // We should only coninue as long as the interrupt status has not changed or\n                // we are currently within a non-interruptable finalizer.\n                if (interrupt === tmp || bracketCount > 0) {\n                  status = CONTINUE;\n                  step   = attempt._3(result);\n                }\n              }\n              break;\n\n            // Enqueue the appropriate handler. We increase the bracket count\n            // because it should not be cancelled.\n            case RELEASE:\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              // It has only been killed if the interrupt status has changed\n              // since we enqueued the item, and the bracket count is 0. If the\n              // bracket count is non-zero then we are in a masked state so it's\n              // impossible to be killed.\n              if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                step = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);\n              } else if (fail) {\n                step = attempt._1.failed(util.fromLeft(fail))(attempt._2);\n              } else {\n                step = attempt._1.completed(util.fromRight(step))(attempt._2);\n              }\n              fail = null;\n              bracketCount++;\n              break;\n\n            case FINALIZER:\n              bracketCount++;\n              attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n              status   = CONTINUE;\n              step     = attempt._1;\n              break;\n\n            case FINALIZED:\n              bracketCount--;\n              status = RETURN;\n              step   = attempt._1;\n              fail   = attempt._2;\n              break;\n            }\n          }\n          break;\n\n        case COMPLETED:\n          for (var k in joins) {\n            if (joins.hasOwnProperty(k)) {\n              rethrow = rethrow && joins[k].rethrow;\n              runEff(joins[k].handler(step));\n            }\n          }\n          joins = null;\n          // If we have an interrupt and a fail, then the thread threw while\n          // running finalizers. This should always rethrow in a fresh stack.\n          if (interrupt && fail) {\n            setTimeout(function () {\n              throw util.fromLeft(fail);\n            }, 0);\n          // If we have an unhandled exception, and no other fiber has joined\n          // then we need to throw the exception in a fresh stack.\n          } else if (util.isLeft(step) && rethrow) {\n            setTimeout(function () {\n              // Guard on reathrow because a completely synchronous fiber can\n              // still have an observer which was added after-the-fact.\n              if (rethrow) {\n                throw util.fromLeft(step);\n              }\n            }, 0);\n          }\n          return;\n        case SUSPENDED:\n          status = CONTINUE;\n          break;\n        case PENDING: return;\n        }\n      }\n    }\n\n    function onComplete(join) {\n      return function () {\n        if (status === COMPLETED) {\n          rethrow = rethrow && join.rethrow;\n          join.handler(step)();\n          return function () {};\n        }\n\n        var jid    = joinId++;\n        joins      = joins || {};\n        joins[jid] = join;\n\n        return function() {\n          if (joins !== null) {\n            delete joins[jid];\n          }\n        };\n      };\n    }\n\n    function kill(error, cb) {\n      return function () {\n        if (status === COMPLETED) {\n          cb(util.right(void 0))();\n          return function () {};\n        }\n\n        var canceler = onComplete({\n          rethrow: false,\n          handler: function (/* unused */) {\n            return cb(util.right(void 0));\n          }\n        })();\n\n        switch (status) {\n        case SUSPENDED:\n          interrupt = util.left(error);\n          status    = COMPLETED;\n          step      = interrupt;\n          run(runTick);\n          break;\n        case PENDING:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            if (status === PENDING) {\n              attempts = new Aff(CONS, new Aff(FINALIZER, step(error)), attempts, interrupt);\n            }\n            status   = RETURN;\n            step     = null;\n            fail     = null;\n            run(++runTick);\n          }\n          break;\n        default:\n          if (interrupt === null) {\n            interrupt = util.left(error);\n          }\n          if (bracketCount === 0) {\n            status = RETURN;\n            step   = null;\n            fail   = null;\n          }\n        }\n\n        return canceler;\n      };\n    }\n\n    function join(cb) {\n      return function () {\n        var canceler = onComplete({\n          rethrow: false,\n          handler: cb\n        })();\n        if (status === SUSPENDED) {\n          run(runTick);\n        }\n        return canceler;\n      };\n    }\n\n    return {\n      kill: kill,\n      join: join,\n      onComplete: onComplete,\n      isSuspended: function () {\n        return status === SUSPENDED;\n      },\n      run: function () {\n        if (status === SUSPENDED) {\n          if (!Scheduler.isDraining()) {\n            Scheduler.enqueue(function () {\n              run(runTick);\n            });\n          } else {\n            run(runTick);\n          }\n        }\n      }\n    };\n  }\n\n  function runPar(util, supervisor, par, cb) {\n    // Table of all forked fibers.\n    var fiberId   = 0;\n    var fibers    = {};\n\n    // Table of currently running cancelers, as a product of `Alt` behavior.\n    var killId    = 0;\n    var kills     = {};\n\n    // Error used for early cancelation on Alt branches.\n    var early     = new Error(\"[ParAff] Early exit\");\n\n    // Error used to kill the entire tree.\n    var interrupt = null;\n\n    // The root pointer of the tree.\n    var root      = EMPTY;\n\n    // Walks a tree, invoking all the cancelers. Returns the table of pending\n    // cancellation fibers.\n    function kill(error, par, cb) {\n      var step  = par;\n      var head  = null;\n      var tail  = null;\n      var count = 0;\n      var kills = {};\n      var tmp, kid;\n\n      loop: while (true) {\n        tmp = null;\n\n        switch (step.tag) {\n        case FORKED:\n          if (step._3 === EMPTY) {\n            tmp = fibers[step._1];\n            kills[count++] = tmp.kill(error, function (result) {\n              return function () {\n                count--;\n                if (count === 0) {\n                  cb(result)();\n                }\n              };\n            });\n          }\n          // Terminal case.\n          if (head === null) {\n            break loop;\n          }\n          // Go down the right side of the tree.\n          step = head._2;\n          if (tail === null) {\n            head = null;\n          } else {\n            head = tail._1;\n            tail = tail._2;\n          }\n          break;\n        case MAP:\n          step = step._2;\n          break;\n        case APPLY:\n        case ALT:\n          if (head) {\n            tail = new Aff(CONS, head, tail);\n          }\n          head = step;\n          step = step._1;\n          break;\n        }\n      }\n\n      if (count === 0) {\n        cb(util.right(void 0))();\n      } else {\n        // Run the cancelation effects. We alias `count` because it's mutable.\n        kid = 0;\n        tmp = count;\n        for (; kid < tmp; kid++) {\n          kills[kid] = kills[kid]();\n        }\n      }\n\n      return kills;\n    }\n\n    // When a fiber resolves, we need to bubble back up the tree with the\n    // result, computing the applicative nodes.\n    function join(result, head, tail) {\n      var fail, step, lhs, rhs, tmp, kid;\n\n      if (util.isLeft(result)) {\n        fail = result;\n        step = null;\n      } else {\n        step = result;\n        fail = null;\n      }\n\n      loop: while (true) {\n        lhs = null;\n        rhs = null;\n        tmp = null;\n        kid = null;\n\n        // We should never continue if the entire tree has been interrupted.\n        if (interrupt !== null) {\n          return;\n        }\n\n        // We've made it all the way to the root of the tree, which means\n        // the tree has fully evaluated.\n        if (head === null) {\n          cb(fail || step)();\n          return;\n        }\n\n        // The tree has already been computed, so we shouldn't try to do it\n        // again. This should never happen.\n        // TODO: Remove this?\n        if (head._3 !== EMPTY) {\n          return;\n        }\n\n        switch (head.tag) {\n        case MAP:\n          if (fail === null) {\n            head._3 = util.right(head._1(util.fromRight(step)));\n            step    = head._3;\n          } else {\n            head._3 = fail;\n          }\n          break;\n        case APPLY:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // If we have a failure we should kill the other side because we\n          // can't possible yield a result anymore.\n          if (fail) {\n            head._3 = fail;\n            tmp     = true;\n            kid     = killId++;\n\n            kills[kid] = kill(early, fail === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(fail, null, null);\n                } else {\n                  join(fail, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          } else if (lhs === EMPTY || rhs === EMPTY) {\n            // We can only proceed if both sides have resolved.\n            return;\n          } else {\n            step    = util.right(util.fromRight(lhs)(util.fromRight(rhs)));\n            head._3 = step;\n          }\n          break;\n        case ALT:\n          lhs = head._1._3;\n          rhs = head._2._3;\n          // We can only proceed if both have resolved or we have a success\n          if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {\n            return;\n          }\n          // If both sides resolve with an error, we should continue with the\n          // first error\n          if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {\n            fail    = step === lhs ? rhs : lhs;\n            step    = null;\n            head._3 = fail;\n          } else {\n            head._3 = step;\n            tmp     = true;\n            kid     = killId++;\n            // Once a side has resolved, we need to cancel the side that is still\n            // pending before we can continue.\n            kills[kid] = kill(early, step === lhs ? head._2 : head._1, function (/* unused */) {\n              return function () {\n                delete kills[kid];\n                if (tmp) {\n                  tmp = false;\n                } else if (tail === null) {\n                  join(step, null, null);\n                } else {\n                  join(step, tail._1, tail._2);\n                }\n              };\n            });\n\n            if (tmp) {\n              tmp = false;\n              return;\n            }\n          }\n          break;\n        }\n\n        if (tail === null) {\n          head = null;\n        } else {\n          head = tail._1;\n          tail = tail._2;\n        }\n      }\n    }\n\n    function resolve(fiber) {\n      return function (result) {\n        return function () {\n          delete fibers[fiber._1];\n          fiber._3 = result;\n          join(result, fiber._2._1, fiber._2._2);\n        };\n      };\n    }\n\n    // Walks the applicative tree, substituting non-applicative nodes with\n    // `FORKED` nodes. In this tree, all applicative nodes use the `_3` slot\n    // as a mutable slot for memoization. In an unresolved state, the `_3`\n    // slot is `EMPTY`. In the cases of `ALT` and `APPLY`, we always walk\n    // the left side first, because both operations are left-associative. As\n    // we `RETURN` from those branches, we then walk the right side.\n    function run() {\n      var status = CONTINUE;\n      var step   = par;\n      var head   = null;\n      var tail   = null;\n      var tmp, fid;\n\n      loop: while (true) {\n        tmp = null;\n        fid = null;\n\n        switch (status) {\n        case CONTINUE:\n          switch (step.tag) {\n          case MAP:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(MAP, step._1, EMPTY, EMPTY);\n            step = step._2;\n            break;\n          case APPLY:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(APPLY, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          case ALT:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n            head = new Aff(ALT, EMPTY, step._2, EMPTY);\n            step = step._1;\n            break;\n          default:\n            // When we hit a leaf value, we suspend the stack in the `FORKED`.\n            // When the fiber resolves, it can bubble back up the tree.\n            fid    = fiberId++;\n            status = RETURN;\n            tmp    = step;\n            step   = new Aff(FORKED, fid, new Aff(CONS, head, tail), EMPTY);\n            tmp    = Fiber(util, supervisor, tmp);\n            tmp.onComplete({\n              rethrow: false,\n              handler: resolve(step)\n            })();\n            fibers[fid] = tmp;\n            if (supervisor) {\n              supervisor.register(tmp);\n            }\n          }\n          break;\n        case RETURN:\n          // Terminal case, we are back at the root.\n          if (head === null) {\n            break loop;\n          }\n          // If we are done with the right side, we need to continue down the\n          // left. Otherwise we should continue up the stack.\n          if (head._1 === EMPTY) {\n            head._1 = step;\n            status  = CONTINUE;\n            step    = head._2;\n            head._2 = EMPTY;\n          } else {\n            head._2 = step;\n            step    = head;\n            if (tail === null) {\n              head  = null;\n            } else {\n              head  = tail._1;\n              tail  = tail._2;\n            }\n          }\n        }\n      }\n\n      // Keep a reference to the tree root so it can be cancelled.\n      root = step;\n\n      for (fid = 0; fid < fiberId; fid++) {\n        fibers[fid].run();\n      }\n    }\n\n    // Cancels the entire tree. If there are already subtrees being canceled,\n    // we need to first cancel those joins. We will then add fresh joins for\n    // all pending branches including those that were in the process of being\n    // canceled.\n    function cancel(error, cb) {\n      interrupt = util.left(error);\n      var innerKills;\n      for (var kid in kills) {\n        if (kills.hasOwnProperty(kid)) {\n          innerKills = kills[kid];\n          for (kid in innerKills) {\n            if (innerKills.hasOwnProperty(kid)) {\n              innerKills[kid]();\n            }\n          }\n        }\n      }\n\n      kills = null;\n      var newKills = kill(error, root, cb);\n\n      return function (killError) {\n        return new Aff(ASYNC, function (killCb) {\n          return function () {\n            for (var kid in newKills) {\n              if (newKills.hasOwnProperty(kid)) {\n                newKills[kid]();\n              }\n            }\n            return nonCanceler;\n          };\n        });\n      };\n    }\n\n    run();\n\n    return function (killError) {\n      return new Aff(ASYNC, function (killCb) {\n        return function () {\n          return cancel(killError, killCb);\n        };\n      });\n    };\n  }\n\n  function sequential(util, supervisor, par) {\n    return new Aff(ASYNC, function (cb) {\n      return function () {\n        return runPar(util, supervisor, par, cb);\n      };\n    });\n  }\n\n  Aff.EMPTY       = EMPTY;\n  Aff.Pure        = AffCtr(PURE);\n  Aff.Throw       = AffCtr(THROW);\n  Aff.Catch       = AffCtr(CATCH);\n  Aff.Sync        = AffCtr(SYNC);\n  Aff.Async       = AffCtr(ASYNC);\n  Aff.Bind        = AffCtr(BIND);\n  Aff.Bracket     = AffCtr(BRACKET);\n  Aff.Fork        = AffCtr(FORK);\n  Aff.Seq         = AffCtr(SEQ);\n  Aff.ParMap      = AffCtr(MAP);\n  Aff.ParApply    = AffCtr(APPLY);\n  Aff.ParAlt      = AffCtr(ALT);\n  Aff.Fiber       = Fiber;\n  Aff.Supervisor  = Supervisor;\n  Aff.Scheduler   = Scheduler;\n  Aff.nonCanceler = nonCanceler;\n\n  return Aff;\n}();\n\nexport const _pure = Aff.Pure;\nexport const _throwError = Aff.Throw;\n\nexport function _catchError(aff) {\n  return function (k) {\n    return Aff.Catch(aff, k);\n  };\n}\n\nexport function _map(f) {\n  return function (aff) {\n    if (aff.tag === Aff.Pure.tag) {\n      return Aff.Pure(f(aff._1));\n    } else {\n      return Aff.Bind(aff, function (value) {\n        return Aff.Pure(f(value));\n      });\n    }\n  };\n}\n\nexport function _bind(aff) {\n  return function (k) {\n    return Aff.Bind(aff, k);\n  };\n}\n\nexport function _fork(immediate) {\n  return function (aff) {\n    return Aff.Fork(immediate, aff);\n  };\n}\n\nexport const _liftEffect = Aff.Sync;\n\nexport function _parAffMap(f) {\n  return function (aff) {\n    return Aff.ParMap(f, aff);\n  };\n}\n\nexport function _parAffApply(aff1) {\n  return function (aff2) {\n    return Aff.ParApply(aff1, aff2);\n  };\n}\n\nexport function _parAffAlt(aff1) {\n  return function (aff2) {\n    return Aff.ParAlt(aff1, aff2);\n  };\n}\n\nexport const makeAff = Aff.Async;\n\nexport function generalBracket(acquire) {\n  return function (options) {\n    return function (k) {\n      return Aff.Bracket(acquire, options, k);\n    };\n  };\n}\n\nexport function _makeFiber(util, aff) {\n  return function () {\n    return Aff.Fiber(util, null, aff);\n  };\n}\n\nexport function _makeSupervisedFiber(util, aff) {\n  return function () {\n    var supervisor = Aff.Supervisor(util);\n    return {\n      fiber: Aff.Fiber(util, supervisor, aff),\n      supervisor: supervisor\n    };\n  };\n}\n\nexport function _killAll(error, supervisor, cb) {\n  return supervisor.killAll(error, cb);\n}\n\nexport const _delay = function () {\n  function setDelay(n, k) {\n    if (n === 0 && typeof setImmediate !== \"undefined\") {\n      return setImmediate(k);\n    } else {\n      return setTimeout(k, n);\n    }\n  }\n\n  function clearDelay(n, t) {\n    if (n === 0 && typeof clearImmediate !== \"undefined\") {\n      return clearImmediate(t);\n    } else {\n      return clearTimeout(t);\n    }\n  }\n\n  return function (right, ms) {\n    return Aff.Async(function (cb) {\n      return function () {\n        var timer = setDelay(ms, cb(right()));\n        return function () {\n          return Aff.Sync(function () {\n            return right(clearDelay(ms, timer));\n          });\n        };\n      };\n    });\n  };\n}();\n\nexport const _sequential = Aff.Seq;\n", "module Control.Monad\n  ( class Monad\n  , liftM1\n  , whenM\n  , unlessM\n  , ap\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  , module Control.Bind\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Bind (class Bind, bind, ifM, join, (<=<), (=<<), (>=>), (>>=))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\nimport Type.Proxy (Proxy)\n\n-- | The `Monad` type class combines the operations of the `Bind` and\n-- | `Applicative` type classes. Therefore, `Monad` instances represent type\n-- | constructors which support sequential composition, and also lifting of\n-- | functions of arbitrary arity.\n-- |\n-- | Instances must satisfy the following laws in addition to the\n-- | `Applicative` and `Bind` laws:\n-- |\n-- | - Left Identity: `pure x >>= f = f x`\n-- | - Right Identity: `x >>= pure = x`\nclass (Applicative m, Bind m) <= Monad m\n\ninstance monadFn :: Monad ((->) r)\n\ninstance monadArray :: Monad Array\n\ninstance monadProxy :: Monad Proxy\n\n-- | `liftM1` provides a default implementation of `(<$>)` for any\n-- | [`Monad`](#monad), without using `(<$>)` as provided by the\n-- | [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n-- |\n-- | `liftM1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftM1\n-- | ```\nliftM1 :: forall m a b. Monad m => (a -> b) -> m a -> m b\nliftM1 f a = do\n  a' <- a\n  pure (f a')\n\n-- | Perform a monadic action when a condition is true, where the conditional\n-- | value is also in a monadic context.\nwhenM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nwhenM mb m = do\n  b <- mb\n  when b m\n\n-- | Perform a monadic action unless a condition is true, where the conditional\n-- | value is also in a monadic context.\nunlessM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nunlessM mb m = do\n  b <- mb\n  unless b m\n\n-- | `ap` provides a default implementation of `(<*>)` for any `Monad`, without\n-- | using `(<*>)` as provided by the `Apply`-`Monad` superclass relationship.\n-- |\n-- | `ap` can therefore be used to write `Apply` instances as follows:\n-- |\n-- | ```purescript\n-- | instance applyF :: Apply F where\n-- |   apply = ap\n-- | ```\n-- Note: Only a `Bind` constraint is needed, but this can\n-- produce loops when used with other default implementations\n-- (i.e. `liftA1`).\n-- See https://github.com/purescript/purescript-prelude/issues/232\nap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\nap f a = do\n  f' <- f\n  a' <- a\n  pure (f' a')\n", "export const concatString = function (s1) {\n  return function (s2) {\n    return s1 + s2;\n  };\n};\n\nexport const concatArray = function (xs) {\n  return function (ys) {\n    if (xs.length === 0) return ys;\n    if (ys.length === 0) return xs;\n    return xs.concat(ys);\n  };\n};\n", "module Data.Semigroup\n  ( class Semigroup\n  , append\n  , (<>)\n  , class SemigroupRecord\n  , appendRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Semigroup` type class identifies an associative operation on a type.\n-- |\n-- | Instances are required to satisfy the following law:\n-- |\n-- | - Associativity: `(x <> y) <> z = x <> (y <> z)`\n-- |\n-- | One example of a `Semigroup` is `String`, with `(<>)` defined as string\n-- | concatenation. Another example is `List a`, with `(<>)` defined as\n-- | list concatenation.\n-- |\n-- | ### Newtypes for Semigroup\n-- |\n-- | There are two other ways to implement an instance for this type class\n-- | regardless of which type is used. These instances can be used by\n-- | wrapping the values in one of the two newtypes below:\n-- | 1. `First` - Use the first argument every time: `append first _ = first`.\n-- | 2. `Last` - Use the last argument every time: `append _ last = last`.\nclass Semigroup a where\n  append :: a -> a -> a\n\ninfixr 5 append as <>\n\ninstance semigroupString :: Semigroup String where\n  append = concatString\n\ninstance semigroupUnit :: Semigroup Unit where\n  append _ _ = unit\n\ninstance semigroupVoid :: Semigroup Void where\n  append _ = absurd\n\ninstance semigroupFn :: Semigroup s' => Semigroup (s -> s') where\n  append f g x = f x <> g x\n\ninstance semigroupArray :: Semigroup (Array a) where\n  append = concatArray\n\ninstance semigroupProxy :: Semigroup (Proxy a) where\n  append _ _ = Proxy\n\ninstance semigroupRecord :: (RL.RowToList row list, SemigroupRecord list row row) => Semigroup (Record row) where\n  append = appendRecord (Proxy :: Proxy list)\n\nforeign import concatString :: String -> String -> String\nforeign import concatArray :: forall a. Array a -> Array a -> Array a\n\n-- | A class for records where all fields have `Semigroup` instances, used to\n-- | implement the `Semigroup` instance for records.\nclass SemigroupRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow | rowlist -> subrow where\n  appendRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance semigroupRecordNil :: SemigroupRecord RL.Nil row () where\n  appendRecord _ _ _ = {}\n\ninstance semigroupRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , SemigroupRecord rowlistTail row subrowTail\n  , Semigroup focus\n  ) =>\n  SemigroupRecord (RL.Cons key focus rowlistTail) row subrow where\n  appendRecord _ ra rb = insert (get ra <> get rb) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = appendRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Control.Alt\n  ( class Alt, alt, (<|>)\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Semigroup (append)\n\n-- | The `Alt` type class identifies an associative operation on a type\n-- | constructor.  It is similar to `Semigroup`, except that it applies to\n-- | types of kind `* -> *`, like `Array` or `List`, rather than concrete types\n-- | `String` or `Number`.\n-- |\n-- | `Alt` instances are required to satisfy the following laws:\n-- |\n-- | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`\n-- | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`\n-- |\n-- | For example, the `Array` (`[]`) type is an instance of `Alt`, where\n-- | `(<|>)` is defined to be concatenation.\n-- |\n-- | A common use case is to select the first \"valid\" item, or, if all items\n-- | are \"invalid\", the last \"invalid\" item.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Control.Alt ((<|>))\n-- | import Data.Maybe (Maybe(..)\n-- | import Data.Either (Either(..))\n-- |\n-- | Nothing <|> Just 1 <|> Just 2 == Just 1\n-- | Left \"err\" <|> Right 1 <|> Right 2 == Right 1\n-- | Left \"err 1\" <|> Left \"err 2\" <|> Left \"err 3\" == Left \"err 3\"\n-- | ```\nclass Functor f <= Alt f where\n  alt :: forall a. f a -> f a -> f a\n\ninfixr 3 alt as <|>\n\ninstance altArray :: Alt Array where\n  alt = append\n", "export const topInt = 2147483647;\nexport const bottomInt = -2147483648;\n\nexport const topChar = String.fromCharCode(65535);\nexport const bottomChar = String.fromCharCode(0);\n\nexport const topNumber = Number.POSITIVE_INFINITY;\nexport const bottomNumber = Number.NEGATIVE_INFINITY;\n", "var unsafeCompareImpl = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (x) {\n        return function (y) {\n          return x < y ? lt : x === y ? eq : gt;\n        };\n      };\n    };\n  };\n};\n\nexport const ordBooleanImpl = unsafeCompareImpl;\nexport const ordIntImpl = unsafeCompareImpl;\nexport const ordNumberImpl = unsafeCompareImpl;\nexport const ordStringImpl = unsafeCompareImpl;\nexport const ordCharImpl = unsafeCompareImpl;\n\nexport const ordArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var i = 0;\n      var xlen = xs.length;\n      var ylen = ys.length;\n      while (i < xlen && i < ylen) {\n        var x = xs[i];\n        var y = ys[i];\n        var o = f(x)(y);\n        if (o !== 0) {\n          return o;\n        }\n        i++;\n      }\n      if (xlen === ylen) {\n        return 0;\n      } else if (xlen > ylen) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n  };\n};\n", "var refEq = function (r1) {\n  return function (r2) {\n    return r1 === r2;\n  };\n};\n\nexport const eqBooleanImpl = refEq;\nexport const eqIntImpl = refEq;\nexport const eqNumberImpl = refEq;\nexport const eqCharImpl = refEq;\nexport const eqStringImpl = refEq;\n\nexport const eqArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      if (xs.length !== ys.length) return false;\n      for (var i = 0; i < xs.length; i++) {\n        if (!f(xs[i])(ys[i])) return false;\n      }\n      return true;\n    };\n  };\n};\n", "module Data.Eq\n  ( class Eq\n  , eq\n  , (==)\n  , notEq\n  , (/=)\n  , class Eq1\n  , eq1\n  , notEq1\n  , class EqRecord\n  , eqRecord\n  ) where\n\nimport Data.HeytingAlgebra ((&&))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Eq` type class represents types which support decidable equality.\n-- |\n-- | `Eq` instances should satisfy the following laws:\n-- |\n-- | - Reflexivity: `x == x = true`\n-- | - Symmetry: `x == y = y == x`\n-- | - Transitivity: if `x == y` and `y == z` then `x == z`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN /= NaN`. Additionally,\n-- | computing with `Number` can result in a loss of precision, so sometimes\n-- | values that should be equivalent are not.\nclass Eq a where\n  eq :: a -> a -> Boolean\n\ninfix 4 eq as ==\n\n-- | `notEq` tests whether one value is _not equal_ to another. Shorthand for\n-- | `not (eq x y)`.\nnotEq :: forall a. Eq a => a -> a -> Boolean\nnotEq x y = (x == y) == false\n\ninfix 4 notEq as /=\n\ninstance eqBoolean :: Eq Boolean where\n  eq = eqBooleanImpl\n\ninstance eqInt :: Eq Int where\n  eq = eqIntImpl\n\ninstance eqNumber :: Eq Number where\n  eq = eqNumberImpl\n\ninstance eqChar :: Eq Char where\n  eq = eqCharImpl\n\ninstance eqString :: Eq String where\n  eq = eqStringImpl\n\ninstance eqUnit :: Eq Unit where\n  eq _ _ = true\n\ninstance eqVoid :: Eq Void where\n  eq _ _ = true\n\ninstance eqArray :: Eq a => Eq (Array a) where\n  eq = eqArrayImpl eq\n\ninstance eqRec :: (RL.RowToList row list, EqRecord list row) => Eq (Record row) where\n  eq = eqRecord (Proxy :: Proxy list)\n\ninstance eqProxy :: Eq (Proxy a) where\n  eq _ _ = true\n\nforeign import eqBooleanImpl :: Boolean -> Boolean -> Boolean\nforeign import eqIntImpl :: Int -> Int -> Boolean\nforeign import eqNumberImpl :: Number -> Number -> Boolean\nforeign import eqCharImpl :: Char -> Char -> Boolean\nforeign import eqStringImpl :: String -> String -> Boolean\n\nforeign import eqArrayImpl :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Boolean\n\n-- | The `Eq1` type class represents type constructors with decidable equality.\nclass Eq1 f where\n  eq1 :: forall a. Eq a => f a -> f a -> Boolean\n\ninstance eq1Array :: Eq1 Array where\n  eq1 = eq\n\nnotEq1 :: forall f a. Eq1 f => Eq a => f a -> f a -> Boolean\nnotEq1 x y = (x `eq1` y) == false\n\n-- | A class for records where all fields have `Eq` instances, used to implement\n-- | the `Eq` instance for records.\nclass EqRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row where\n  eqRecord :: Proxy rowlist -> Record row -> Record row -> Boolean\n\ninstance eqRowNil :: EqRecord RL.Nil row where\n  eqRecord _ _ _ = true\n\ninstance eqRowCons ::\n  ( EqRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Eq focus\n  ) =>\n  EqRecord (RL.Cons key focus rowlistTail) row where\n  eqRecord _ ra rb = (get ra == get rb) && tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    tail = eqRecord (Proxy :: Proxy rowlistTail) ra rb\n", "module Data.Ordering (Ordering(..), invert) where\n\nimport Data.Eq (class Eq)\nimport Data.Semigroup (class Semigroup)\nimport Data.Show (class Show)\n\n-- | The `Ordering` data type represents the three possible outcomes of\n-- | comparing two values:\n-- |\n-- | `LT` - The first value is _less than_ the second.\n-- | `GT` - The first value is _greater than_ the second.\n-- | `EQ` - The first value is _equal to_ the second.\ndata Ordering = LT | GT | EQ\n\ninstance eqOrdering :: Eq Ordering where\n  eq LT LT = true\n  eq GT GT = true\n  eq EQ EQ = true\n  eq _ _ = false\n\ninstance semigroupOrdering :: Semigroup Ordering where\n  append LT _ = LT\n  append GT _ = GT\n  append EQ y = y\n\ninstance showOrdering :: Show Ordering where\n  show LT = \"LT\"\n  show GT = \"GT\"\n  show EQ = \"EQ\"\n\n-- | Reverses an `Ordering` value, flipping greater than for less than while\n-- | preserving equality.\ninvert :: Ordering -> Ordering\ninvert GT = LT\ninvert EQ = EQ\ninvert LT = GT\n", "module Data.Ord\n  ( class Ord\n  , compare\n  , class Ord1\n  , compare1\n  , lessThan\n  , (<)\n  , lessThanOrEq\n  , (<=)\n  , greaterThan\n  , (>)\n  , greaterThanOrEq\n  , (>=)\n  , comparing\n  , min\n  , max\n  , clamp\n  , between\n  , abs\n  , signum\n  , module Data.Ordering\n  , class OrdRecord\n  , compareRecord\n  ) where\n\nimport Data.Eq (class Eq, class Eq1, class EqRecord, (/=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Ordering (Ordering(..))\nimport Data.Ring (class Ring, zero, one, negate)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Ord` type class represents types which support comparisons with a\n-- | _total order_.\n-- |\n-- | `Ord` instances should satisfy the laws of total orderings:\n-- |\n-- | - Reflexivity: `a <= a`\n-- | - Antisymmetry: if `a <= b` and `b <= a` then `a == b`\n-- | - Transitivity: if `a <= b` and `b <= c` then `a <= c`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN <= NaN` evaluates to `false`\nclass Eq a <= Ord a where\n  compare :: a -> a -> Ordering\n\ninstance ordBoolean :: Ord Boolean where\n  compare = ordBooleanImpl LT EQ GT\n\ninstance ordInt :: Ord Int where\n  compare = ordIntImpl LT EQ GT\n\ninstance ordNumber :: Ord Number where\n  compare = ordNumberImpl LT EQ GT\n\ninstance ordString :: Ord String where\n  compare = ordStringImpl LT EQ GT\n\ninstance ordChar :: Ord Char where\n  compare = ordCharImpl LT EQ GT\n\ninstance ordUnit :: Ord Unit where\n  compare _ _ = EQ\n\ninstance ordVoid :: Ord Void where\n  compare _ _ = EQ\n\ninstance ordProxy :: Ord (Proxy a) where\n  compare _ _ = EQ\n\ninstance ordArray :: Ord a => Ord (Array a) where\n  compare = \\xs ys -> compare 0 (ordArrayImpl toDelta xs ys)\n    where\n    toDelta x y =\n      case compare x y of\n        EQ -> 0\n        LT -> 1\n        GT -> -1\n\nforeign import ordBooleanImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Boolean\n  -> Boolean\n  -> Ordering\n\nforeign import ordIntImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Int\n  -> Int\n  -> Ordering\n\nforeign import ordNumberImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Number\n  -> Number\n  -> Ordering\n\nforeign import ordStringImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> String\n  -> String\n  -> Ordering\n\nforeign import ordCharImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Char\n  -> Char\n  -> Ordering\n\nforeign import ordArrayImpl :: forall a. (a -> a -> Int) -> Array a -> Array a -> Int\n\ninstance ordOrdering :: Ord Ordering where\n  compare LT LT = EQ\n  compare EQ EQ = EQ\n  compare GT GT = EQ\n  compare LT _ = LT\n  compare EQ LT = GT\n  compare EQ GT = LT\n  compare GT _ = GT\n\n-- | Test whether one value is _strictly less than_ another.\nlessThan :: forall a. Ord a => a -> a -> Boolean\nlessThan a1 a2 = case a1 `compare` a2 of\n  LT -> true\n  _ -> false\n\n-- | Test whether one value is _strictly greater than_ another.\ngreaterThan :: forall a. Ord a => a -> a -> Boolean\ngreaterThan a1 a2 = case a1 `compare` a2 of\n  GT -> true\n  _ -> false\n\n-- | Test whether one value is _non-strictly less than_ another.\nlessThanOrEq :: forall a. Ord a => a -> a -> Boolean\nlessThanOrEq a1 a2 = case a1 `compare` a2 of\n  GT -> false\n  _ -> true\n\n-- | Test whether one value is _non-strictly greater than_ another.\ngreaterThanOrEq :: forall a. Ord a => a -> a -> Boolean\ngreaterThanOrEq a1 a2 = case a1 `compare` a2 of\n  LT -> false\n  _ -> true\n\ninfixl 4 lessThan as <\ninfixl 4 lessThanOrEq as <=\ninfixl 4 greaterThan as >\ninfixl 4 greaterThanOrEq as >=\n\n-- | Compares two values by mapping them to a type with an `Ord` instance.\ncomparing :: forall a b. Ord b => (a -> b) -> (a -> a -> Ordering)\ncomparing f x y = compare (f x) (f y)\n\n-- | Take the minimum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmin :: forall a. Ord a => a -> a -> a\nmin x y =\n  case compare x y of\n    LT -> x\n    EQ -> x\n    GT -> y\n\n-- | Take the maximum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmax :: forall a. Ord a => a -> a -> a\nmax x y =\n  case compare x y of\n    LT -> y\n    EQ -> x\n    GT -> x\n\n-- | Clamp a value between a minimum and a maximum. For example:\n-- |\n-- | ``` purescript\n-- | let f = clamp 0 10\n-- | f (-5) == 0\n-- | f 5    == 5\n-- | f 15   == 10\n-- | ```\nclamp :: forall a. Ord a => a -> a -> a -> a\nclamp low hi x = min hi (max low x)\n\n-- | Test whether a value is between a minimum and a maximum (inclusive).\n-- | For example:\n-- |\n-- | ``` purescript\n-- | let f = between 0 10\n-- | f 0    == true\n-- | f (-5) == false\n-- | f 5    == true\n-- | f 10   == true\n-- | f 15   == false\n-- | ```\nbetween :: forall a. Ord a => a -> a -> a -> Boolean\nbetween low hi x\n  | x < low = false\n  | x > hi = false\n  | true = true\n\n-- | The absolute value function. `abs x` is defined as `if x >= zero then x\n-- | else negate x`.\nabs :: forall a. Ord a => Ring a => a -> a\nabs x = if x >= zero then x else negate x\n\n-- | The sign function; returns `one` if the argument is positive,\n-- | `negate one` if the argument is negative, or `zero` if the argument is `zero`.\n-- | For floating point numbers with signed zeroes, when called with a zero,\n-- | this function returns the argument in order to preserve the sign.\n-- | For any `x`, we should have `signum x * abs x == x`.\nsignum :: forall a. Ord a => Ring a => a -> a\nsignum x =\n  if x < zero then negate one\n  else if x > zero then one\n  else x\n\n-- | The `Ord1` type class represents totally ordered type constructors.\nclass Eq1 f <= Ord1 f where\n  compare1 :: forall a. Ord a => f a -> f a -> Ordering\n\ninstance ord1Array :: Ord1 Array where\n  compare1 = compare\n\nclass OrdRecord :: RL.RowList Type -> Row Type -> Constraint\nclass EqRecord rowlist row <= OrdRecord rowlist row where\n  compareRecord :: Proxy rowlist -> Record row -> Record row -> Ordering\n\ninstance ordRecordNil :: OrdRecord RL.Nil row where\n  compareRecord _ _ _ = EQ\n\ninstance ordRecordCons ::\n  ( OrdRecord rowlistTail row\n  , Row.Cons key focus rowTail row\n  , IsSymbol key\n  , Ord focus\n  ) =>\n  OrdRecord (RL.Cons key focus rowlistTail) row where\n  compareRecord _ ra rb =\n    if left /= EQ then left\n    else compareRecord (Proxy :: Proxy rowlistTail) ra rb\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    unsafeGet' = unsafeGet :: String -> Record row -> focus\n    left = unsafeGet' key ra `compare` unsafeGet' key rb\n\ninstance ordRecord ::\n  ( RL.RowToList row list\n  , OrdRecord list row\n  ) =>\n  Ord (Record row) where\n  compare = compareRecord (Proxy :: Proxy list)\n", "module Data.Bounded\n  ( class Bounded\n  , bottom\n  , top\n  , module Data.Ord\n  , class BoundedRecord\n  , bottomRecord\n  , topRecord\n  ) where\n\nimport Data.Ord (class Ord, class OrdRecord, Ordering(..), compare, (<), (<=), (>), (>=))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Bounded` type class represents totally ordered types that have an\n-- | upper and lower boundary.\n-- |\n-- | Instances should satisfy the following law in addition to the `Ord` laws:\n-- |\n-- | - Bounded: `bottom <= a <= top`\nclass Ord a <= Bounded a where\n  top :: a\n  bottom :: a\n\ninstance boundedBoolean :: Bounded Boolean where\n  top = true\n  bottom = false\n\n-- | The `Bounded` `Int` instance has `top :: Int` equal to 2^31 - 1,\n-- | and `bottom :: Int` equal to -2^31, since these are the largest and smallest\n-- | integers representable by twos-complement 32-bit integers, respectively.\ninstance boundedInt :: Bounded Int where\n  top = topInt\n  bottom = bottomInt\n\nforeign import topInt :: Int\nforeign import bottomInt :: Int\n\n-- | Characters fall within the Unicode range.\ninstance boundedChar :: Bounded Char where\n  top = topChar\n  bottom = bottomChar\n\nforeign import topChar :: Char\nforeign import bottomChar :: Char\n\ninstance boundedOrdering :: Bounded Ordering where\n  top = GT\n  bottom = LT\n\ninstance boundedUnit :: Bounded Unit where\n  top = unit\n  bottom = unit\n\nforeign import topNumber :: Number\nforeign import bottomNumber :: Number\n\ninstance boundedNumber :: Bounded Number where\n  top = topNumber\n  bottom = bottomNumber\n\ninstance boundedProxy :: Bounded (Proxy a) where\n  bottom = Proxy\n  top = Proxy\n\nclass BoundedRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass OrdRecord rowlist row <= BoundedRecord rowlist row subrow | rowlist -> subrow where\n  topRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  bottomRecord :: Proxy rowlist -> Proxy row -> Record subrow\n\ninstance boundedRecordNil :: BoundedRecord RL.Nil row () where\n  topRecord _ _ = {}\n  bottomRecord _ _ = {}\n\ninstance boundedRecordCons ::\n  ( IsSymbol key\n  , Bounded focus\n  , Row.Cons key focus rowTail row\n  , Row.Cons key focus subrowTail subrow\n  , BoundedRecord rowlistTail row subrowTail\n  ) =>\n  BoundedRecord (RL.Cons key focus rowlistTail) row subrow where\n  topRecord _ rowProxy = insert top tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = topRecord (Proxy :: Proxy rowlistTail) rowProxy\n\n  bottomRecord _ rowProxy = insert bottom tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = bottomRecord (Proxy :: Proxy rowlistTail) rowProxy\n\ninstance boundedRecord ::\n  ( RL.RowToList row list\n  , BoundedRecord list row row\n  ) =>\n  Bounded (Record row) where\n  top = topRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  bottom = bottomRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n", "export const showIntImpl = function (n) {\n  return n.toString();\n};\n\nexport const showNumberImpl = function (n) {\n  var str = n.toString();\n  return isNaN(str + \".0\") ? str : str + \".0\";\n};\n\nexport const showCharImpl = function (c) {\n  var code = c.charCodeAt(0);\n  if (code < 0x20 || code === 0x7F) {\n    switch (c) {\n      case \"\\x07\": return \"'\\\\a'\";\n      case \"\\b\": return \"'\\\\b'\";\n      case \"\\f\": return \"'\\\\f'\";\n      case \"\\n\": return \"'\\\\n'\";\n      case \"\\r\": return \"'\\\\r'\";\n      case \"\\t\": return \"'\\\\t'\";\n      case \"\\v\": return \"'\\\\v'\";\n    }\n    return \"'\\\\\" + code.toString(10) + \"'\";\n  }\n  return c === \"'\" || c === \"\\\\\" ? \"'\\\\\" + c + \"'\" : \"'\" + c + \"'\";\n};\n\nexport const showStringImpl = function (s) {\n  var l = s.length;\n  return \"\\\"\" + s.replace(\n    /[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n    function (c, i) {\n      switch (c) {\n        case \"\\\"\":\n        case \"\\\\\":\n          return \"\\\\\" + c;\n        case \"\\x07\": return \"\\\\a\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\f\": return \"\\\\f\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\v\": return \"\\\\v\";\n      }\n      var k = i + 1;\n      var empty = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n      return \"\\\\\" + c.charCodeAt(0).toString(10) + empty;\n    }\n  ) + \"\\\"\";\n};\n\nexport const showArrayImpl = function (f) {\n  return function (xs) {\n    var ss = [];\n    for (var i = 0, l = xs.length; i < l; i++) {\n      ss[i] = f(xs[i]);\n    }\n    return \"[\" + ss.join(\",\") + \"]\";\n  };\n};\n", "module Data.Show\n  ( class Show\n  , show\n  , class ShowRecordFields\n  , showRecordFields\n  ) where\n\nimport Data.Semigroup ((<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row (class Nub)\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `Show` type class represents those types which can be converted into\n-- | a human-readable `String` representation.\n-- |\n-- | While not required, it is recommended that for any expression `x`, the\n-- | string `show x` be executable PureScript code which evaluates to the same\n-- | value as the expression `x`.\nclass Show a where\n  show :: a -> String\n\ninstance showUnit :: Show Unit where\n  show _ = \"unit\"\n\ninstance showBoolean :: Show Boolean where\n  show true = \"true\"\n  show false = \"false\"\n\ninstance showInt :: Show Int where\n  show = showIntImpl\n\ninstance showNumber :: Show Number where\n  show = showNumberImpl\n\ninstance showChar :: Show Char where\n  show = showCharImpl\n\ninstance showString :: Show String where\n  show = showStringImpl\n\ninstance showArray :: Show a => Show (Array a) where\n  show = showArrayImpl show\n\ninstance showProxy :: Show (Proxy a) where\n  show _ = \"Proxy\"\n\ninstance showVoid :: Show Void where\n  show = absurd\n\ninstance showRecord ::\n  ( Nub rs rs\n  , RL.RowToList rs ls\n  , ShowRecordFields ls rs\n  ) =>\n  Show (Record rs) where\n  show record = \"{\" <> showRecordFields (Proxy :: Proxy ls) record <> \"}\"\n\n-- | A class for records where all fields have `Show` instances, used to\n-- | implement the `Show` instance for records.\nclass ShowRecordFields :: RL.RowList Type -> Row Type -> Constraint\nclass ShowRecordFields rowlist row where\n  showRecordFields :: Proxy rowlist -> Record row -> String\n\ninstance showRecordFieldsNil :: ShowRecordFields RL.Nil row where\n  showRecordFields _ _ = \"\"\nelse\ninstance showRecordFieldsConsNil ::\n  ( IsSymbol key\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus RL.Nil) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \" \"\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\nelse\ninstance showRecordFieldsCons ::\n  ( IsSymbol key\n  , ShowRecordFields rowlistTail row\n  , Show focus\n  ) =>\n  ShowRecordFields (RL.Cons key focus rowlistTail) row where\n  showRecordFields _ record = \" \" <> key <> \": \" <> show focus <> \",\" <> tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    focus = unsafeGet key record :: focus\n    tail = showRecordFields (Proxy :: Proxy rowlistTail) record\n\nforeign import showIntImpl :: Int -> String\nforeign import showNumberImpl :: Number -> String\nforeign import showCharImpl :: Char -> String\nforeign import showStringImpl :: String -> String\nforeign import showArrayImpl :: forall a. (a -> String) -> Array a -> String\n", "module Data.Maybe where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Extend (class Extend)\nimport Control.Plus (class Plus)\n\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Ord (class Ord1)\n\n-- | The `Maybe` type is used to represent optional values and can be seen as\n-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`\n-- | is the non-null value `x`.\ndata Maybe a = Nothing | Just a\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Just` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing == Nothing\n-- | ```\ninstance functorMaybe :: Functor Maybe where\n  map fn (Just x) = Just (fn x)\n  map _  _        = Nothing\n\n-- | The `Apply` instance allows functions contained within a `Just` to\n-- | transform a value contained within a `Just` using the `apply` operator:\n-- |\n-- | ``` purescript\n-- | Just f <*> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Just f <*> Nothing == Nothing\n-- | Nothing <*> Just x == Nothing\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a\n-- | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Maybe a -> Maybe b -> Maybe c`:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> Just y == Just (f x y)\n-- | ```\n-- |\n-- | The `Nothing`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Nothing`\n-- | means the whole result becomes `Nothing` also:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing <*> Just y == Nothing\n-- | f <$> Just x <*> Nothing == Nothing\n-- | f <$> Nothing <*> Nothing == Nothing\n-- | ```\ninstance applyMaybe :: Apply Maybe where\n  apply (Just fn) x = fn <$> x\n  apply Nothing   _ = Nothing\n\n-- | The `Applicative` instance enables lifting of values into `Maybe` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Maybe _ == Just x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Maybe` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> pure y == Just (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Just` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Just` with a new constructor.\ninstance applicativeMaybe :: Applicative Maybe where\n  pure = Just\n\n-- | The `Alt` instance allows for a choice to be made between two `Maybe`\n-- | values with the `<|>` operator, where the first `Just` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Just x <|> Just y == Just x\n-- | Nothing <|> Just y == Just y\n-- | Nothing <|> Nothing == Nothing\n-- | ```\ninstance altMaybe :: Alt Maybe where\n  alt Nothing r = r\n  alt l       _ = l\n\n-- | The `Plus` instance provides a default `Maybe` value:\n-- |\n-- | ``` purescript\n-- | empty :: Maybe _ == Nothing\n-- | ```\ninstance plusMaybe :: Plus Maybe where\n  empty = Nothing\n\n-- | The `Alternative` instance guarantees that there are both `Applicative` and\n-- | `Plus` instances for `Maybe`.\ninstance alternativeMaybe :: Alternative Maybe\n\n-- | The `Bind` instance allows sequencing of `Maybe` values and functions that\n-- | return a `Maybe` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Just x >>= f = f x\n-- | Nothing >>= f = Nothing\n-- | ```\ninstance bindMaybe :: Bind Maybe where\n  bind (Just x) k = k x\n  bind Nothing  _ = Nothing\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:\n-- |\n-- | ``` purescript\n-- | do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | case x of\n-- |   Nothing -> Nothing\n-- |   Just x' -> case y of\n-- |     Nothing -> Nothing\n-- |     Just y' -> Just (f x' y')\n-- | ```\ninstance monadMaybe :: Monad Maybe\n\n-- | The `Extend` instance allows sequencing of `Maybe` values and functions\n-- | that accept a `Maybe a` and return a non-`Maybe` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Nothing = Nothing\n-- | f <<= x = Just (f x)\n-- | ```\ninstance extendMaybe :: Extend Maybe where\n  extend _ Nothing  = Nothing\n  extend f x        = Just (f x)\n\ninstance invariantMaybe :: Invariant Maybe where\n  imap = imapF\n\n-- | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values\n-- | whenever there is a `Semigroup` instance for the type the `Maybe` contains.\n-- | The exact behaviour of `<>` depends on the \"inner\" `Semigroup` instance,\n-- | but generally captures the notion of appending or combining things.\n-- |\n-- | ``` purescript\n-- | Just x <> Just y = Just (x <> y)\n-- | Just x <> Nothing = Just x\n-- | Nothing <> Just y = Just y\n-- | Nothing <> Nothing = Nothing\n-- | ```\ninstance semigroupMaybe :: Semigroup a => Semigroup (Maybe a) where\n  append Nothing y = y\n  append x Nothing = x\n  append (Just x) (Just y) = Just (x <> y)\n\ninstance monoidMaybe :: Semigroup a => Monoid (Maybe a) where\n  mempty = Nothing\n\ninstance semiringMaybe :: Semiring a => Semiring (Maybe a) where\n  zero = Nothing\n  one = Just one\n\n  add Nothing y = y\n  add x Nothing = x\n  add (Just x) (Just y) = Just (add x y)\n\n  mul x y = mul <$> x <*> y\n\n-- | The `Eq` instance allows `Maybe` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for the\n-- | type the `Maybe` contains.\nderive instance eqMaybe :: Eq a => Eq (Maybe a)\n\ninstance eq1Maybe :: Eq1 Maybe where eq1 = eq\n\n-- | The `Ord` instance allows `Maybe` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | the type the `Maybe` contains.\n-- |\n-- | `Nothing` is considered to be less than any `Just` value.\nderive instance ordMaybe :: Ord a => Ord (Maybe a)\n\ninstance ord1Maybe :: Ord1 Maybe where compare1 = compare\n\ninstance boundedMaybe :: Bounded a => Bounded (Maybe a) where\n  top = Just top\n  bottom = Nothing\n\n-- | The `Show` instance allows `Maybe` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for the type the `Maybe`\n-- | contains.\ninstance showMaybe :: Show a => Show (Maybe a) where\n  show (Just x) = \"(Just \" <> show x <> \")\"\n  show Nothing  = \"Nothing\"\n\nderive instance genericMaybe :: Generic (Maybe a) _\n\n-- | Takes a default value, a function, and a `Maybe` value. If the `Maybe`\n-- | value is `Nothing` the default value is returned, otherwise the function\n-- | is applied to the value inside the `Just` and the result is returned.\n-- |\n-- | ``` purescript\n-- | maybe x f Nothing == x\n-- | maybe x f (Just y) == f y\n-- | ```\nmaybe :: forall a b. b -> (a -> b) -> Maybe a -> b\nmaybe b _ Nothing = b\nmaybe _ f (Just a) = f a\n\n-- | Similar to `maybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `maybe` has\n-- | to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | maybe' (\\_ -> x) f Nothing == x\n-- | maybe' (\\_ -> x) f (Just y) == f y\n-- | ```\nmaybe' :: forall a b. (Unit -> b) -> (a -> b) -> Maybe a -> b\nmaybe' g _ Nothing = g unit\nmaybe' _ f (Just a) = f a\n\n-- | Takes a default value, and a `Maybe` value. If the `Maybe` value is\n-- | `Nothing` the default value is returned, otherwise the value inside the\n-- | `Just` is returned.\n-- |\n-- | ``` purescript\n-- | fromMaybe x Nothing == x\n-- | fromMaybe x (Just y) == y\n-- | ```\nfromMaybe :: forall a. a -> Maybe a -> a\nfromMaybe a = maybe a identity\n\n-- | Similar to `fromMaybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`\n-- | has to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | fromMaybe' (\\_ -> x) Nothing == x\n-- | fromMaybe' (\\_ -> x) (Just y) == y\n-- | ```\nfromMaybe' :: forall a. (Unit -> a) -> Maybe a -> a\nfromMaybe' a = maybe' a identity\n\n-- | Returns `true` when the `Maybe` value was constructed with `Just`.\nisJust :: forall a. Maybe a -> Boolean\nisJust = maybe false (const true)\n\n-- | Returns `true` when the `Maybe` value is `Nothing`.\nisNothing :: forall a. Maybe a -> Boolean\nisNothing = maybe true (const false)\n\n-- | A partial function that extracts the value from the `Just` data\n-- | constructor. Passing `Nothing` to `fromJust` will throw an error at\n-- | runtime.\nfromJust :: forall a. Partial => Maybe a -> a\nfromJust (Just x) = x\n\n-- | One or none.\n-- |\n-- | ```purescript\n-- | optional empty = pure Nothing\n-- | ```\n-- |\n-- | The behaviour of `optional (pure x)` depends on whether the `Alt` instance\n-- | satisfy the left catch law (`pure a <|> b = pure a`).\n-- |\n-- | `Either e` does:\n-- |\n-- | ```purescript\n-- | optional (Right x) = Right (Just x)\n-- | ```\n-- |\n-- | But `Array` does not:\n-- |\n-- | ```purescript\n-- | optional [x] = [Just x, Nothing]\n-- | ```\noptional :: forall f a. Alt f => Applicative f => f a -> f (Maybe a)\noptional a = map Just a <|> pure Nothing\n", "module Data.Either where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Extend (class Extend)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.Maybe (Maybe(..), maybe, maybe')\nimport Data.Ord (class Ord1)\n\n-- | The `Either` type is used to represent a choice between two types of value.\n-- |\n-- | A common use case for `Either` is error handling, where `Left` is used to\n-- | carry an error value and `Right` is used to carry a success value.\ndata Either a b = Left a | Right b\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Right` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Left y == Left y\n-- | ```\nderive instance functorEither :: Functor (Either a)\n\nderive instance genericEither :: Generic (Either a b) _\n\ninstance invariantEither :: Invariant (Either a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions contained within a `Right` to\n-- | transform a value contained within a `Right` using the `(<*>)` operator:\n-- |\n-- | ``` purescript\n-- | Right f <*> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Left f <*> Right x == Left f\n-- | Right f <*> Left y == Left y\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a\n-- | pure function to take `Either`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Either l a -> Either l b -> Either l c`:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> Right y == Right (f x y)\n-- | ```\n-- |\n-- | The `Left`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Left`\n-- | means the whole result becomes `Left` also, taking the first `Left` value\n-- | found:\n-- |\n-- | ``` purescript\n-- | f <$> Left x <*> Right y == Left x\n-- | f <$> Right x <*> Left y == Left y\n-- | f <$> Left x <*> Left y == Left x\n-- | ```\ninstance applyEither :: Apply (Either e) where\n  apply (Left e) _ = Left e\n  apply (Right f) r = f <$> r\n\n-- | The `Applicative` instance enables lifting of values into `Either` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Either _ _ == Right x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Either` and non-`Either` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Either` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> pure y == Right (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Right` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Right` with a new constructor.\ninstance applicativeEither :: Applicative (Either e) where\n  pure = Right\n\n-- | The `Alt` instance allows for a choice to be made between two `Either`\n-- | values with the `<|>` operator, where the first `Right` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Right x <|> Right y == Right x\n-- | Left x <|> Right y == Right y\n-- | Left x <|> Left y == Left y\n-- | ```\ninstance altEither :: Alt (Either e) where\n  alt (Left _) r = r\n  alt l        _ = l\n\n-- | The `Bind` instance allows sequencing of `Either` values and functions that\n-- | return an `Either` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Left x >>= f = Left x\n-- | Right x >>= f = f x\n-- | ```\n-- |\n-- | `Either`'s \"do notation\" can be understood to work like this:\n-- | ``` purescript\n-- | x :: forall e a. Either e a\n-- | x = --\n-- |\n-- | y :: forall e b. Either e b\n-- | y = --\n-- |\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | ...which is equivalent to...\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\n-- |\n-- | ...and is the same as writing...\n-- |\n-- | ```\n-- | foo :: forall e a. (a -> b -> c) -> Either e c\n-- | foo f = case x of\n-- |   Left e ->\n-- |     Left e\n-- |   Right x -> case y of\n-- |     Left e ->\n-- |       Left e\n-- |     Right y ->\n-- |       Right (f x y)\n-- | ```\ninstance bindEither :: Bind (Either e) where\n  bind = either (\\e _ -> Left e) (\\a f -> f a)\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Either`.\ninstance monadEither :: Monad (Either e)\n\n-- | The `Extend` instance allows sequencing of `Either` values and functions\n-- | that accept an `Either` and return a non-`Either` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Left x = Left x\n-- | f <<= Right x = Right (f (Right x))\n-- | ```\ninstance extendEither :: Extend (Either e) where\n  extend _ (Left y)  = Left y\n  extend f x         = Right (f x)\n\n-- | The `Show` instance allows `Either` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for both type the `Either` can\n-- | contain.\ninstance showEither :: (Show a, Show b) => Show (Either a b) where\n  show (Left x) = \"(Left \" <> show x <> \")\"\n  show (Right y) = \"(Right \" <> show y <> \")\"\n\n-- | The `Eq` instance allows `Either` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for both\n-- | types the `Either` can contain.\nderive instance eqEither :: (Eq a, Eq b) => Eq (Either a b)\n\nderive instance eq1Either :: Eq a => Eq1 (Either a)\n\n-- | The `Ord` instance allows `Either` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | both types the `Either` can contain.\n-- |\n-- | Any `Left` value is considered to be less than a `Right` value.\nderive instance ordEither :: (Ord a, Ord b) => Ord (Either a b)\n\nderive instance ord1Either :: Ord a => Ord1 (Either a)\n\ninstance boundedEither :: (Bounded a, Bounded b) => Bounded (Either a b) where\n  top = Right top\n  bottom = Left bottom\n\ninstance semigroupEither :: (Semigroup b) => Semigroup (Either a b) where\n  append x y = append <$> x <*> y\n\n-- | Takes two functions and an `Either` value, if the value is a `Left` the\n-- | inner value is applied to the first function, if the value is a `Right`\n-- | the inner value is applied to the second function.\n-- |\n-- | ``` purescript\n-- | either f g (Left x) == f x\n-- | either f g (Right y) == g y\n-- | ```\neither :: forall a b c. (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n-- | Combine two alternatives.\nchoose :: forall m a b. Alt m => m a -> m b -> m (Either a b)\nchoose a b = Left <$> a <|> Right <$> b\n\n-- | Returns `true` when the `Either` value was constructed with `Left`.\nisLeft :: forall a b. Either a b -> Boolean\nisLeft = either (const true) (const false)\n\n-- | Returns `true` when the `Either` value was constructed with `Right`.\nisRight :: forall a b. Either a b -> Boolean\nisRight = either (const false) (const true)\n\n-- | A function that extracts the value from the `Left` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Right` is passed to `fromLeft`.\nfromLeft :: forall a b. a -> Either a b -> a\nfromLeft _ (Left a) = a\nfromLeft default _ = default\n\n-- | Similar to `fromLeft` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromLeft`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Right`.\nfromLeft' :: forall a b. (Unit -> a) -> Either a b -> a\nfromLeft' _ (Left a) = a\nfromLeft' default _ = default unit\n\n-- | A function that extracts the value from the `Right` data constructor.\n-- | The first argument is a default value, which will be returned in the\n-- | case where a `Left` is passed to `fromRight`.\nfromRight :: forall a b. b -> Either a b -> b\nfromRight _ (Right b) = b\nfromRight default _ = default\n\n-- | Similar to `fromRight` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromRight`\n-- | has to evaluate the default value before returning the result,\n-- | whereas here the value is only computed when the `Either` is known\n-- | to be `Left`.\nfromRight' :: forall a b. (Unit -> b) -> Either a b -> b\nfromRight' _ (Right b) = b\nfromRight' default _ = default unit\n\n-- | Takes a default and a `Maybe` value, if the value is a `Just`, turn it into\n-- | a `Right`, if the value is a `Nothing` use the provided default as a `Left`\n-- |\n-- | ```purescript\n-- | note \"default\" Nothing = Left \"default\"\n-- | note \"default\" (Just 1) = Right 1\n-- | ```\nnote :: forall a b. a -> Maybe b -> Either a b\nnote a = maybe (Left a) Right\n\n-- | Similar to `note`, but for use in cases where the default value may be\n-- | expensive to compute.\n-- |\n-- | ```purescript\n-- | note' (\\_ -> \"default\") Nothing = Left \"default\"\n-- | note' (\\_ -> \"default\") (Just 1) = Right 1\n-- | ```\nnote' :: forall a b. (Unit -> a) -> Maybe b -> Either a b\nnote' f = maybe' (Left <<< f) Right\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Left` values away and converting\n-- | them into `Nothing`. `Right` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | hush (Left \"ParseError\") = Nothing\n-- | hush (Right 42) = Just 42\n-- | ```\nhush :: forall a b. Either a b -> Maybe b\nhush = either (const Nothing) Just\n\n-- | Turns an `Either` into a `Maybe`, by throwing potential `Right` values away and converting\n-- | them into `Nothing`. `Left` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | blush (Left \"ParseError\") = Just \"Parse Error\"\n-- | blush (Right 42) = Nothing\n-- | ```\nblush :: forall a b. Either a b -> Maybe a\nblush = either Just (const Nothing)\n", "export const pureE = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexport const bindE = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexport const untilE = function (f) {\n  return function () {\n    while (!f());\n  };\n};\n\nexport const whileE = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n};\n\nexport const forE = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexport const foreachE = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n", "module Data.Monoid\n  ( class Monoid\n  , mempty\n  , power\n  , guard\n  , module Data.Semigroup\n  , class MonoidRecord\n  , memptyRecord\n  ) where\n\nimport Data.Boolean (otherwise)\nimport Data.Eq ((==))\nimport Data.EuclideanRing (mod, (/))\nimport Data.Ord ((<=))\nimport Data.Ordering (Ordering(..))\nimport Data.Semigroup (class Semigroup, class SemigroupRecord, (<>))\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a\n-- | left and right unit for the associative operation `<>`:\n-- |\n-- | - Left unit: `(mempty <> x) = x`\n-- | - Right unit: `(x <> mempty) = x`\n-- |\n-- | `Monoid`s are commonly used as the result of fold operations, where\n-- | `<>` is used to combine individual results, and `mempty` gives the result\n-- | of folding an empty collection of elements.\n-- |\n-- | ### Newtypes for Monoid\n-- |\n-- | Some types (e.g. `Int`, `Boolean`) can implement multiple law-abiding\n-- | instances for `Monoid`. Let's use `Int` as an example\n-- | 1. `<>` could be `+` and `mempty` could be `0`\n-- | 2. `<>` could be `*` and `mempty` could be `1`.\n-- |\n-- | To clarify these ambiguous situations, one should use the newtypes\n-- | defined in `Data.Monoid.<NewtypeName>` modules.\n-- |\n-- | In the above ambiguous situation, we could use `Additive`\n-- | for the first situation or `Multiplicative` for the second one.\nclass Semigroup m <= Monoid m where\n  mempty :: m\n\ninstance monoidUnit :: Monoid Unit where\n  mempty = unit\n\ninstance monoidOrdering :: Monoid Ordering where\n  mempty = EQ\n\ninstance monoidFn :: Monoid b => Monoid (a -> b) where\n  mempty _ = mempty\n\ninstance monoidString :: Monoid String where\n  mempty = \"\"\n\ninstance monoidArray :: Monoid (Array a) where\n  mempty = []\n\ninstance monoidRecord :: (RL.RowToList row list, MonoidRecord list row row) => Monoid (Record row) where\n  mempty = memptyRecord (Proxy :: Proxy list)\n\n-- | Append a value to itself a certain number of times. For the\n-- | `Multiplicative` type, and for a non-negative power, this is the same as\n-- | normal number exponentiation.\n-- |\n-- | If the second argument is negative this function will return `mempty`\n-- | (*unlike* normal number exponentiation). The `Monoid` constraint alone\n-- | is not enough to write a `power` function with the property that `power x\n-- | n` cancels with `power x (-n)`, i.e. `power x n <> power x (-n) = mempty`.\n-- | For that, we would additionally need the ability to invert elements, i.e.\n-- | a Group.\n-- |\n-- | ```purescript\n-- | power [1,2] 3    == [1,2,1,2,1,2]\n-- | power [1,2] 1    == [1,2]\n-- | power [1,2] 0    == []\n-- | power [1,2] (-3) == []\n-- | ```\n-- |\npower :: forall m. Monoid m => m -> Int -> m\npower x = go\n  where\n  go :: Int -> m\n  go p\n    | p <= 0 = mempty\n    | p == 1 = x\n    | p `mod` 2 == 0 = let x' = go (p / 2) in x' <> x'\n    | otherwise = let x' = go (p / 2) in x' <> x' <> x\n\n-- | Allow or \"truncate\" a Monoid to its `mempty` value based on a condition.\nguard :: forall m. Monoid m => Boolean -> m -> m\nguard true a = a\nguard false _ = mempty\n\n-- | A class for records where all fields have `Monoid` instances, used to\n-- | implement the `Monoid` instance for records.\nclass MonoidRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass SemigroupRecord rowlist row subrow <= MonoidRecord rowlist row subrow | rowlist -> row subrow where\n  memptyRecord :: Proxy rowlist -> Record subrow\n\ninstance monoidRecordNil :: MonoidRecord RL.Nil row () where\n  memptyRecord _ = {}\n\ninstance monoidRecordCons ::\n  ( IsSymbol key\n  , Monoid focus\n  , Row.Cons key focus subrowTail subrow\n  , MonoidRecord rowlistTail row subrowTail\n  ) =>\n  MonoidRecord (RL.Cons key focus rowlistTail) row subrow where\n  memptyRecord _ = insert mempty tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = memptyRecord (Proxy :: Proxy rowlistTail)\n", "-- | This module provides the `Effect` type, which is used to represent\n-- | _native_ effects. The `Effect` type provides a typed API for effectful\n-- | computations, while at the same time generating efficient JavaScript.\nmodule Effect\n  ( Effect\n  , untilE, whileE, forE, foreachE\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\n\n-- | A native effect. The type parameter denotes the return type of running the\n-- | effect, that is, an `Effect Int` is a possibly-effectful computation which\n-- | eventually produces a value of the type `Int` when it finishes.\nforeign import data Effect :: Type -> Type\n\ntype role Effect representational\n\ninstance functorEffect :: Functor Effect where\n  map = liftA1\n\ninstance applyEffect :: Apply Effect where\n  apply = ap\n\ninstance applicativeEffect :: Applicative Effect where\n  pure = pureE\n\nforeign import pureE :: forall a. a -> Effect a\n\ninstance bindEffect :: Bind Effect where\n  bind = bindE\n\nforeign import bindE :: forall a b. Effect a -> (a -> Effect b) -> Effect b\n\ninstance monadEffect :: Monad Effect\n\n-- | The `Semigroup` instance for effects allows you to run two effects, one\n-- | after the other, and then combine their results using the result type's\n-- | `Semigroup` instance.\ninstance semigroupEffect :: Semigroup a => Semigroup (Effect a) where\n  append = lift2 append\n\n-- | If you have a `Monoid a` instance, then `mempty :: Effect a` is defined as\n-- | `pure mempty`.\ninstance monoidEffect :: Monoid a => Monoid (Effect a) where\n  mempty = pureE mempty\n\n-- | Loop until a condition becomes `true`.\n-- |\n-- | `untilE b` is an effectful computation which repeatedly runs the effectful\n-- | computation `b`, until its return value is `true`.\nforeign import untilE :: Effect Boolean -> Effect Unit\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `whileE b m` is effectful computation which runs the effectful computation\n-- | `b`. If its result is `true`, it runs the effectful computation `m` and\n-- | loops. If not, the computation ends.\nforeign import whileE :: forall a. Effect Boolean -> Effect a -> Effect Unit\n\n-- | Loop over a consecutive collection of numbers.\n-- |\n-- | `forE lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import forE :: Int -> Int -> (Int -> Effect Unit) -> Effect Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `foreachE xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreachE :: forall a. Array a -> (a -> Effect Unit) -> Effect Unit\n", "export function showErrorImpl(err) {\n  return err.stack || err.toString();\n}\n\nexport function error(msg) {\n  return new Error(msg);\n}\n\nexport function errorWithCause(msg) {\n  return function(cause) {\n    return new Error(msg, { cause });\n  };\n}\n\nexport function errorWithName(msg) {\n  return function(name) {\n    const e = new Error(msg);\n    e.name = name;\n    return e;\n  };\n}\n\nexport function message(e) {\n  return e.message;\n}\n\nexport function name(e) {\n  return e.name || \"Error\";\n}\n\nexport function stackImpl(just) {\n  return function (nothing) {\n    return function (e) {\n      return e.stack ? just(e.stack) : nothing;\n    };\n  };\n}\n\nexport function throwException(e) {\n  return function () {\n    throw e;\n  };\n}\n\nexport function catchException(c) {\n  return function (t) {\n    return function () {\n      try {\n        return t();\n      } catch (e) {\n        if (e instanceof Error || Object.prototype.toString.call(e) === \"[object Error]\") {\n          return c(e)();\n        } else {\n          return c(new Error(e.toString()))();\n        }\n      }\n    };\n  };\n}\n", "-- | This module defines an effect, actions and handlers for working\n-- | with JavaScript exceptions.\n\nmodule Effect.Exception\n  ( Error\n  , catchException\n  , error\n  , errorWithCause\n  , errorWithName\n  , message\n  , name\n  , stack\n  , throw\n  , throwException\n  , try\n  )\n  where\n\nimport Prelude\n\nimport Effect (Effect)\n\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\n\n-- | The type of JavaScript errors\nforeign import data Error :: Type\n\ninstance showError :: Show Error where\n  show = showErrorImpl\n\nforeign import showErrorImpl :: Error -> String\n\n-- | Create a JavaScript error, specifying a message\nforeign import error :: String -> Error\n\n-- | Create a JavaScript error, specifying a message and a cause\nforeign import errorWithCause :: String -> Error -> Error\n\n-- | Create a JavaScript error, specifying a message and a name\nforeign import errorWithName :: String -> String -> Error\n\n-- | Get the error message from a JavaScript error\nforeign import message :: Error -> String\n\n-- | Get the error name when defined, or fallback to 'Error'\nforeign import name :: Error -> String\n\n-- | Get the stack trace from a JavaScript error\nstack :: Error -> Maybe String\nstack = stackImpl Just Nothing\n\nforeign import stackImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Error\n  -> Maybe String\n\n-- | Throw an exception\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = do\n-- |   x <- readNumber\n-- |   when (x < 0) $ throwException $\n-- |     error \"Expected a non-negative number\"\n-- | ```\nforeign import throwException\n  :: forall a\n   . Error\n  -> Effect a\n\n-- | Catch an exception by providing an exception handler.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = catchException Console.logShow do\n-- |   Console.log \"Exceptions thrown in this block will be logged to the console\"\n-- | ```\nforeign import catchException\n  :: forall a\n   . (Error -> Effect a)\n  -> Effect a\n  -> Effect a\n\n-- | A shortcut allowing you to throw an error in one step. Defined as\n-- | `throwException <<< error`.\nthrow :: forall a. String -> Effect a\nthrow = throwException <<< error\n\n-- | Runs an Eff and returns eventual Exceptions as a `Left` value. If the\n-- | computation succeeds the result gets wrapped in a `Right`.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main :: Effect Unit\n-- | main = do\n-- |   result <- try (readTextFile UTF8 \"README.md\")\n-- |   case result of\n-- |     Right lines ->\n-- |       Console.log (\"README: \\n\" <> lines )\n-- |     Left error ->\n-- |       Console.error (\"Couldn't open README.md. Error was: \" <> show error)\n-- | ```\n\ntry :: forall a. Effect a -> Effect (Either Error a)\ntry action = catchException (pure <<< Left) (Right <$> action)\n", "-- | This module defines the `MonadError` type class and its instances.\n\nmodule Control.Monad.Error.Class where\n\nimport Prelude\n\nimport Data.Either (Either(..), either)\nimport Data.Maybe (Maybe(..), maybe)\nimport Effect (Effect)\nimport Effect.Exception as Ex\n\n\n-- | The `MonadThrow` type class represents those monads which support errors via\n-- | `throwError`, where `throwError e` halts, yielding the error `e`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Left zero: `throwError e >>= f = throwError e`\n-- |\nclass Monad m <= MonadThrow e m | m -> e where\n  throwError :: forall a. e -> m a\n\n-- | The `MonadError` type class represents those monads which support catching\n-- | errors.\n-- |\n-- | - `catchError x f` calls the error handler `f` if an error is thrown during the\n-- |   evaluation of `x`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Catch: `catchError (throwError e) f = f e`\n-- | - Pure: `catchError (pure a) f = pure a`\n-- |\nclass MonadThrow e m <= MonadError e m | m -> e where\n  catchError :: forall a. m a -> (e -> m a) -> m a\n\n-- | This function allows you to provide a predicate for selecting the\n-- | exceptions that you're interested in, and handle only those exceptons.\n-- | If the inner computation throws an exception, and the predicate returns\n-- | Nothing, then the whole computation will still fail with that exception.\ncatchJust\n  :: forall e m a b\n   . MonadError e m\n  => (e -> Maybe b) -- ^ Predicate to select exceptions\n  -> m a            -- ^ Computation to run\n  -> (b -> m a)     -- ^ Handler\n  -> m a\ncatchJust p act handler = catchError act handle\n  where\n  handle e =\n    case p e of\n      Nothing -> throwError e\n      Just b -> handler b\n\n-- | Return `Right` if the given action succeeds, `Left` if it throws.\ntry\n  :: forall e m a\n   . MonadError e m\n  => m a\n  -> m (Either e a)\ntry a = (Right <$> a) `catchError` (pure <<< Left)\n\ninstance monadThrowEither :: MonadThrow e (Either e) where\n  throwError = Left\n\ninstance monadErrorEither :: MonadError e (Either e) where\n  catchError (Left e) h = h e\n  catchError (Right x) _ = Right x\n\ninstance monadThrowMaybe :: MonadThrow Unit Maybe where\n  throwError = const Nothing\n\ninstance monadErrorMaybe :: MonadError Unit Maybe where\n  catchError Nothing f  = f unit\n  catchError (Just a) _ = Just a\n \ninstance monadThrowEffect :: MonadThrow Ex.Error Effect where\n  throwError = Ex.throwException\n\ninstance monadErrorEffect :: MonadError Ex.Error Effect where\n  catchError = flip Ex.catchException\n\n\n-- | Make sure that a resource is cleaned up in the event of an exception. The\n-- | release action is called regardless of whether the body action throws or\n-- | returns.\nwithResource\n  :: forall e m r a\n   . MonadError e m\n  => m r\n  -> (r -> m Unit)\n  -> (r -> m a)\n  -> m a\nwithResource acquire release kleisli = do\n  resource <- acquire\n  result <- try $ kleisli resource\n  release resource\n  either throwError pure result\n\n-- | Lift a `Maybe` value to a MonadThrow monad.\nliftMaybe :: forall m e a. MonadThrow e m => e -> Maybe a -> m a\nliftMaybe error = maybe (throwError error) pure\n\n-- | Lift an `Either` value to a MonadThrow monad.\nliftEither :: forall m e a. MonadThrow e m => Either e a -> m a\nliftEither = either throwError pure\n", "module Data.Identity where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\n\nnewtype Identity a = Identity a\n\nderive instance newtypeIdentity :: Newtype (Identity a) _\n\nderive newtype instance eqIdentity :: Eq a => Eq (Identity a)\n\nderive newtype instance ordIdentity :: Ord a => Ord (Identity a)\n\nderive newtype instance boundedIdentity :: Bounded a => Bounded (Identity a)\n\nderive newtype instance heytingAlgebraIdentity :: HeytingAlgebra a => HeytingAlgebra (Identity a)\n\nderive newtype instance booleanAlgebraIdentity :: BooleanAlgebra a => BooleanAlgebra (Identity a)\n\nderive newtype instance semigroupIdentity :: Semigroup a => Semigroup (Identity a)\n\nderive newtype instance monoidIdentity :: Monoid a => Monoid (Identity a)\n\nderive newtype instance semiringIdentity :: Semiring a => Semiring (Identity a)\n\nderive newtype instance euclideanRingIdentity :: EuclideanRing a => EuclideanRing (Identity a)\n\nderive newtype instance ringIdentity :: Ring a => Ring (Identity a)\n\nderive newtype instance commutativeRingIdentity :: CommutativeRing a => CommutativeRing (Identity a)\n\nderive newtype instance lazyIdentity :: Lazy a => Lazy (Identity a)\n\ninstance showIdentity :: Show a => Show (Identity a) where\n  show (Identity x) = \"(Identity \" <> show x <> \")\"\n\nderive instance eq1Identity :: Eq1 Identity\n\nderive instance ord1Identity :: Ord1 Identity\n\nderive instance functorIdentity :: Functor Identity\n\ninstance invariantIdentity :: Invariant Identity where\n  imap = imapF\n\ninstance altIdentity :: Alt Identity where\n  alt x _ = x\n\ninstance applyIdentity :: Apply Identity where\n  apply (Identity f) (Identity x) = Identity (f x)\n\ninstance applicativeIdentity :: Applicative Identity where\n  pure = Identity\n\ninstance bindIdentity :: Bind Identity where\n  bind (Identity m) f = f m\n\ninstance monadIdentity :: Monad Identity\n\ninstance extendIdentity :: Extend Identity where\n  extend f m = Identity (f m)\n\ninstance comonadIdentity :: Comonad Identity where\n  extract (Identity x) = x\n", "export const _new = function (val) {\n  return function () {\n    return { value: val };\n  };\n};\n\nexport const newWithSelf = function (f) {\n  return function () {\n    var ref = { value: null };\n    ref.value = f(ref);\n    return ref;\n  };\n};\n\nexport const read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexport const modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexport const write = function (val) {\n  return function (ref) {\n    return function () {\n      ref.value = val;\n    };\n  };\n};\n", "-- | This module defines the `Ref` type for mutable value references, as well\n-- | as actions for working with them.\n-- |\n-- | You'll notice that all of the functions that operate on a `Ref` (e.g.\n-- | `new`, `read`, `write`) return their result wrapped in an `Effect`.\n-- | Working with mutable references is considered effectful in PureScript\n-- | because of the principle of purity: functions should not have side\n-- | effects, and should return the same result when called with the same\n-- | arguments. If a `Ref` could be written to without using `Effect`, that\n-- | would cause a side effect (the effect of changing the result of subsequent\n-- | reads for that `Ref`). If there were a function for reading the current\n-- | value of a `Ref` without the result being wrapped in `Effect`, the result\n-- | of calling that function would change each time a new value was written to\n-- | the `Ref`. Even creating a new `Ref` is effectful: if there were a\n-- | function for creating a new `Ref` with the type `forall s. s -> Ref s`,\n-- | then calling that function twice with the same argument would not give the\n-- | same result in each case, since you'd end up with two distinct references\n-- | which could be updated independently of each other.\n-- |\n-- | _Note_: `Control.Monad.ST` provides a pure alternative to `Ref` when\n-- | mutation is restricted to a local scope.\nmodule Effect.Ref\n  ( Ref\n  , new\n  , newWithSelf\n  , read\n  , modify'\n  , modify\n  , modify_\n  , write\n  ) where\n\nimport Prelude\n\nimport Effect (Effect)\n\n-- | A value of type `Ref a` represents a mutable reference\n-- | which holds a value of type `a`.\nforeign import data Ref :: Type -> Type\n\ntype role Ref representational\n\n-- | Create a new mutable reference containing the specified value.\nforeign import _new :: forall s. s -> Effect (Ref s)\n\nnew :: forall s. s -> Effect (Ref s)\nnew = _new\n\n-- | Create a new mutable reference containing a value that can refer to the\n-- | `Ref` being created.\nforeign import newWithSelf :: forall s. (Ref s -> s) -> Effect (Ref s)\n\n-- | Read the current value of a mutable reference.\nforeign import read :: forall s. Ref s -> Effect s\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value.\nmodify' :: forall s b. (s -> { state :: s, value :: b }) -> Ref s -> Effect b\nmodify' = modifyImpl\n\nforeign import modifyImpl :: forall s b. (s -> { state :: s, value :: b }) -> Ref s -> Effect b\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value. The updated value is returned.\nmodify :: forall s. (s -> s) -> Ref s -> Effect s\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\n-- | A version of `modify` which does not return the updated value.\nmodify_ :: forall s. (s -> s) -> Ref s -> Effect Unit\nmodify_ f s = void $ modify f s\n\n-- | Update the value of a mutable reference to the specified value.\nforeign import write :: forall s. s -> Ref s -> Effect Unit\n", "module Control.Monad.Rec.Class\n  ( Step(..)\n  , class MonadRec\n  , tailRec\n  , tailRec2\n  , tailRec3\n  , tailRecM\n  , tailRecM2\n  , tailRecM3\n  , forever\n  , whileJust\n  , untilJust\n  , loop2\n  , loop3\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Either (Either(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect, untilE)\nimport Effect.Ref as Ref\nimport Partial.Unsafe (unsafePartial)\n\n-- | The result of a computation: either `Loop` containing the updated\n-- | accumulator, or `Done` containing the final result of the computation.\ndata Step a b = Loop a | Done b\n\nderive instance functorStep :: Functor (Step a)\n\ninstance bifunctorStep :: Bifunctor Step where\n  bimap f _ (Loop a) = Loop (f a)\n  bimap _ g (Done b) = Done (g b)\n\n-- | This type class captures those monads which support tail recursion in\n-- | constant stack space.\n-- |\n-- | The `tailRecM` function takes a step function, and applies that step\n-- | function recursively until a pure value of type `b` is found.\n-- |\n-- | Instances are provided for standard monad transformers.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | loopWriter :: Int -> WriterT (Additive Int) Effect Unit\n-- | loopWriter n = tailRecM go n\n-- |   where\n-- |   go 0 = do\n-- |     traceM \"Done!\"\n-- |     pure (Done unit)\n-- |   go i = do\n-- |     tell $ Additive i\n-- |     pure (Loop (i - 1))\n-- | ```\nclass Monad m <= MonadRec m where\n  tailRecM :: forall a b. (a -> m (Step a b)) -> a -> m b\n\n-- | Create a tail-recursive function of two arguments which uses constant stack space.\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM2\n  :: forall m a b c\n   . MonadRec m\n  => (a -> b -> m (Step { a :: a, b :: b } c))\n  -> a\n  -> b\n  -> m c\ntailRecM2 f a b = tailRecM (\\o -> f o.a o.b) { a, b }\n\n-- | Create a tail-recursive function of three arguments which uses constant stack space.\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRecM3\n  :: forall m a b c d\n   . MonadRec m\n  => (a -> b -> c -> m (Step { a :: a, b :: b, c :: c } d))\n  -> a\n  -> b\n  -> c\n  -> m d\ntailRecM3 f a b c = tailRecM (\\o -> f o.a o.b o.c) { a, b, c }\n\n-- | Create a pure tail-recursive function of one argument\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | pow :: Int -> Int -> Int\n-- | pow n p = tailRec go { accum: 1, power: p }\n-- |   where\n-- |   go :: _ -> Step _ Int\n-- |   go { accum: acc, power: 0 } = Done acc\n-- |   go { accum: acc, power: p } = Loop { accum: acc * n, power: p - 1 }\n-- | ```\ntailRec :: forall a b. (a -> Step a b) -> a -> b\ntailRec f = go <<< f\n  where\n  go (Loop a) = go (f a)\n  go (Done b) = b\n\n-- | Create a pure tail-recursive function of two arguments\n-- |\n-- | The `loop2` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec2 :: forall a b c. (a -> b -> Step { a :: a, b :: b } c) -> a -> b -> c\ntailRec2 f a b = tailRec (\\o -> f o.a o.b) { a, b }\n\n-- | Create a pure tail-recursive function of three arguments\n-- |\n-- | The `loop3` helper function provides a curried alternative to the `Loop`\n-- | constructor for this function.\ntailRec3 :: forall a b c d. (a -> b -> c -> Step { a :: a, b :: b, c :: c } d) -> a -> b -> c -> d\ntailRec3 f a b c = tailRec (\\o -> f o.a o.b o.c) { a, b, c }\n\ninstance monadRecIdentity :: MonadRec Identity where\n  tailRecM f = Identity <<< tailRec (runIdentity <<< f)\n    where runIdentity (Identity x) = x\n\ninstance monadRecEffect :: MonadRec Effect where\n  tailRecM f a = do\n    r <- Ref.new =<< f a\n    untilE do\n      Ref.read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          _ <- Ref.write e r\n          pure false\n        Done _ -> pure true\n    fromDone <$> Ref.read r\n    where\n    fromDone :: forall a b. Step a b -> b\n    fromDone = unsafePartial \\(Done b) -> b\n\ninstance monadRecFunction :: MonadRec ((->) e) where\n  tailRecM f a0 e = tailRec (\\a -> f a e) a0\n\ninstance monadRecEither :: MonadRec (Either e) where\n  tailRecM f a0 =\n    let\n      g (Left e) = Done (Left e)\n      g (Right (Loop a)) = Loop (f a)\n      g (Right (Done b)) = Done (Right b)\n    in tailRec g (f a0)\n\ninstance monadRecMaybe :: MonadRec Maybe where\n  tailRecM f a0 =\n    let\n      g Nothing = Done Nothing\n      g (Just (Loop a)) = Loop (f a)\n      g (Just (Done b)) = Done (Just b)\n    in tailRec g (f a0)\n\n-- | `forever` runs an action indefinitely, using the `MonadRec` instance to\n-- | ensure constant stack usage.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = forever $ trace \"Hello, World!\"\n-- | ```\nforever :: forall m a b. MonadRec m => m a -> m b\nforever ma = tailRecM (\\u -> Loop u <$ ma) unit\n\n-- | While supplied computation evaluates to `Just _`, it will be\n-- | executed repeatedly and results will be combined using monoid instance.\nwhileJust :: forall a m. Monoid a => MonadRec m => m (Maybe a) -> m a\nwhileJust m = mempty # tailRecM \\v -> m <#> case _ of\n  Nothing -> Done v\n  Just x -> Loop $ v <> x\n\n-- | Supplied computation will be executed repeatedly until it evaluates\n-- | to `Just value` and then that `value` will be returned.\nuntilJust :: forall a m. MonadRec m => m (Maybe a) -> m a\nuntilJust m = unit # tailRecM \\_ -> m <#> case _ of\n  Nothing -> Loop unit\n  Just x -> Done x\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec2` and `tailRecM2`.\nloop2 :: forall a b c. a -> b -> Step { a :: a, b :: b } c\nloop2 a b = Loop { a, b }\n\n-- | A curried version of the `Loop` constructor, provided as a convenience for\n-- | use with `tailRec3` and `tailRecM3`.\nloop3 :: forall a b c d. a -> b -> c -> Step { a :: a, b :: b, c :: c } d\nloop3 a b c = Loop { a, b, c }\n", "// module Unsafe.Coerce\n\nexport const unsafeCoerce = function (x) {\n  return x;\n};\n", "export const boolConj = function (b1) {\n  return function (b2) {\n    return b1 && b2;\n  };\n};\n\nexport const boolDisj = function (b1) {\n  return function (b2) {\n    return b1 || b2;\n  };\n};\n\nexport const boolNot = function (b) {\n  return !b;\n};\n", "module Data.HeytingAlgebra\n  ( class HeytingAlgebra\n  , tt\n  , ff\n  , implies\n  , conj\n  , disj\n  , not\n  , (&&)\n  , (||)\n  , class HeytingAlgebraRecord\n  , ffRecord\n  , ttRecord\n  , impliesRecord\n  , conjRecord\n  , disjRecord\n  , notRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Proxy (Proxy(..))\n\n-- | The `HeytingAlgebra` type class represents types that are bounded lattices with\n-- | an implication operator such that the following laws hold:\n-- |\n-- | - Associativity:\n-- |   - `a || (b || c) = (a || b) || c`\n-- |   - `a && (b && c) = (a && b) && c`\n-- | - Commutativity:\n-- |   - `a || b = b || a`\n-- |   - `a && b = b && a`\n-- | - Absorption:\n-- |   - `a || (a && b) = a`\n-- |   - `a && (a || b) = a`\n-- | - Idempotent:\n-- |   - `a || a = a`\n-- |   - `a && a = a`\n-- | - Identity:\n-- |   - `a || ff = a`\n-- |   - `a && tt = a`\n-- | - Implication:\n-- |   - ``a `implies` a = tt``\n-- |   - ``a && (a `implies` b) = a && b``\n-- |   - ``b && (a `implies` b) = b``\n-- |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``\n-- | - Complemented:\n-- |   - ``not a = a `implies` ff``\nclass HeytingAlgebra a where\n  ff :: a\n  tt :: a\n  implies :: a -> a -> a\n  conj :: a -> a -> a\n  disj :: a -> a -> a\n  not :: a -> a\n\ninfixr 3 conj as &&\ninfixr 2 disj as ||\n\ninstance heytingAlgebraBoolean :: HeytingAlgebra Boolean where\n  ff = false\n  tt = true\n  implies a b = not a || b\n  conj = boolConj\n  disj = boolDisj\n  not = boolNot\n\ninstance heytingAlgebraUnit :: HeytingAlgebra Unit where\n  ff = unit\n  tt = unit\n  implies _ _ = unit\n  conj _ _ = unit\n  disj _ _ = unit\n  not _ = unit\n\ninstance heytingAlgebraFunction :: HeytingAlgebra b => HeytingAlgebra (a -> b) where\n  ff _ = ff\n  tt _ = tt\n  implies f g a = f a `implies` g a\n  conj f g a = f a && g a\n  disj f g a = f a || g a\n  not f a = not (f a)\n\ninstance heytingAlgebraProxy :: HeytingAlgebra (Proxy a) where\n  conj _ _ = Proxy\n  disj _ _ = Proxy\n  implies _ _ = Proxy\n  ff = Proxy\n  not _ = Proxy\n  tt = Proxy\n\ninstance heytingAlgebraRecord :: (RL.RowToList row list, HeytingAlgebraRecord list row row) => HeytingAlgebra (Record row) where\n  ff = ffRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  tt = ttRecord (Proxy :: Proxy list) (Proxy :: Proxy row)\n  conj = conjRecord (Proxy :: Proxy list)\n  disj = disjRecord (Proxy :: Proxy list)\n  implies = impliesRecord (Proxy :: Proxy list)\n  not = notRecord (Proxy :: Proxy list)\n\nforeign import boolConj :: Boolean -> Boolean -> Boolean\nforeign import boolDisj :: Boolean -> Boolean -> Boolean\nforeign import boolNot :: Boolean -> Boolean\n\n-- | A class for records where all fields have `HeytingAlgebra` instances, used\n-- | to implement the `HeytingAlgebra` instance for records.\nclass HeytingAlgebraRecord :: RL.RowList Type -> Row Type -> Row Type -> Constraint\nclass HeytingAlgebraRecord rowlist row subrow | rowlist -> subrow where\n  ffRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  ttRecord :: Proxy rowlist -> Proxy row -> Record subrow\n  impliesRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  disjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  conjRecord :: Proxy rowlist -> Record row -> Record row -> Record subrow\n  notRecord :: Proxy rowlist -> Record row -> Record subrow\n\ninstance heytingAlgebraRecordNil :: HeytingAlgebraRecord RL.Nil row () where\n  conjRecord _ _ _ = {}\n  disjRecord _ _ _ = {}\n  ffRecord _ _ = {}\n  impliesRecord _ _ _ = {}\n  notRecord _ _ = {}\n  ttRecord _ _ = {}\n\ninstance heytingAlgebraRecordCons ::\n  ( IsSymbol key\n  , Row.Cons key focus subrowTail subrow\n  , HeytingAlgebraRecord rowlistTail row subrowTail\n  , HeytingAlgebra focus\n  ) =>\n  HeytingAlgebraRecord (RL.Cons key focus rowlistTail) row subrow where\n  conjRecord _ ra rb = insert (conj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = conjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  disjRecord _ ra rb = insert (disj (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = disjRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  impliesRecord _ ra rb = insert (implies (get ra) (get rb)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = impliesRecord (Proxy :: Proxy rowlistTail) ra rb\n\n  ffRecord _ row = insert ff tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ffRecord (Proxy :: Proxy rowlistTail) row\n\n  notRecord _ row = insert (not (get row)) tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    get = unsafeGet key :: Record row -> focus\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = notRecord (Proxy :: Proxy rowlistTail) row\n\n  ttRecord _ row = insert tt tail\n    where\n    key = reflectSymbol (Proxy :: Proxy key)\n    insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n    tail = ttRecord (Proxy :: Proxy rowlistTail) row\n", "-- | A data type and functions for working with ordered pairs.\nmodule Data.Tuple where\n\nimport Prelude\n\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy, defer)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Generic.Rep (class Generic)\nimport Data.HeytingAlgebra (implies, ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | A simple product type for wrapping a pair of component values.\ndata Tuple a b = Tuple a b\n\n-- | Allows `Tuple`s to be rendered as a string with `show` whenever there are\n-- | `Show` instances for both component types.\ninstance showTuple :: (Show a, Show b) => Show (Tuple a b) where\n  show (Tuple a b) = \"(Tuple \" <> show a <> \" \" <> show b <> \")\"\n\n-- | Allows `Tuple`s to be checked for equality with `==` and `/=` whenever\n-- | there are `Eq` instances for both component types.\nderive instance eqTuple :: (Eq a, Eq b) => Eq (Tuple a b)\n\nderive instance eq1Tuple :: Eq a => Eq1 (Tuple a)\n\n-- | Allows `Tuple`s to be compared with `compare`, `>`, `>=`, `<` and `<=`\n-- | whenever there are `Ord` instances for both component types. To obtain\n-- | the result, the `fst`s are `compare`d, and if they are `EQ`ual, the\n-- | `snd`s are `compare`d.\nderive instance ordTuple :: (Ord a, Ord b) => Ord (Tuple a b)\n\nderive instance ord1Tuple :: Ord a => Ord1 (Tuple a)\n\ninstance boundedTuple :: (Bounded a, Bounded b) => Bounded (Tuple a b) where\n  top = Tuple top top\n  bottom = Tuple bottom bottom\n\ninstance semigroupoidTuple :: Semigroupoid Tuple where\n  compose (Tuple _ c) (Tuple a _) = Tuple a c\n\n-- | The `Semigroup` instance enables use of the associative operator `<>` on\n-- | `Tuple`s whenever there are `Semigroup` instances for the component\n-- | types. The `<>` operator is applied pairwise, so:\n-- | ```purescript\n-- | (Tuple a1 b1) <> (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n-- | ```\ninstance semigroupTuple :: (Semigroup a, Semigroup b) => Semigroup (Tuple a b) where\n  append (Tuple a1 b1) (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n\ninstance monoidTuple :: (Monoid a, Monoid b) => Monoid (Tuple a b) where\n  mempty = Tuple mempty mempty\n\ninstance semiringTuple :: (Semiring a, Semiring b) => Semiring (Tuple a b) where\n  add (Tuple x1 y1) (Tuple x2 y2) = Tuple (add x1 x2) (add y1 y2)\n  one = Tuple one one\n  mul (Tuple x1 y1) (Tuple x2 y2) = Tuple (mul x1 x2) (mul y1 y2)\n  zero = Tuple zero zero\n\ninstance ringTuple :: (Ring a, Ring b) => Ring (Tuple a b) where\n  sub (Tuple x1 y1) (Tuple x2 y2) = Tuple (sub x1 x2) (sub y1 y2)\n\ninstance commutativeRingTuple :: (CommutativeRing a, CommutativeRing b) => CommutativeRing (Tuple a b)\n\ninstance heytingAlgebraTuple :: (HeytingAlgebra a, HeytingAlgebra b) => HeytingAlgebra (Tuple a b) where\n  tt = Tuple tt tt\n  ff = Tuple ff ff\n  implies (Tuple x1 y1) (Tuple x2 y2) = Tuple (x1 `implies` x2) (y1 `implies` y2)\n  conj (Tuple x1 y1) (Tuple x2 y2) = Tuple (conj x1 x2) (conj y1 y2)\n  disj (Tuple x1 y1) (Tuple x2 y2) = Tuple (disj x1 x2) (disj y1 y2)\n  not (Tuple x y) = Tuple (not x) (not y)\n\ninstance booleanAlgebraTuple :: (BooleanAlgebra a, BooleanAlgebra b) => BooleanAlgebra (Tuple a b)\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<$>` operator, applying the function to the second\n-- | component, so:\n-- | ```purescript\n-- | f <$> (Tuple x y) = Tuple x (f y)\n-- | ````\nderive instance functorTuple :: Functor (Tuple a)\n\nderive instance genericTuple :: Generic (Tuple a b) _\n\ninstance invariantTuple :: Invariant (Tuple a) where\n  imap = imapF\n\n-- | The `Apply` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<*>` operator whenever there is a `Semigroup` instance\n-- | for the `fst` component, so:\n-- | ```purescript\n-- | (Tuple a1 f) <*> (Tuple a2 x) == Tuple (a1 <> a2) (f x)\n-- | ```\ninstance applyTuple :: (Semigroup a) => Apply (Tuple a) where\n  apply (Tuple a1 f) (Tuple a2 x) = Tuple (a1 <> a2) (f x)\n\ninstance applicativeTuple :: (Monoid a) => Applicative (Tuple a) where\n  pure = Tuple mempty\n\ninstance bindTuple :: (Semigroup a) => Bind (Tuple a) where\n  bind (Tuple a1 b) f = case f b of\n    Tuple a2 c -> Tuple (a1 <> a2) c\n\ninstance monadTuple :: (Monoid a) => Monad (Tuple a)\n\ninstance extendTuple :: Extend (Tuple a) where\n  extend f t@(Tuple a _) = Tuple a (f t)\n\ninstance comonadTuple :: Comonad (Tuple a) where\n  extract = snd\n\ninstance lazyTuple :: (Lazy a, Lazy b) => Lazy (Tuple a b) where\n  defer f = Tuple (defer $ \\_ -> fst (f unit)) (defer $ \\_ -> snd (f unit))\n\n-- | Returns the first component of a tuple.\nfst :: forall a b. Tuple a b -> a\nfst (Tuple a _) = a\n\n-- | Returns the second component of a tuple.\nsnd :: forall a b. Tuple a b -> b\nsnd (Tuple _ b) = b\n\n-- | Turn a function that expects a tuple into a function of two arguments.\ncurry :: forall a b c. (Tuple a b -> c) -> a -> b -> c\ncurry f a b = f (Tuple a b)\n\n-- | Turn a function of two arguments into a function that expects a tuple.\nuncurry :: forall a b c. (a -> b -> c) -> Tuple a b -> c\nuncurry f (Tuple a b) = f a b\n\n-- | Exchange the first and second components of a tuple.\nswap :: forall a b. Tuple a b -> Tuple b a\nswap (Tuple a b) = Tuple b a\n", "-- | This module defines the `MonadState` type class and its instances.\n\nmodule Control.Monad.State.Class where\n\nimport Prelude (class Monad, Unit, unit)\n\nimport Data.Tuple (Tuple(..))\n\n-- | The `MonadState s` type class represents those monads which support a single piece of mutable\n-- | state of type `s`.\n-- |\n-- | - `state f` updates the state using the function `f`.\n-- |\n-- | An implementation is provided for `StateT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - `do { get ; get } = get`\n-- | - `do { put x ; put y } = put y`\n-- | - `do { put x ; get } = put x $> x`\n-- | - `do { s <- get ; put s } = pure unit`\n-- |\nclass Monad m <= MonadState s m | m -> s where\n  state :: forall a. (s -> (Tuple a s)) -> m a\n\n-- | Get the current state.\nget :: forall m s. MonadState s m => m s\nget = state \\s -> Tuple s s\n\n-- | Get a value which depends on the current state.\ngets :: forall s m a. MonadState s m => (s -> a) -> m a\ngets f = state \\s -> Tuple (f s) s\n\n-- | Set the state.\nput :: forall m s. MonadState s m => s -> m Unit\nput s = state \\_ -> Tuple unit s\n\n-- | Modify the state by applying a function to the current state. The returned\n-- | value is the new state value.\nmodify :: forall s m. MonadState s m => (s -> s) -> m s\nmodify f = state \\s -> let s' = f s in Tuple s' s'\n\nmodify_ :: forall s m. MonadState s m => (s -> s) -> m Unit\nmodify_ f = state \\s -> Tuple unit (f s)\n", "module Effect.Class where\n\nimport Control.Category (identity)\nimport Control.Monad (class Monad)\nimport Effect (Effect)\n\n-- | The `MonadEffect` class captures those monads which support native effects.\n-- |\n-- | Instances are provided for `Effect` itself, and the standard monad\n-- | transformers.\n-- |\n-- | `liftEffect` can be used in any appropriate monad transformer stack to lift an\n-- | action of type `Effect a` into the monad.\n-- |\nclass Monad m <= MonadEffect m where\n  liftEffect :: forall a. Effect a -> m a\n\ninstance monadEffectEffect :: MonadEffect Effect where\n  liftEffect = identity\n", "-- | This module defines the `MonadWriter` type class and its instances.\n\nmodule Control.Monad.Writer.Class where\n\nimport Prelude\n\nimport Data.Tuple (Tuple(..))\n\n-- | The `MonadTell w` type class represents those monads which support a\n-- | monoidal accumulator of type `w`, where `tell` appends a value to the\n-- | accumulator.\n-- |\n-- | An implementation is provided for `WriterT`, and for other monad\n-- | transformers defined in this library.\n-- |\n-- | Law:\n-- |\n-- | - `do { tell x ; tell y } = tell (x <> y)`\nclass (Semigroup w, Monad m) <= MonadTell w m | m -> w where\n  tell :: w -> m Unit\n\n-- | An extension of the `MonadTell` class that introduces some operations on\n-- | the accumulator:\n-- |\n-- | - `listen` modifies the result to include the changes to the accumulator.\n-- | - `pass` applies the returned function to the accumulator.\n-- |\n-- | An implementation is provided for `WriterT`, and for other monad\n-- | transformers defined in this library.\n-- |\n-- | Laws in addition to the `MonadTell` law:\n-- |\n-- | - `do { tell x ; tell y } = tell (x <> y)`\n-- | - `listen (pure a) = pure (Tuple a mempty)`\n-- | - `listen (writer a x) = tell x $> Tuple a x`\nclass (Monoid w, MonadTell w m) <= MonadWriter w m | m -> w where\n  listen :: forall a. m a -> m (Tuple a w)\n  pass :: forall a. m (Tuple a (w -> w)) -> m a\n\n-- | Projects a value from modifications made to the accumulator during an\n-- | action.\nlistens :: forall w m a b. MonadWriter w m => (w -> b) -> m a -> m (Tuple a b)\nlistens f m = do\n  Tuple a w <- listen m\n  pure $ Tuple a (f w)\n\n-- | Modify the final accumulator value by applying a function.\ncensor :: forall w m a. MonadWriter w m => (w -> w) -> m a -> m a\ncensor f m = pass do\n  a <- m\n  pure $ Tuple a f\n", "module Control.Plus\n  ( class Plus, empty\n  , module Control.Alt\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Plus` type class extends the `Alt` type class with a value that\n-- | should be the left and right identity for `(<|>)`.\n-- |\n-- | It is similar to `Monoid`, except that it applies to types of\n-- | kind `* -> *`, like `Array` or `List`, rather than concrete types like\n-- | `String` or `Number`.\n-- |\n-- | `Plus` instances should satisfy the following laws:\n-- |\n-- | - Left identity: `empty <|> x == x`\n-- | - Right identity: `x <|> empty == x`\n-- | - Annihilation: `f <$> empty == empty`\nclass Alt f <= Plus f where\n  empty :: forall a. f a\n\ninstance plusArray :: Plus Array where\n  empty = []\n", "module Safe.Coerce\n  ( module Prim.Coerce\n  , coerce\n  ) where\n\nimport Prim.Coerce (class Coercible)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Coerce a value of one type to a value of some other type, without changing\n-- | its runtime representation. This function behaves identically to\n-- | `unsafeCoerce` at runtime. Unlike `unsafeCoerce`, it is safe, because the\n-- | `Coercible` constraint prevents any use of this function from compiling\n-- | unless the compiler can prove that the two types have the same runtime\n-- | representation.\n-- |\n-- | One application for this function is to avoid doing work that you know is a\n-- | no-op because of newtypes. For example, if you have an `Array (Conj a)` and you\n-- | want an `Array (Disj a)`, you could do `Data.Array.map (un Conj >>> Disj)`, but\n-- | this performs an unnecessary traversal of the array, with O(n) cost.\n-- | `coerce` accomplishes the same with only O(1) cost:\n-- |\n-- | ```purescript\n-- | mapConjToDisj :: forall a. Array (Conj a) -> Array (Disj a)\n-- | mapConjToDisj = coerce\n-- | ```\ncoerce :: forall a b. Coercible a b => a -> b\ncoerce = unsafeCoerce\n", "-- | This module defines the writer monad transformer, `WriterT`.\n\nmodule Control.Monad.Writer.Trans\n  ( WriterT(..), runWriterT, execWriterT, mapWriterT\n  , module Control.Monad.Trans.Class\n  , module Control.Monad.Writer.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Monad.Cont.Class (class MonadCont, callCC)\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError, catchError, throwError)\nimport Control.Monad.Reader.Class (class MonadAsk, class MonadReader, ask, local)\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(..))\nimport Control.Monad.ST.Class (class MonadST, liftST)\nimport Control.Monad.State.Class (class MonadState, state)\nimport Control.Monad.Trans.Class (class MonadTrans, lift)\nimport Control.Monad.Writer.Class (class MonadTell, tell, class MonadWriter, censor, listen, listens, pass)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus, empty)\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple(..), snd)\nimport Effect.Class (class MonadEffect, liftEffect)\n\n-- | The writer monad transformer.\n-- |\n-- | This monad transformer extends the base monad with a monoidal accumulator of\n-- | type `w`.\n-- |\n-- | The `MonadWriter` type class describes the operations supported by this monad.\nnewtype WriterT w m a = WriterT (m (Tuple a w))\n\n-- | Run a computation in the `WriterT` monad.\nrunWriterT :: forall w m a. WriterT w m a -> m (Tuple a w)\nrunWriterT (WriterT x) = x\n\n-- | Run a computation in the `WriterT` monad, discarding the result.\nexecWriterT :: forall w m a. Functor m => WriterT w m a -> m w\nexecWriterT (WriterT m) = snd <$> m\n\n-- | Change the accumulator and base monad types in a `WriterT` monad action.\nmapWriterT :: forall w1 w2 m1 m2 a b. (m1 (Tuple a w1) -> m2 (Tuple b w2)) -> WriterT w1 m1 a -> WriterT w2 m2 b\nmapWriterT f (WriterT m) = WriterT (f m)\n\nderive instance newtypeWriterT :: Newtype (WriterT w m a) _\n\ninstance functorWriterT :: Functor m => Functor (WriterT w m) where\n  map f = mapWriterT $ map \\(Tuple a w) -> Tuple (f a) w\n\ninstance applyWriterT :: (Semigroup w, Apply m) => Apply (WriterT w m) where\n  apply (WriterT f) (WriterT v) = WriterT\n    let k (Tuple a w) (Tuple b w') = Tuple (a b) (w <> w')\n    in k <$> f <*> v\n\ninstance applicativeWriterT :: (Monoid w, Applicative m) => Applicative (WriterT w m) where\n  pure a = WriterT $ pure $ Tuple a mempty\n\ninstance altWriterT :: Alt m => Alt (WriterT w m) where\n  alt (WriterT m) (WriterT n) = WriterT (m <|> n)\n\ninstance plusWriterT :: Plus m => Plus (WriterT w m) where\n  empty = WriterT empty\n\ninstance alternativeWriterT :: (Monoid w, Alternative m) => Alternative (WriterT w m)\n\ninstance bindWriterT :: (Semigroup w, Bind m) => Bind (WriterT w m) where\n  bind (WriterT m) k = WriterT $\n    m >>= \\(Tuple a w) ->\n      case k a of\n        WriterT wt ->\n          map (\\(Tuple b w') -> Tuple b (w <> w')) wt\n\ninstance monadWriterT :: (Monoid w, Monad m) => Monad (WriterT w m)\n\ninstance monadRecWriterT :: (Monoid w, MonadRec m) => MonadRec (WriterT w m) where\n  tailRecM f a = WriterT $ tailRecM f' (Tuple a mempty)\n    where\n    f' (Tuple a' w) =\n      case f a' of\n        WriterT wt -> wt >>= \\(Tuple m w1) ->\n          pure case m of\n            Loop x -> Loop (Tuple x (w <> w1))\n            Done y -> Done (Tuple y (w <> w1))\n\ninstance monadPlusWriterT :: (Monoid w, MonadPlus m) => MonadPlus (WriterT w m)\n\ninstance monadTransWriterT :: Monoid w => MonadTrans (WriterT w) where\n  lift m = WriterT do\n    a <- m\n    pure $ Tuple a mempty\n\ninstance monadEffectWriter :: (Monoid w, MonadEffect m) => MonadEffect (WriterT w m) where\n  liftEffect = lift <<< liftEffect\n\ninstance monadContWriterT :: (Monoid w, MonadCont m) => MonadCont (WriterT w m) where\n  callCC f = WriterT $ callCC \\c ->\n    case f (\\a -> WriterT $ c (Tuple a mempty)) of WriterT b -> b\n\ninstance monadThrowWriterT :: (Monoid w, MonadThrow e m) => MonadThrow e (WriterT w m) where\n  throwError e = lift (throwError e)\n\ninstance monadErrorWriterT :: (Monoid w, MonadError e m) => MonadError e (WriterT w m) where\n  catchError (WriterT m) h = WriterT $ catchError m (\\e -> case h e of WriterT a -> a)\n\ninstance monadAskWriterT :: (Monoid w, MonadAsk r m) => MonadAsk r (WriterT w m) where\n  ask = lift ask\n\ninstance monadReaderWriterT :: (Monoid w, MonadReader r m) => MonadReader r (WriterT w m) where\n  local f = mapWriterT (local f)\n\ninstance monadStateWriterT :: (Monoid w, MonadState s m) => MonadState s (WriterT w m) where\n  state f = lift (state f)\n\ninstance monadTellWriterT :: (Monoid w, Monad m) => MonadTell w (WriterT w m) where\n  tell = WriterT <<< pure <<< Tuple unit\n\ninstance monadWriterWriterT :: (Monoid w, Monad m) => MonadWriter w (WriterT w m) where\n  listen (WriterT m) = WriterT do\n    Tuple a w <- m\n    pure $ Tuple (Tuple a w) w\n  pass (WriterT m) = WriterT do\n    Tuple (Tuple a f) w <- m\n    pure $ Tuple a (f w)\n\ninstance semigroupWriterT :: (Apply m, Semigroup w, Semigroup a) => Semigroup (WriterT w m a) where\n  append = lift2 (<>)\n\ninstance monoidWriterT :: (Applicative m, Monoid w, Monoid a) => Monoid (WriterT w m a) where\n  mempty = pure mempty\n\ninstance (Monoid w, MonadST s m) => MonadST s (WriterT w m) where\n  liftST = lift <<< liftST\n", "module Data.Profunctor where\n\nimport Prelude\nimport Data.Newtype (class Newtype, wrap, unwrap)\n\n-- | A `Profunctor` is a `Functor` from the pair category `(Type^op, Type)`\n-- | to `Type`.\n-- |\n-- | In other words, a `Profunctor` is a type constructor of two type\n-- | arguments, which is contravariant in its first argument and covariant\n-- | in its second argument.\n-- |\n-- | The `dimap` function can be used to map functions over both arguments\n-- | simultaneously.\n-- |\n-- | A straightforward example of a profunctor is the function arrow `(->)`.\n-- |\n-- | Laws:\n-- |\n-- | - Identity: `dimap identity identity = identity`\n-- | - Composition: `dimap f1 g1 <<< dimap f2 g2 = dimap (f1 >>> f2) (g1 <<< g2)`\nclass Profunctor p where\n  dimap :: forall a b c d. (a -> b) -> (c -> d) -> p b c -> p a d\n\n-- | Map a function over the (contravariant) first type argument only.\nlcmap :: forall a b c p. Profunctor p => (a -> b) -> p b c -> p a c\nlcmap a2b = dimap a2b identity\n\n-- | Map a function over the (covariant) second type argument only.\nrmap :: forall a b c p. Profunctor p => (b -> c) -> p a b -> p a c\nrmap b2c = dimap identity b2c\n\n-- | Lift a pure function into any `Profunctor` which is also a `Category`.\narr :: forall a b p. Category p => Profunctor p => (a -> b) -> p a b\narr f = rmap f identity\n\nunwrapIso :: forall p t a. Profunctor p => Newtype t a => p t t -> p a a\nunwrapIso = dimap wrap unwrap\n\nwrapIso :: forall p t a. Profunctor p => Newtype t a => (a -> t) -> p a a -> p t t\nwrapIso _ = dimap unwrap wrap\n\ninstance profunctorFn :: Profunctor (->) where\n  dimap a2b c2d b2c = a2b >>> b2c >>> c2d\n", "module Control.Parallel.Class where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Monad.Cont.Trans (ContT(..), runContT)\nimport Control.Monad.Except.Trans (ExceptT(..))\nimport Control.Monad.Maybe.Trans (MaybeT(..))\nimport Control.Monad.Reader.Trans (mapReaderT, ReaderT)\nimport Control.Monad.Writer.Trans (mapWriterT, WriterT)\nimport Control.Plus (class Plus)\nimport Data.Either (Either)\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Costar (Costar(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Profunctor.Star (Star(..))\nimport Effect.Class (class MonadEffect, liftEffect)\nimport Effect.Ref as Ref\n\n-- | The `Parallel` class abstracts over pairs of `Apply`s where one of them\n-- | (`m`) composes sequentially, and the other (`f`) composes in parallel.\n-- | `m` is usually a `Monad`, which enforces the sequential nature of its\n-- | composition, but it doesn't need to be.\nclass (Apply m, Apply f) <= Parallel f m | m -> f, f -> m where\n  parallel :: m ~> f\n  sequential :: f ~> m\n\ninstance monadParExceptT :: (Parallel f m, Monad m) => Parallel (Compose f (Either e)) (ExceptT e m) where\n  parallel (ExceptT ma) = Compose (parallel ma)\n  sequential (Compose fa) = ExceptT (sequential fa)\n\ninstance monadParReaderT :: Parallel f m => Parallel (ReaderT e f) (ReaderT e m) where\n  parallel = mapReaderT parallel\n  sequential = mapReaderT sequential\n\ninstance monadParWriterT :: (Monoid w, Parallel f m) => Parallel (WriterT w f) (WriterT w m) where\n  parallel = mapWriterT parallel\n  sequential = mapWriterT sequential\n\ninstance monadParMaybeT :: (Parallel f m, Monad m) => Parallel (Compose f Maybe) (MaybeT m) where\n  parallel (MaybeT ma) = Compose (parallel ma)\n  sequential (Compose fa) = MaybeT (sequential fa)\n\ninstance monadParStar :: Parallel f m => Parallel (Star f a) (Star m a) where\n  parallel (Star f) = (Star $ parallel <<< f)\n  sequential (Star f) = (Star $ sequential <<< f)\n\ninstance monadParCostar :: Parallel f m => Parallel (Costar f a) (Costar m a) where\n  parallel (Costar f) = (Costar $ sequential >>> f)\n  sequential (Costar f) = (Costar $ parallel >>> f)\n\n-- | The `ParCont` type constructor provides an `Applicative` instance\n-- | based on `ContT Unit m`, which waits for multiple continuations to be\n-- | resumed simultaneously.\n-- |\n-- | ParCont sections of code can be embedded in sequential code by using\n-- | the `parallel` and `sequential` functions:\n-- |\n-- | ```purescript\n-- | loadModel :: ContT Unit (Eff (ajax :: AJAX)) Model\n-- | loadModel = do\n-- |   token <- authenticate\n-- |   sequential $\n-- |     Model <$> parallel (get \"/products/popular/\" token)\n-- |           <*> parallel (get \"/categories/all\" token)\n-- | ```\nnewtype ParCont m a = ParCont (ContT Unit m a)\n\nderive instance newtypeParCont :: Newtype (ParCont m a) _\n\ninstance functorParCont :: MonadEffect m => Functor (ParCont m) where\n  map f = parallel <<< map f <<< sequential\n\ninstance applyParCont :: MonadEffect m => Apply (ParCont m) where\n  apply (ParCont ca) (ParCont cb) = ParCont $ ContT \\k -> do\n    ra <- liftEffect (Ref.new Nothing)\n    rb <- liftEffect (Ref.new Nothing)\n\n    runContT ca \\a -> do\n      mb <- liftEffect (Ref.read rb)\n      case mb of\n        Nothing -> liftEffect (Ref.write (Just a) ra)\n        Just b -> k (a b)\n\n    runContT cb \\b -> do\n      ma <- liftEffect (Ref.read ra)\n      case ma of\n        Nothing -> liftEffect (Ref.write (Just b) rb)\n        Just a -> k (a b)\n\ninstance applicativeParCont :: MonadEffect m => Applicative (ParCont m) where\n  pure = parallel <<< pure\n\ninstance altParCont :: MonadEffect m => Alt (ParCont m) where\n  alt (ParCont c1) (ParCont c2) = ParCont $ ContT \\k -> do\n    done <- liftEffect (Ref.new false)\n\n    runContT c1 \\a -> do\n      b <- liftEffect (Ref.read done)\n      if b\n        then pure unit\n        else do\n          liftEffect (Ref.write true done)\n          k a\n\n    runContT c2 \\a -> do\n      b <- liftEffect (Ref.read done)\n      if b\n        then pure unit\n        else do\n          liftEffect (Ref.write true done)\n          k a\n\ninstance plusParCont :: MonadEffect m => Plus (ParCont m) where\n  empty = ParCont $ ContT \\_ -> pure unit\n\ninstance alternativeParCont :: MonadEffect m => Alternative (ParCont m)\n\ninstance monadParParCont :: MonadEffect m => Parallel (ParCont m) (ContT Unit m) where\n  parallel = ParCont\n  sequential (ParCont ma) = ma\n", "export const foldrArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n      }\n      return acc;\n    };\n  };\n};\n\nexport const foldlArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n      }\n      return acc;\n    };\n  };\n};\n", "module Data.Bifunctor where\n\nimport Control.Category (identity)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Tuple (Tuple(..))\n\n-- | A `Bifunctor` is a `Functor` from the pair category `(Type, Type)` to `Type`.\n-- |\n-- | A type constructor with two type arguments can be made into a `Bifunctor` if\n-- | both of its type arguments are covariant.\n-- |\n-- | The `bimap` function maps a pair of functions over the two type arguments\n-- | of the bifunctor.\n-- |\n-- | Laws:\n-- |\n-- | - Identity: `bimap identity identity == identity`\n-- | - Composition: `bimap f1 g1 <<< bimap f2 g2 == bimap (f1 <<< f2) (g1 <<< g2)`\n-- |\nclass Bifunctor f where\n  bimap :: forall a b c d. (a -> b) -> (c -> d) -> f a c -> f b d\n\n-- | Map a function over the first type argument of a `Bifunctor`.\nlmap :: forall f a b c. Bifunctor f => (a -> b) -> f a c -> f b c\nlmap f = bimap f identity\n\n-- | Map a function over the second type arguments of a `Bifunctor`.\nrmap :: forall f a b c. Bifunctor f => (b -> c) -> f a b -> f a c\nrmap = bimap identity\n\ninstance bifunctorEither :: Bifunctor Either where\n  bimap f _ (Left l) = Left (f l)\n  bimap _ g (Right r) = Right (g r)\n\ninstance bifunctorTuple :: Bifunctor Tuple where\n  bimap f g (Tuple x y) = Tuple (f x) (g y)\n\ninstance bifunctorConst :: Bifunctor Const where\n  bimap f _ (Const a) = Const (f a)\n", "module Data.Maybe.First where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Extend (class Extend)\nimport Control.Plus (class Plus)\n\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\n\n-- | Monoid returning the first (left-most) non-`Nothing` value.\n-- |\n-- | ``` purescript\n-- | First (Just x) <> First (Just y) == First (Just x)\n-- | First Nothing <> First (Just y) == First (Just y)\n-- | First Nothing <> First Nothing == First Nothing\n-- | mempty :: First _ == First Nothing\n-- | ```\nnewtype First a = First (Maybe a)\n\nderive instance newtypeFirst :: Newtype (First a) _\n\nderive newtype instance eqFirst :: (Eq a) => Eq (First a)\n\nderive newtype instance eq1First :: Eq1 First\n\nderive newtype instance ordFirst :: (Ord a) => Ord (First a)\n\nderive newtype instance ord1First :: Ord1 First\n\nderive newtype instance boundedFirst :: (Bounded a) => Bounded (First a)\n\nderive newtype instance functorFirst :: Functor First\n\nderive newtype instance invariantFirst :: Invariant First\n\nderive newtype instance applyFirst :: Apply First\n\nderive newtype instance applicativeFirst :: Applicative First\n\nderive newtype instance bindFirst :: Bind First\n\nderive newtype instance monadFirst :: Monad First\n\nderive newtype instance extendFirst :: Extend First\n\ninstance showFirst :: (Show a) => Show (First a) where\n  show (First a) = \"First (\" <> show a <> \")\"\n\ninstance semigroupFirst :: Semigroup (First a) where\n  append first@(First (Just _)) _ = first\n  append _ second = second\n\ninstance monoidFirst :: Monoid (First a) where\n  mempty = First Nothing\n\ninstance altFirst :: Alt First where\n  alt = append\n\ninstance plusFirst :: Plus First where\n  empty = mempty\n\ninstance alternativeFirst :: Alternative First\n", "module Data.Traversable\n  ( class Traversable, traverse, sequence\n  , traverseDefault, sequenceDefault\n  , for\n  , scanl\n  , scanr\n  , mapAccumL\n  , mapAccumR\n  , module Data.Foldable\n  , module Data.Traversable.Accum\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\nimport Data.Const (Const(..))\nimport Data.Either (Either(..))\nimport Data.Foldable (class Foldable, all, and, any, elem, find, fold, foldMap, foldMapDefaultL, foldMapDefaultR, foldl, foldlDefault, foldr, foldrDefault, for_, intercalate, maximum, maximumBy, minimum, minimumBy, notElem, oneOf, or, sequence_, sum, traverse_)\nimport Data.Functor.App (App(..))\nimport Data.Functor.Compose (Compose(..))\nimport Data.Functor.Coproduct (Coproduct(..), coproduct)\nimport Data.Functor.Product (Product(..), product)\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Traversable.Accum (Accum)\nimport Data.Traversable.Accum.Internal (StateL(..), StateR(..), stateL, stateR)\nimport Data.Tuple (Tuple(..))\n\n-- | `Traversable` represents data structures which can be _traversed_,\n-- | accumulating results and effects in some `Applicative` functor.\n-- |\n-- | - `traverse` runs an action for every element in a data structure,\n-- |   and accumulates the results.\n-- | - `sequence` runs the actions _contained_ in a data structure,\n-- |   and accumulates the results.\n-- |\n-- | ```purescript\n-- | import Data.Traversable\n-- | import Data.Maybe\n-- | import Data.Int (fromNumber)\n-- |\n-- | sequence [Just 1, Just 2, Just 3] == Just [1,2,3]\n-- | sequence [Nothing, Just 2, Just 3] == Nothing\n-- |\n-- | traverse fromNumber [1.0, 2.0, 3.0] == Just [1,2,3]\n-- | traverse fromNumber [1.5, 2.0, 3.0] == Nothing\n-- |\n-- | traverse logShow [1,2,3]\n-- | -- prints:\n-- |    1\n-- |    2\n-- |    3\n-- |\n-- | traverse (\\x -> [x, 0]) [1,2,3] == [[1,2,3],[1,2,0],[1,0,3],[1,0,0],[0,2,3],[0,2,0],[0,0,3],[0,0,0]]\n-- | ```\n-- |\n-- | The `traverse` and `sequence` functions should be compatible in the\n-- | following sense:\n-- |\n-- | - `traverse f xs = sequence (f <$> xs)`\n-- | - `sequence = traverse identity`\n-- |\n-- | `Traversable` instances should also be compatible with the corresponding\n-- | `Foldable` instances, in the following sense:\n-- |\n-- | - `foldMap f = runConst <<< traverse (Const <<< f)`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `traverseDefault`\n-- | - `sequenceDefault`\nclass (Functor t, Foldable t) <= Traversable t where\n  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n\n-- | A default implementation of `traverse` using `sequence` and `map`.\ntraverseDefault\n  :: forall t a b m\n   . Traversable t\n  => Applicative m\n  => (a -> m b)\n  -> t a\n  -> m (t b)\ntraverseDefault f ta = sequence (f <$> ta)\n\n-- | A default implementation of `sequence` using `traverse`.\nsequenceDefault\n  :: forall t a m\n   . Traversable t\n  => Applicative m\n  => t (m a)\n  -> m (t a)\nsequenceDefault = traverse identity\n\ninstance traversableArray :: Traversable Array where\n  traverse = traverseArrayImpl apply map pure\n  sequence = sequenceDefault\n\nforeign import traverseArrayImpl\n  :: forall m a b\n   . (forall x y. m (x -> y) -> m x -> m y)\n  -> (forall x y. (x -> y) -> m x -> m y)\n  -> (forall x. x -> m x)\n  -> (a -> m b)\n  -> Array a\n  -> m (Array b)\n\ninstance traversableMaybe :: Traversable Maybe where\n  traverse _ Nothing  = pure Nothing\n  traverse f (Just x) = Just <$> f x\n  sequence Nothing  = pure Nothing\n  sequence (Just x) = Just <$> x\n\ninstance traversableFirst :: Traversable First where\n  traverse f (First x) = First <$> traverse f x\n  sequence (First x) = First <$> sequence x\n\ninstance traversableLast :: Traversable Last where\n  traverse f (Last x) = Last <$> traverse f x\n  sequence (Last x) = Last <$> sequence x\n\ninstance traversableAdditive :: Traversable Additive where\n  traverse f (Additive x) = Additive <$> f x\n  sequence (Additive x) = Additive <$> x\n\ninstance traversableDual :: Traversable Dual where\n  traverse f (Dual x) = Dual <$> f x\n  sequence (Dual x) = Dual <$> x\n\ninstance traversableConj :: Traversable Conj where\n  traverse f (Conj x) = Conj <$> f x\n  sequence (Conj x) = Conj <$> x\n\ninstance traversableDisj :: Traversable Disj where\n  traverse f (Disj x) = Disj <$> f x\n  sequence (Disj x) = Disj <$> x\n\ninstance traversableMultiplicative :: Traversable Multiplicative where\n  traverse f (Multiplicative x) = Multiplicative <$> f x\n  sequence (Multiplicative x) = Multiplicative <$> x\n\ninstance traversableEither :: Traversable (Either a) where\n  traverse _ (Left x)  = pure (Left x)\n  traverse f (Right x) = Right <$> f x\n  sequence (Left x) = pure (Left x)\n  sequence (Right x)  = Right <$> x\n\ninstance traversableTuple :: Traversable (Tuple a) where\n  traverse f (Tuple x y) = Tuple x <$> f y\n  sequence (Tuple x y) = Tuple x <$> y\n\ninstance traversableIdentity :: Traversable Identity where\n  traverse f (Identity x) = Identity <$> f x\n  sequence (Identity x) = Identity <$> x\n\ninstance traversableConst :: Traversable (Const a) where\n  traverse _ (Const x) = pure (Const x)\n  sequence (Const x) = pure (Const x)\n\ninstance traversableProduct :: (Traversable f, Traversable g) => Traversable (Product f g) where\n  traverse f (Product (Tuple fa ga)) = lift2 product (traverse f fa) (traverse f ga)\n  sequence (Product (Tuple fa ga)) = lift2 product (sequence fa) (sequence ga)\n\ninstance traversableCoproduct :: (Traversable f, Traversable g) => Traversable (Coproduct f g) where\n  traverse f = coproduct\n    (map (Coproduct <<< Left) <<< traverse f)\n    (map (Coproduct <<< Right) <<< traverse f)\n  sequence = coproduct\n    (map (Coproduct <<< Left) <<< sequence)\n    (map (Coproduct <<< Right) <<< sequence)\n\ninstance traversableCompose :: (Traversable f, Traversable g) => Traversable (Compose f g) where\n  traverse f (Compose fga) = map Compose $ traverse (traverse f) fga\n  sequence = traverse identity\n\ninstance traversableApp :: Traversable f => Traversable (App f) where\n  traverse f (App x) = App <$> traverse f x\n  sequence (App x) = App <$> sequence x\n\n-- | A version of `traverse` with its arguments flipped.\n-- |\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for [1, 2, 3] \\n -> do\n-- |   print n\n-- |   return (n * n)\n-- | ```\nfor\n  :: forall a b m t\n   . Applicative m\n  => Traversable t\n  => t a\n  -> (a -> m b)\n  -> m (t b)\nfor x f = traverse f x\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```purescript\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nscanl :: forall a b f. Traversable f => (b -> a -> b) -> b -> f a -> f b\nscanl f b0 xs = (mapAccumL (\\b a -> let b' = f b a in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanl`, `mapAccumL` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumL\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumL f s0 xs = stateL (traverse (\\a -> StateL \\s -> f s a) xs) s0\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```purescript\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nscanr :: forall a b f. Traversable f => (a -> b -> b) -> b -> f a -> f b\nscanr f b0 xs = (mapAccumR (\\b a -> let b' = f a b in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanr`, `mapAccumR` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumR\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumR f s0 xs = stateR (traverse (\\a -> StateR \\s -> f s a) xs) s0\n", "module Control.Parallel\n  ( parApply\n  , parTraverse\n  , parTraverse_\n  , parSequence\n  , parSequence_\n  , parOneOf\n  , parOneOfMap\n  , module Control.Parallel.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alternative (class Alternative)\nimport Control.Parallel.Class (class Parallel, parallel, sequential, ParCont(..))\n\nimport Data.Foldable (class Foldable, traverse_, oneOfMap)\nimport Data.Traversable (class Traversable, traverse)\n\n-- | Apply a function to an argument under a type constructor in parallel.\nparApply\n  :: forall f m a b\n   . Parallel f m\n   => m (a -> b)\n   -> m a\n   -> m b\nparApply mf ma = sequential(apply (parallel mf) (parallel ma))\n\n-- | Traverse a collection in parallel.\nparTraverse\n  :: forall f m t a b\n   . Parallel f m\n  => Applicative f\n  => Traversable t\n  => (a -> m b)\n  -> t a\n  -> m (t b)\nparTraverse f = sequential <<< traverse (parallel <<< f)\n\n-- | Traverse a collection in parallel, discarding any results.\nparTraverse_\n  :: forall f m t a b\n   . Parallel f m\n  => Applicative f\n  => Foldable t\n  => (a -> m b)\n  -> t a\n  -> m Unit\nparTraverse_ f = sequential <<< traverse_ (parallel <<< f)\n\nparSequence\n  :: forall a t m f\n   . Parallel f m\n  => Applicative f\n  => Traversable t\n  => t (m a)\n  -> m (t a)\nparSequence = parTraverse identity\n\nparSequence_\n  :: forall a t m f\n   . Parallel f m\n  => Applicative f\n  => Foldable t\n  => t (m a)\n  -> m Unit\nparSequence_ = parTraverse_ identity\n\n-- | Race a collection in parallel.\nparOneOf\n  :: forall a t m f\n   . Parallel f m\n  => Alternative f\n  => Foldable t\n  => Functor t\n  => t (m a)\n  -> m a\nparOneOf = sequential <<< oneOfMap parallel\n\n-- | Race a collection in parallel while mapping to some effect.\nparOneOfMap\n  :: forall a b t m f\n   . Parallel f m\n  => Alternative f\n  => Foldable t\n  => Functor t\n  => (a -> m b)\n  -> t a\n  -> m b\nparOneOfMap f = sequential <<< oneOfMap (parallel <<< f)\n", "export const unsafePerformEffect = function (f) {\n  return f();\n};\n", "// module Partial.Unsafe\n\nexport const _unsafePartial = function (f) {\n  return f();\n};\n", "// module Partial\n\nexport const _crashWith = function (msg) {\n  throw new Error(msg);\n};\n", "-- | Some partial helper functions. See the README for more documentation.\nmodule Partial\n  ( crash\n  , crashWith\n  ) where\n\n-- | A partial function which crashes on any input with a default message.\ncrash :: forall a. Partial => a\ncrash = crashWith \"Partial.crash: partial function\"\n\n-- | A partial function which crashes on any input with the specified message.\ncrashWith :: forall a. Partial => String -> a\ncrashWith = _crashWith\n\nforeign import _crashWith :: forall a. String -> a\n", "-- | Utilities for working with partial functions.\n-- | See the README for more documentation.\nmodule Partial.Unsafe\n  ( unsafePartial\n  , unsafeCrashWith\n  ) where\n\nimport Partial (crashWith)\n\n-- Note: this function's type signature is more like\n-- `(Unit -> a) -> a`. However, we would need to use\n-- `unsafeCoerce` to make this compile, incurring\n-- either a dependency or reimplementing it here.\n-- Rather than doing that, we'll use a type signature\n-- of `a -> b` instead.\nforeign import _unsafePartial :: forall a b. a -> b\n\n-- | Discharge a partiality constraint, unsafely.\nunsafePartial :: forall a. (Partial => a) -> a\nunsafePartial = _unsafePartial\n\n-- | A function which crashes with the specified error message.\nunsafeCrashWith :: forall a. String -> a\nunsafeCrashWith msg = unsafePartial (crashWith msg)\n", "module Effect.Aff.Class where\n\nimport Prelude\nimport Control.Monad.Cont.Trans (ContT)\nimport Control.Monad.Except.Trans (ExceptT)\nimport Control.Monad.List.Trans (ListT)\nimport Control.Monad.Maybe.Trans (MaybeT)\nimport Control.Monad.Reader.Trans (ReaderT)\nimport Control.Monad.RWS.Trans (RWST)\nimport Control.Monad.State.Trans (StateT)\nimport Control.Monad.Trans.Class (lift)\nimport Control.Monad.Writer.Trans (WriterT)\nimport Effect.Aff (Aff)\nimport Effect.Class (class MonadEffect)\n\nclass MonadEffect m <= MonadAff m where\n  liftAff :: Aff ~> m\n\ninstance monadAffAff :: MonadAff Aff where\n  liftAff = identity\n\ninstance monadAffContT :: MonadAff m => MonadAff (ContT r m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffExceptT :: MonadAff m => MonadAff (ExceptT e m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffListT :: MonadAff m => MonadAff (ListT m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffMaybe :: MonadAff m => MonadAff (MaybeT m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffReader :: MonadAff m => MonadAff (ReaderT r m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffRWS :: (MonadAff m, Monoid w) => MonadAff (RWST r w s m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffState :: MonadAff m => MonadAff (StateT s m) where\n  liftAff = lift <<< liftAff\n\ninstance monadAffWriter :: (MonadAff m, Monoid w) => MonadAff (WriterT w m) where\n  liftAff = lift <<< liftAff\n", "module Data.Semigroup.Foldable\n  ( class Foldable1\n  , foldMap1\n  , fold1\n  , foldr1\n  , foldl1\n  , traverse1_\n  , for1_\n  , sequence1_\n  , foldr1Default\n  , foldl1Default\n  , foldMap1DefaultR\n  , foldMap1DefaultL\n  , intercalate\n  , intercalateMap\n  , maximum\n  , maximumBy\n  , minimum\n  , minimumBy\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable)\nimport Data.Identity (Identity(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (ala, alaF)\nimport Data.Ord.Max (Max(..))\nimport Data.Ord.Min (Min(..))\nimport Data.Tuple (Tuple(..))\n\n-- | `Foldable1` represents data structures with a minimum of one element that can be _folded_.\n-- |\n-- | - `foldr1` folds a structure from the right\n-- | - `foldl1` folds a structure from the left\n-- | - `foldMap1` folds a structure by accumulating values in a `Semigroup`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldr1Default`\n-- | - `foldl1Default`\n-- | - `foldMap1DefaultR`\n-- | - `foldMap1DefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable t <= Foldable1 t where\n  foldr1 :: forall a. (a -> a -> a) -> t a -> a\n  foldl1 :: forall a. (a -> a -> a) -> t a -> a\n  foldMap1 :: forall a m. Semigroup m => (a -> m) -> t a -> m\n\n-- | A default implementation of `foldr1` using `foldMap1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldMap1DefaultR`.\nfoldr1Default :: forall t a. Foldable1 t => (a -> a -> a) -> t a -> a\nfoldr1Default = flip (runFoldRight1 <<< foldMap1 mkFoldRight1)\n\n-- | A default implementation of `foldl1` using `foldMap1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldMap1DefaultL`.\nfoldl1Default :: forall t a. Foldable1 t => (a -> a -> a) -> t a -> a\nfoldl1Default = flip (runFoldRight1 <<< alaF Dual foldMap1 mkFoldRight1) <<< flip\n\n-- | A default implementation of `foldMap1` using `foldr1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldr1Default`.\nfoldMap1DefaultR :: forall t m a. Foldable1 t => Functor t => Semigroup m => (a -> m) -> t a -> m\nfoldMap1DefaultR f = map f >>> foldr1 (<>)\n\n-- | A default implementation of `foldMap1` using `foldl1`.\n-- |\n-- | Note: when defining a `Foldable1` instance, this function is unsafe to use\n-- | in combination with `foldl1Default`.\nfoldMap1DefaultL :: forall t m a. Foldable1 t => Functor t => Semigroup m => (a -> m) -> t a -> m\nfoldMap1DefaultL f = map f >>> foldl1 (<>)\n\ninstance foldableDual :: Foldable1 Dual where\n  foldr1 _ (Dual x) = x\n  foldl1 _ (Dual x) = x\n  foldMap1 f (Dual x) = f x\n\ninstance foldableMultiplicative :: Foldable1 Multiplicative where\n  foldr1 _ (Multiplicative x) = x\n  foldl1 _ (Multiplicative x) = x\n  foldMap1 f (Multiplicative x) = f x\n\ninstance foldableTuple :: Foldable1 (Tuple a) where\n  foldMap1 f (Tuple _ x) = f x\n  foldr1 _ (Tuple _ x) = x\n  foldl1 _ (Tuple _ x) = x\n\ninstance foldableIdentity :: Foldable1 Identity where\n  foldMap1 f (Identity x) = f x\n  foldl1 _ (Identity x) = x\n  foldr1 _ (Identity x) = x\n\n-- | Fold a data structure, accumulating values in some `Semigroup`.\nfold1 :: forall t m. Foldable1 t => Semigroup m => t m -> m\nfold1 = foldMap1 identity\n\nnewtype Act :: forall k. (k -> Type) -> k -> Type\nnewtype Act f a = Act (f a)\n\ngetAct :: forall f a. Act f a -> f a\ngetAct (Act f) = f\n\ninstance semigroupAct :: Apply f => Semigroup (Act f a) where\n  append (Act a) (Act b) = Act (a *> b)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Apply` instance at each value, ignoring the final result.\ntraverse1_ :: forall t f a b. Foldable1 t => Apply f => (a -> f b) -> t a -> f Unit\ntraverse1_ f t = unit <$ getAct (foldMap1 (Act <<< f) t)\n\n-- | A version of `traverse1_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\nfor1_ :: forall t f a b. Foldable1 t => Apply f => t a -> (a -> f b) -> f Unit\nfor1_ = flip traverse1_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable1` instance, ignoring the final result.\nsequence1_ :: forall t f a. Foldable1 t => Apply f => t (f a) -> f Unit\nsequence1_ = traverse1_ identity\n\nmaximum :: forall f a. Ord a => Foldable1 f => f a -> a\nmaximum = ala Max foldMap1\n\nmaximumBy :: forall f a. Foldable1 f => (a -> a -> Ordering) -> f a -> a\nmaximumBy cmp = foldl1 \\x y -> if cmp x y == GT then x else y\n\nminimum :: forall f a. Ord a => Foldable1 f => f a -> a\nminimum = ala Min foldMap1\n\nminimumBy :: forall f a. Foldable1 f => (a -> a -> Ordering) -> f a -> a\nminimumBy cmp = foldl1 \\x y -> if cmp x y == LT then x else y\n\n-- | Internal. Used by intercalation functions.\nnewtype JoinWith a = JoinWith (a -> a)\n\njoinee :: forall a. JoinWith a -> a -> a\njoinee (JoinWith x) = x\n\ninstance semigroupJoinWith :: Semigroup a => Semigroup (JoinWith a) where\n  append (JoinWith a) (JoinWith b) = JoinWith $ \\j -> a j <> j <> b j\n\n-- | Fold a data structure using a `Semigroup` instance,\n-- | combining adjacent elements using the specified separator.\nintercalate :: forall f m. Foldable1 f => Semigroup m => m -> f m -> m\nintercalate = flip intercalateMap identity\n\n-- | Fold a data structure, accumulating values in some `Semigroup`,\n-- | combining adjacent elements using the specified separator.\nintercalateMap\n  :: forall f m a\n   . Foldable1 f\n  => Semigroup m\n  => m -> (a -> m) -> f a -> m\nintercalateMap j f foldable =\n  joinee (foldMap1 (JoinWith <<< const <<< f) foldable) j\n\n-- | Internal. Used by foldr1Default and foldl1Default.\ndata FoldRight1 a = FoldRight1 (a -> (a -> a -> a) -> a) a\n\ninstance foldRight1Semigroup :: Semigroup (FoldRight1 a) where\n  append (FoldRight1 lf lr) (FoldRight1 rf rr) = FoldRight1 (\\a f -> lf (f lr (rf a f)) f) rr\n\nmkFoldRight1 :: forall a. a -> FoldRight1 a\nmkFoldRight1 = FoldRight1 const\n\nrunFoldRight1 :: forall a. FoldRight1 a -> (a -> a -> a) -> a\nrunFoldRight1 (FoldRight1 f a) = f a\n", "-- | This module defines a generic non-empty data structure, which adds an\n-- | additional element to any container type.\nmodule Data.NonEmpty\n  ( NonEmpty(..)\n  , singleton\n  , (:|)\n  , foldl1\n  , fromNonEmpty\n  , oneOf\n  , head\n  , tail\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Plus (class Plus, empty)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, foldMap)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldMapWithIndex, foldlWithIndex, foldrWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Ord (class Ord1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Foldable (foldl1) as Foldable1\nimport Data.Traversable (class Traversable, traverse, sequence)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (uncurry)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | A non-empty container of elements of type a.\n-- |\n-- | ```purescript\n-- | import Data.NonEmpty\n-- |\n-- | nonEmptyArray :: NonEmpty Array Int\n-- | nonEmptyArray = NonEmpty 1 [2,3]\n-- |\n-- | import Data.List(List(..), (:))\n-- |\n-- | nonEmptyList :: NonEmpty List Int\n-- | nonEmptyList = NonEmpty 1 (2 : 3 : Nil)\n-- | ```\ndata NonEmpty f a = NonEmpty a (f a)\n\n-- | An infix synonym for `NonEmpty`.\n-- |\n-- | ```purescript\n-- | nonEmptyArray :: NonEmpty Array Int\n-- | nonEmptyArray = 1 :| [2,3]\n-- |\n-- | nonEmptyList :: NonEmpty List Int\n-- | nonEmptyList = 1 :| 2 : 3 : Nil\n-- | ```\ninfixr 5 NonEmpty as :|\n\n-- | Create a non-empty structure with a single value.\n-- |\n-- | ```purescript\n-- | import Prelude\n-- |\n-- | singleton 1 == 1 :| []\n-- | singleton 1 == 1 :| Nil\n-- | ```\nsingleton :: forall f a. Plus f => a -> NonEmpty f a\nsingleton a = a :| empty\n\n-- | Fold a non-empty structure, collecting results using a binary operation.\n-- |\n-- | ```purescript\n-- | foldl1 (+) (1 :| [2, 3]) == 6\n-- | ```\nfoldl1 :: forall f a. Foldable f => (a -> a -> a) -> NonEmpty f a -> a\nfoldl1 = Foldable1.foldl1\n\n-- | Apply a function that takes the `first` element and remaining elements\n-- | as arguments to a non-empty container.\n-- |\n-- | For example, return the remaining elements multiplied by the first element:\n-- |\n-- | ```purescript\n-- | fromNonEmpty (\\x xs -> map (_ * x) xs) (3 :| [2, 1]) == [6, 3]\n-- | ```\nfromNonEmpty :: forall f a r. (a -> f a -> r) -> NonEmpty f a -> r\nfromNonEmpty f (a :| fa) = a `f` fa\n\n-- | Returns the `alt` (`<|>`) result of:\n-- | - The first element lifted to the container of the remaining elements.\n-- | - The remaining elements.\n-- |\n-- | ```purescript\n-- | import Data.Maybe(Maybe(..))\n-- |\n-- | oneOf (1 :| Nothing) == Just 1\n-- | oneOf (1 :| Just 2) == Just 1\n-- |\n-- | oneOf (1 :| [2, 3]) == [1,2,3]\n-- | ```\noneOf :: forall f a. Alternative f => NonEmpty f a -> f a\noneOf (a :| fa) = pure a <|> fa\n\n-- | Get the 'first' element of a non-empty container.\n-- |\n-- | ```purescript\n-- | head (1 :| [2, 3]) == 1\n-- | ```\nhead :: forall f a. NonEmpty f a -> a\nhead (x :| _) = x\n\n-- | Get everything but the 'first' element of a non-empty container.\n-- |\n-- | ```purescript\n-- | tail (1 :| [2, 3]) == [2, 3]\n-- | ```\ntail :: forall f a. NonEmpty f a -> f a\ntail (_ :| xs) = xs\n\ninstance showNonEmpty :: (Show a, Show (f a)) => Show (NonEmpty f a) where\n  show (a :| fa) = \"(NonEmpty \" <> show a <> \" \" <> show fa <> \")\"\n\nderive instance eqNonEmpty :: (Eq1 f, Eq a) => Eq (NonEmpty f a)\n\nderive instance eq1NonEmpty :: Eq1 f => Eq1 (NonEmpty f)\n\nderive instance ordNonEmpty :: (Ord1 f, Ord a) => Ord (NonEmpty f a)\n\nderive instance ord1NonEmpty :: Ord1 f => Ord1 (NonEmpty f)\n\nderive instance functorNonEmpty :: Functor f => Functor (NonEmpty f)\n\ninstance functorWithIndex\n  :: FunctorWithIndex i f\n  => FunctorWithIndex (Maybe i) (NonEmpty f) where\n  mapWithIndex f (a :| fa) = f Nothing a :| mapWithIndex (f <<< Just) fa\n\ninstance foldableNonEmpty :: Foldable f => Foldable (NonEmpty f) where\n  foldMap f (a :| fa) = f a <> foldMap f fa\n  foldl f b (a :| fa) = foldl f (f b a) fa\n  foldr f b (a :| fa) = f a (foldr f b fa)\n\ninstance foldableWithIndexNonEmpty\n  :: (FoldableWithIndex i f)\n  => FoldableWithIndex (Maybe i) (NonEmpty f) where\n  foldMapWithIndex f (a :| fa) = f Nothing a <> foldMapWithIndex (f <<< Just) fa\n  foldlWithIndex f b (a :| fa) = foldlWithIndex (f <<< Just) (f Nothing b a) fa\n  foldrWithIndex f b (a :| fa) = f Nothing a (foldrWithIndex (f <<< Just) b fa)\n\ninstance traversableNonEmpty :: Traversable f => Traversable (NonEmpty f) where\n  sequence (a :| fa) = NonEmpty <$> a <*> sequence fa\n  traverse f (a :| fa) = NonEmpty <$> f a <*> traverse f fa\n\ninstance traversableWithIndexNonEmpty\n  :: (TraversableWithIndex i f)\n  => TraversableWithIndex (Maybe i) (NonEmpty f) where\n  traverseWithIndex f (a :| fa) =\n    NonEmpty <$> f Nothing a <*> traverseWithIndex (f <<< Just) fa\n\ninstance foldable1NonEmpty :: Foldable f => Foldable1 (NonEmpty f) where\n  foldMap1 f (a :| fa) = foldl (\\s a1 -> s <> f a1) (f a) fa\n  foldr1 f (a :| fa) = maybe a (f a) $ foldr (\\a1 -> Just <<< maybe a1 (f a1)) Nothing fa\n  foldl1 f (a :| fa) = foldl f a fa\n\ninstance unfoldable1NonEmpty :: Unfoldable f => Unfoldable1 (NonEmpty f) where\n  unfoldr1 f b = uncurry (:|) $ unfoldr (map f) <$> f b\n\n-- | This is a lawful `Semigroup` instance that will behave sensibly for common nonempty\n-- | containers like lists and arrays. However, it's not guaranteed that `pure` will behave\n-- | sensibly alongside `<>` for all types, as we don't have any laws which govern their behavior.\ninstance semigroupNonEmpty\n  :: (Applicative f, Semigroup (f a))\n  => Semigroup (NonEmpty f a) where\n  append (a1 :| f1) (a2 :| f2) = a1 :| (f1 <> pure a2 <> f2)\n", "module Data.List.Types\n  ( List(..)\n  , (:)\n  , NonEmptyList(..)\n  , toList\n  , nelCons\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, intercalate)\nimport Data.FoldableWithIndex (class FoldableWithIndex, foldlWithIndex, foldrWithIndex, foldMapWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty (NonEmpty, (:|))\nimport Data.NonEmpty as NE\nimport Data.Ord (class Ord1, compare1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Traversable (class Traversable1, traverse1)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (Tuple(..), snd)\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\ndata List a = Nil | Cons a (List a)\n\ninfixr 6 Cons as :\n\ninstance showList :: Show a => Show (List a) where\n  show Nil = \"Nil\"\n  show xs = \"(\" <> intercalate \" : \" (show <$> xs) <> \" : Nil)\"\n\ninstance eqList :: Eq a => Eq (List a) where\n  eq = eq1\n\ninstance eq1List :: Eq1 List where\n  eq1 xs ys = go xs ys true\n    where\n      go _ _ false = false\n      go Nil Nil acc = acc\n      go (x : xs') (y : ys') acc = go xs' ys' $ acc && (y == x)\n      go _ _ _ = false\n\ninstance ordList :: Ord a => Ord (List a) where\n  compare = compare1\n\ninstance ord1List :: Ord1 List where\n  compare1 xs ys = go xs ys\n    where\n    go Nil Nil = EQ\n    go Nil _ = LT\n    go _ Nil = GT\n    go (x : xs') (y : ys') =\n      case compare x y of\n        EQ -> go xs' ys'\n        other -> other\n\ninstance semigroupList :: Semigroup (List a) where\n  append xs ys = foldr (:) ys xs\n\ninstance monoidList :: Monoid (List a) where\n  mempty = Nil\n\ninstance functorList :: Functor List where\n  map = listMap\n\n-- chunked list Functor inspired by OCaml\n-- https://discuss.ocaml.org/t/a-new-list-map-that-is-both-stack-safe-and-fast/865\n-- chunk sizes determined through experimentation\nlistMap :: forall a b. (a -> b) -> List a -> List b\nlistMap f = chunkedRevMap Nil\n  where\n  chunkedRevMap :: List (List a) -> List a -> List b\n  chunkedRevMap chunksAcc chunk@(_ : _ : _ : xs) =\n    chunkedRevMap (chunk : chunksAcc) xs\n  chunkedRevMap chunksAcc xs =\n    reverseUnrolledMap chunksAcc $ unrolledMap xs\n    where\n    unrolledMap :: List a -> List b\n    unrolledMap (x1 : x2 : Nil) = f x1 : f x2 : Nil\n    unrolledMap (x1 : Nil) = f x1 : Nil\n    unrolledMap _ = Nil\n\n    reverseUnrolledMap :: List (List a) -> List b -> List b\n    reverseUnrolledMap ((x1 : x2 : x3 : _) : cs) acc =\n      reverseUnrolledMap cs (f x1 : f x2 : f x3 : acc)\n    reverseUnrolledMap _ acc = acc\n\ninstance functorWithIndexList :: FunctorWithIndex Int List where\n  mapWithIndex f = foldrWithIndex (\\i x acc -> f i x : acc) Nil\n\ninstance foldableList :: Foldable List where\n  foldr f b = foldl (flip f) b <<< rev\n    where\n    rev = go Nil\n      where\n      go acc Nil = acc\n      go acc (x : xs) = go (x : acc) xs\n  foldl f = go\n    where\n    go b = case _ of\n      Nil -> b\n      a : as -> go (f b a) as\n  foldMap f = foldl (\\acc -> append acc <<< f) mempty\n\ninstance foldableWithIndexList :: FoldableWithIndex Int List where\n  foldrWithIndex f b xs =\n    -- as we climb the reversed list, we decrement the index\n    snd $ foldl\n            (\\(Tuple i b') a -> Tuple (i - 1) (f (i - 1) a b'))\n            (Tuple len b)\n            revList\n    where\n    Tuple len revList = rev (Tuple 0 Nil) xs\n      where\n      -- As we create our reversed list, we count elements.\n      rev = foldl (\\(Tuple i acc) a -> Tuple (i + 1) (a : acc))\n  foldlWithIndex f acc =\n    snd <<< foldl (\\(Tuple i b) a -> Tuple (i + 1) (f i b a)) (Tuple 0 acc)\n  foldMapWithIndex f = foldlWithIndex (\\i acc -> append acc <<< f i) mempty\n\ninstance unfoldable1List :: Unfoldable1 List where\n  unfoldr1 f b = go b Nil\n    where\n    go source memo = case f source of\n      Tuple one (Just rest) -> go rest (one : memo)\n      Tuple one Nothing -> foldl (flip (:)) Nil (one : memo)\n\ninstance unfoldableList :: Unfoldable List where\n  unfoldr f b = go b Nil\n    where\n    go source memo = case f source of\n      Nothing -> (foldl (flip (:)) Nil memo)\n      Just (Tuple one rest) -> go rest (one : memo)\n\ninstance traversableList :: Traversable List where\n  traverse f = map (foldl (flip (:)) Nil) <<< foldl (\\acc -> lift2 (flip (:)) acc <<< f) (pure Nil)\n  sequence = traverse identity\n\ninstance traversableWithIndexList :: TraversableWithIndex Int List where\n  traverseWithIndex f =\n    map rev\n    <<< foldlWithIndex (\\i acc -> lift2 (flip (:)) acc <<< f i) (pure Nil)\n    where\n    rev = foldl (flip Cons) Nil\n\ninstance applyList :: Apply List where\n  apply Nil _ = Nil\n  apply (f : fs) xs = (f <$> xs) <> (fs <*> xs)\n\ninstance applicativeList :: Applicative List where\n  pure a = a : Nil\n\ninstance bindList :: Bind List where\n  bind Nil _ = Nil\n  bind (x : xs) f = f x <> bind xs f\n\ninstance monadList :: Monad List\n\ninstance altList :: Alt List where\n  alt = append\n\ninstance plusList :: Plus List where\n  empty = Nil\n\ninstance alternativeList :: Alternative List\n\ninstance monadPlusList :: MonadPlus List\n\ninstance extendList :: Extend List where\n  extend _ Nil = Nil\n  extend f l@(_ : as) =\n    f l : (foldr go { val: Nil, acc: Nil } as).val\n    where\n    go a' { val, acc } =\n      let acc' = a' : acc\n      in { val: f acc' : val, acc: acc' }\n\nnewtype NonEmptyList a = NonEmptyList (NonEmpty List a)\n\ntoList :: NonEmptyList ~> List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nnelCons :: forall a. a -> NonEmptyList a -> NonEmptyList a\nnelCons a (NonEmptyList (b :| bs)) = NonEmptyList (a :| b : bs)\n\nderive instance newtypeNonEmptyList :: Newtype (NonEmptyList a) _\n\nderive newtype instance eqNonEmptyList :: Eq a => Eq (NonEmptyList a)\nderive newtype instance ordNonEmptyList :: Ord a => Ord (NonEmptyList a)\n\nderive newtype instance eq1NonEmptyList :: Eq1 NonEmptyList\nderive newtype instance ord1NonEmptyList :: Ord1 NonEmptyList\n\ninstance showNonEmptyList :: Show a => Show (NonEmptyList a) where\n  show (NonEmptyList nel) = \"(NonEmptyList \" <> show nel <> \")\"\n\nderive newtype instance functorNonEmptyList :: Functor NonEmptyList\n\ninstance applyNonEmptyList :: Apply NonEmptyList where\n  apply (NonEmptyList (f :| fs)) (NonEmptyList (a :| as)) =\n    NonEmptyList (f a :| (fs <*> a : Nil) <> ((f : fs) <*> as))\n\ninstance applicativeNonEmptyList :: Applicative NonEmptyList where\n  pure = NonEmptyList <<< NE.singleton\n\ninstance bindNonEmptyList :: Bind NonEmptyList where\n  bind (NonEmptyList (a :| as)) f =\n    case f a of\n      NonEmptyList (b :| bs) ->\n        NonEmptyList (b :| bs <> bind as (toList <<< f))\n\ninstance monadNonEmptyList :: Monad NonEmptyList\n\ninstance altNonEmptyList :: Alt NonEmptyList where\n  alt = append\n\ninstance extendNonEmptyList :: Extend NonEmptyList where\n  extend f w@(NonEmptyList (_ :| as)) =\n    NonEmptyList (f w :| (foldr go { val: Nil, acc: Nil } as).val)\n    where\n    go a { val, acc } = { val: f (NonEmptyList (a :| acc)) : val, acc: a : acc }\n\ninstance comonadNonEmptyList :: Comonad NonEmptyList where\n  extract (NonEmptyList (a :| _)) = a\n\ninstance semigroupNonEmptyList :: Semigroup (NonEmptyList a) where\n  append (NonEmptyList (a :| as)) as' =\n    NonEmptyList (a :| as <> toList as')\n\nderive newtype instance foldableNonEmptyList :: Foldable NonEmptyList\n\nderive newtype instance traversableNonEmptyList :: Traversable NonEmptyList\n\nderive newtype instance foldable1NonEmptyList :: Foldable1 NonEmptyList\n\nderive newtype instance unfoldable1NonEmptyList :: Unfoldable1 NonEmptyList\n\ninstance functorWithIndexNonEmptyList :: FunctorWithIndex Int NonEmptyList where\n  mapWithIndex fn (NonEmptyList ne) = NonEmptyList $ mapWithIndex (fn <<< maybe 0 (add 1)) ne\n\ninstance foldableWithIndexNonEmptyList :: FoldableWithIndex Int NonEmptyList where\n  foldMapWithIndex f (NonEmptyList ne) = foldMapWithIndex (f <<< maybe 0 (add 1)) ne\n  foldlWithIndex f b (NonEmptyList ne) = foldlWithIndex (f <<< maybe 0 (add 1)) b ne\n  foldrWithIndex f b (NonEmptyList ne) = foldrWithIndex (f <<< maybe 0 (add 1)) b ne\n\ninstance traversableWithIndexNonEmptyList :: TraversableWithIndex Int NonEmptyList where\n  traverseWithIndex f (NonEmptyList ne) = NonEmptyList <$> traverseWithIndex (f <<< maybe 0 (add 1)) ne\n\ninstance traversable1NonEmptyList :: Traversable1 NonEmptyList where\n  traverse1 f (NonEmptyList (a :| as)) =\n    foldl (\\acc -> lift2 (flip nelCons) acc <<< f) (pure <$> f a) as\n      <#> case _ of NonEmptyList (x :| xs) \u2192 foldl (flip nelCons) (pure x) xs\n  sequence1 = traverse1 identity\n", "module CSS.String where\n\nimport Prelude\n\nclass IsString s where\n  fromString :: String -> s\n\ninstance isStringString :: IsString String where\n  fromString = identity\n", "//------------------------------------------------------------------------------\n// Array creation --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const rangeImpl = function (start, end) {\n  var step = start > end ? -1 : 1;\n  var result = new Array(step * (end - start) + 1);\n  var i = start, n = 0;\n  while (i !== end) {\n    result[n++] = i;\n    i += step;\n  }\n  result[n] = i;\n  return result;\n};\n\nvar replicateFill = function (count, value) {\n  if (count < 1) {\n    return [];\n  }\n  var result = new Array(count);\n  return result.fill(value);\n};\n\nvar replicatePolyfill = function (count, value) {\n  var result = [];\n  var n = 0;\n  for (var i = 0; i < count; i++) {\n    result[n++] = value;\n  }\n  return result;\n};\n\n// In browsers that have Array.prototype.fill we use it, as it's faster.\nexport const replicateImpl = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n\nexport const fromFoldableImpl = (function () {\n  function Cons(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  var emptyList = {};\n\n  function curryCons(head) {\n    return function (tail) {\n      return new Cons(head, tail);\n    };\n  }\n\n  function listToArray(list) {\n    var result = [];\n    var count = 0;\n    var xs = list;\n    while (xs !== emptyList) {\n      result[count++] = xs.head;\n      xs = xs.tail;\n    }\n    return result;\n  }\n\n  return function (foldr, xs) {\n    return listToArray(foldr(curryCons)(emptyList)(xs));\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Array size ------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const length = function (xs) {\n  return xs.length;\n};\n\n//------------------------------------------------------------------------------\n// Non-indexed reads -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unconsImpl = function (empty, next, xs) {\n  return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));\n};\n\n//------------------------------------------------------------------------------\n// Indexed operations ----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const indexImpl = function (just, nothing, xs, i) {\n  return i < 0 || i >= xs.length ? nothing :  just(xs[i]);\n};\n\nexport const findMapImpl = function (nothing, isJust, f, xs) {\n  for (var i = 0; i < xs.length; i++) {\n    var result = f(xs[i]);\n    if (isJust(result)) return result;\n  }\n  return nothing;\n};\n\nexport const findIndexImpl = function (just, nothing, f, xs) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const findLastIndexImpl = function (just, nothing, f, xs) {\n  for (var i = xs.length - 1; i >= 0; i--) {\n    if (f(xs[i])) return just(i);\n  }\n  return nothing;\n};\n\nexport const _insertAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i > l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 0, a);\n  return just(l1);\n};\n\nexport const _deleteAt = function (just, nothing, i, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1.splice(i, 1);\n  return just(l1);\n};\n\nexport const _updateAt = function (just, nothing, i, a, l) {\n  if (i < 0 || i >= l.length) return nothing;\n  var l1 = l.slice();\n  l1[i] = a;\n  return just(l1);\n};\n\n//------------------------------------------------------------------------------\n// Transformations -------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const reverse = function (l) {\n  return l.slice().reverse();\n};\n\nexport const concat = function (xss) {\n  if (xss.length <= 10000) {\n    // This method is faster, but it crashes on big arrays.\n    // So we use it when can and fallback to simple variant otherwise.\n    return Array.prototype.concat.apply([], xss);\n  }\n\n  var result = [];\n  for (var i = 0, l = xss.length; i < l; i++) {\n    var xs = xss[i];\n    for (var j = 0, m = xs.length; j < m; j++) {\n      result.push(xs[j]);\n    }\n  }\n  return result;\n};\n\nexport const filterImpl = function (f, xs) {\n  return xs.filter(f);\n};\n\nexport const partitionImpl = function (f, xs) {\n  var yes = [];\n  var no  = [];\n  for (var i = 0; i < xs.length; i++) {\n    var x = xs[i];\n    if (f(x))\n      yes.push(x);\n    else\n      no.push(x);\n  }\n  return { yes: yes, no: no };\n};\n\nexport const scanlImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) {\n    acc = f(acc)(xs[i]);\n    out[i] = acc;\n  }\n  return out;\n};\n\nexport const scanrImpl = function (f, b, xs) {\n  var len = xs.length;\n  var acc = b;\n  var out = new Array(len);\n  for (var i = len - 1; i >= 0; i--) {\n    acc = f(xs[i])(acc);\n    out[i] = acc;\n  }\n  return out;\n};\n\n//------------------------------------------------------------------------------\n// Sorting ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare, fromOrdering, xs) {\n    var out;\n\n    if (xs.length < 2) return xs;\n\n    out = xs.slice(0);\n    mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);\n\n    return out;\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Subarrays -------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const sliceImpl = function (s, e, l) {\n  return l.slice(s, e);\n};\n\n//------------------------------------------------------------------------------\n// Zipping ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const zipWithImpl = function (f, xs, ys) {\n  var l = xs.length < ys.length ? xs.length : ys.length;\n  var result = new Array(l);\n  for (var i = 0; i < l; i++) {\n    result[i] = f(xs[i])(ys[i]);\n  }\n  return result;\n};\n\n//------------------------------------------------------------------------------\n// Folding ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const anyImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (p(xs[i])) return true;\n  }\n  return false;\n};\n\nexport const allImpl = function (p, xs) {\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    if (!p(xs[i])) return false;\n  }\n  return true;\n};\n\n//------------------------------------------------------------------------------\n// Partial ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexport const unsafeIndexImpl = function (xs, n) {\n  return xs[n];\n};\n", "// module Data.Function.Uncurried\n\nexport const mkFn0 = function (fn) {\n  return function () {\n    return fn();\n  };\n};\n\nexport const mkFn2 = function (fn) {\n  /* jshint maxparams: 2 */\n  return function (a, b) {\n    return fn(a)(b);\n  };\n};\n\nexport const mkFn3 = function (fn) {\n  /* jshint maxparams: 3 */\n  return function (a, b, c) {\n    return fn(a)(b)(c);\n  };\n};\n\nexport const mkFn4 = function (fn) {\n  /* jshint maxparams: 4 */\n  return function (a, b, c, d) {\n    return fn(a)(b)(c)(d);\n  };\n};\n\nexport const mkFn5 = function (fn) {\n  /* jshint maxparams: 5 */\n  return function (a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e);\n  };\n};\n\nexport const mkFn6 = function (fn) {\n  /* jshint maxparams: 6 */\n  return function (a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f);\n  };\n};\n\nexport const mkFn7 = function (fn) {\n  /* jshint maxparams: 7 */\n  return function (a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g);\n  };\n};\n\nexport const mkFn8 = function (fn) {\n  /* jshint maxparams: 8 */\n  return function (a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h);\n  };\n};\n\nexport const mkFn9 = function (fn) {\n  /* jshint maxparams: 9 */\n  return function (a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i);\n  };\n};\n\nexport const mkFn10 = function (fn) {\n  /* jshint maxparams: 10 */\n  return function (a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j);\n  };\n};\n\nexport const runFn0 = function (fn) {\n  return fn();\n};\n\nexport const runFn2 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return fn(a, b);\n    };\n  };\n};\n\nexport const runFn3 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return fn(a, b, c);\n      };\n    };\n  };\n};\n\nexport const runFn4 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return fn(a, b, c, d);\n        };\n      };\n    };\n  };\n};\n\nexport const runFn5 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return fn(a, b, c, d, e);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn6 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return fn(a, b, c, d, e, f);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn7 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return fn(a, b, c, d, e, f, g);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn8 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return fn(a, b, c, d, e, f, g, h);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn9 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return fn(a, b, c, d, e, f, g, h, i);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runFn10 = function (fn) {\n  return function (a) {\n    return function (b) {\n      return function (c) {\n        return function (d) {\n          return function (e) {\n            return function (f) {\n              return function (g) {\n                return function (h) {\n                  return function (i) {\n                    return function (j) {\n                      return fn(a, b, c, d, e, f, g, h, i, j);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n", "export const fromNumberImpl = function (just) {\n  return function (nothing) {\n    return function (n) {\n      /* jshint bitwise: false */\n      return (n | 0) === n ? just(n) : nothing;\n    };\n  };\n};\n\nexport const toNumber = function (n) {\n  return n;\n};\n\nexport const fromStringAsImpl = function (just) {\n  return function (nothing) {\n    return function (radix) {\n      var digits;\n      if (radix < 11) {\n        digits = \"[0-\" + (radix - 1).toString() + \"]\";\n      } else if (radix === 11) {\n        digits = \"[0-9a]\";\n      } else {\n        digits = \"[0-9a-\" + String.fromCharCode(86 + radix) + \"]\";\n      }\n      var pattern = new RegExp(\"^[\\\\+\\\\-]?\" + digits + \"+$\", \"i\");\n\n      return function (s) {\n        /* jshint bitwise: false */\n        if (pattern.test(s)) {\n          var i = parseInt(s, radix);\n          return (i | 0) === i ? just(i) : nothing;\n        } else {\n          return nothing;\n        }\n      };\n    };\n  };\n};\n\nexport const toStringAs = function (radix) {\n  return function (i) {\n    return i.toString(radix);\n  };\n};\n\n\nexport const quot = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x / y | 0;\n  };\n};\n\nexport const rem = function (x) {\n  return function (y) {\n    return x % y;\n  };\n};\n\nexport const pow = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return Math.pow(x,y) | 0;\n  };\n};\n", "/* globals exports */\nexport const nan = NaN;\nconst isNaNImpl = isNaN;\nexport { isNaNImpl as isNaN };\nexport const infinity = Infinity;\nconst isFiniteImpl = isFinite;\nexport { isFiniteImpl as isFinite };\n\nexport function fromStringImpl(str, isFinite, just, nothing) {\n  var num = parseFloat(str);\n  if (isFinite(num)) {\n    return just(num);\n  } else {\n    return nothing;\n  }\n}\n\nexport const abs = Math.abs;\n\nexport const acos = Math.acos;\n\nexport const asin = Math.asin;\n\nexport const atan = Math.atan;\n\nexport const atan2 = function (y) {\n  return function (x) {\n    return Math.atan2(y, x);\n  };\n};\n\nexport const ceil = Math.ceil;\n\nexport const cos = Math.cos;\n\nexport const exp = Math.exp;\n\nexport const floor = Math.floor;\n\nexport const log = Math.log;\n\nexport const max = function (n1) {\n  return function (n2) {\n    return Math.max(n1, n2);\n  };\n};\n\nexport const min = function (n1) {\n  return function (n2) {\n    return Math.min(n1, n2);\n  };\n};\n\nexport const pow = function (n) {\n  return function (p) {\n    return Math.pow(n, p);\n  };\n};\n\nexport const remainder = function (n) {\n  return function (m) {\n    return n % m;\n  };\n};\n\nexport const round = Math.round;\n\nexport const sign = Math.sign ? Math.sign : function(x) {\n  return x === 0 || x !== x ? x : (x < 0 ? -1 : 1);\n};\n\nexport const sin = Math.sin;\n\nexport const sqrt = Math.sqrt;\n\nexport const tan = Math.tan;\n\nexport const trunc = Math.trunc ? Math.trunc : function(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n}\n", "/* global Symbol */\n\nvar hasArrayFrom = typeof Array.from === \"function\";\nvar hasStringIterator =\n  typeof Symbol !== \"undefined\" &&\n  Symbol != null &&\n  typeof Symbol.iterator !== \"undefined\" &&\n  typeof String.prototype[Symbol.iterator] === \"function\";\nvar hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\nvar hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n\nexport const _unsafeCodePointAt0 = function (fallback) {\n  return hasCodePointAt\n    ? function (str) { return str.codePointAt(0); }\n    : fallback;\n};\n\nexport const _codePointAt = function (fallback) {\n  return function (Just) {\n    return function (Nothing) {\n      return function (unsafeCodePointAt0) {\n        return function (index) {\n          return function (str) {\n            var length = str.length;\n            if (index < 0 || index >= length) return Nothing;\n            if (hasStringIterator) {\n              var iter = str[Symbol.iterator]();\n              for (var i = index;; --i) {\n                var o = iter.next();\n                if (o.done) return Nothing;\n                if (i === 0) return Just(unsafeCodePointAt0(o.value));\n              }\n            }\n            return fallback(index)(str);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const _countPrefix = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasStringIterator) {\n      return function (pred) {\n        return function (str) {\n          var iter = str[Symbol.iterator]();\n          for (var cpCount = 0; ; ++cpCount) {\n            var o = iter.next();\n            if (o.done) return cpCount;\n            var cp = unsafeCodePointAt0(o.value);\n            if (!pred(cp)) return cpCount;\n          }\n        };\n      };\n    }\n    return fallback;\n  };\n};\n\nexport const _fromCodePointArray = function (singleton) {\n  return hasFromCodePoint\n    ? function (cps) {\n      // Function.prototype.apply will fail for very large second parameters,\n      // so we don't use it for arrays with 10,000 or more entries.\n      if (cps.length < 10e3) {\n        return String.fromCodePoint.apply(String, cps);\n      }\n      return cps.map(singleton).join(\"\");\n    }\n    : function (cps) {\n      return cps.map(singleton).join(\"\");\n    };\n};\n\nexport const _singleton = function (fallback) {\n  return hasFromCodePoint ? String.fromCodePoint : fallback;\n};\n\nexport const _take = function (fallback) {\n  return function (n) {\n    if (hasStringIterator) {\n      return function (str) {\n        var accum = \"\";\n        var iter = str[Symbol.iterator]();\n        for (var i = 0; i < n; ++i) {\n          var o = iter.next();\n          if (o.done) return accum;\n          accum += o.value;\n        }\n        return accum;\n      };\n    }\n    return fallback(n);\n  };\n};\n\nexport const _toCodePointArray = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasArrayFrom) {\n      return function (str) {\n        return Array.from(str, unsafeCodePointAt0);\n      };\n    }\n    return fallback;\n  };\n};\n", "module Control.Alternative\n  ( class Alternative\n  , guard\n  , module Control.Alt\n  , module Control.Applicative\n  , module Control.Apply\n  , module Control.Plus\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\nimport Control.Applicative (class Applicative, pure, liftA1, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Plus (class Plus, empty)\n\nimport Data.Unit (Unit, unit)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Alternative` type class has no members of its own; it just specifies\n-- | that the type constructor has both `Applicative` and `Plus` instances.\n-- |\n-- | Types which have `Alternative` instances should also satisfy the following\n-- | laws:\n-- |\n-- | - Distributivity: `(f <|> g) <*> x == (f <*> x) <|> (g <*> x)`\n-- | - Annihilation: `empty <*> f = empty`\nclass (Applicative f, Plus f) <= Alternative f\n\ninstance alternativeArray :: Alternative Array\n\n-- | Fail using `Plus` if a condition does not hold, or\n-- | succeed using `Applicative` if it does.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Prelude\n-- | import Control.Alternative (guard)\n-- | import Data.Array ((..))\n-- |\n-- | factors :: Int -> Array Int\n-- | factors n = do\n-- |   a <- 1..n\n-- |   b <- 1..n\n-- |   guard $ a * b == n\n-- |   pure a\n-- | ```\nguard :: forall m. Alternative m => Boolean -> m Unit\nguard true = pure unit\nguard false = empty\n", "module Data.Profunctor.Strong where\n\nimport Prelude\n\nimport Data.Profunctor (class Profunctor, lcmap)\nimport Data.Tuple (Tuple(..))\n\n-- | The `Strong` class extends `Profunctor` with combinators for working with\n-- | product types.\n-- |\n-- | `first` and `second` lift values in a `Profunctor` to act on the first and\n-- | second components of a `Tuple`, respectively.\n-- |\n-- | Another way to think about Strong is to piggyback on the intuition of\n-- | inputs and outputs.  Rewriting the type signature in this light then yields:\n-- | ```\n-- | first ::  forall input output a. p input output -> p (Tuple input a) (Tuple output a)\n-- | second :: forall input output a. p input output -> p (Tuple a input) (Tuple a output)\n-- | ```\n-- | If we specialize the profunctor p to the function arrow, we get the following type\n-- | signatures, which may look a bit more familiar:\n-- | ```\n-- | first ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)\n-- | second :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)\n-- | ```\n-- | So, when the `profunctor` is `Function` application, `first` essentially applies your function\n-- | to the first element of a `Tuple`, and `second` applies it to the second element (same as `map` would do).\nclass Profunctor p <= Strong p where\n  first :: forall a b c. p a b -> p (Tuple a c) (Tuple b c)\n  second :: forall a b c. p b c -> p (Tuple a b) (Tuple a c)\n\ninstance strongFn :: Strong (->) where\n  first a2b (Tuple a c) = Tuple (a2b a) c\n  second = (<$>)\n\n-- | Compose a value acting on a `Tuple` from two values, each acting on one of\n-- | the components of the `Tuple`.\n-- |\n-- | Specializing `(***)` to function application would look like this:\n-- | ```\n-- | (***) :: forall a b c d. (a -> b) -> (c -> d) -> (Tuple a c) -> (Tuple b d)\n-- | ```\n-- | We take two functions, `f` and `g`, and we transform them into a single function which\n-- | takes a `Tuple` and maps `f` over the first element and `g` over the second.  Just like `bi-map`\n-- | would do for the `bi-functor` instance of `Tuple`.\nsplitStrong\n  :: forall p a b c d\n   . Semigroupoid p\n  => Strong p\n  => p a b\n  -> p c d\n  -> p (Tuple a c) (Tuple b d)\nsplitStrong l r = first l >>> second r\n\ninfixr 3 splitStrong as ***\n\n-- | Compose a value which introduces a `Tuple` from two values, each introducing\n-- | one side of the `Tuple`.\n-- |\n-- | This combinator is useful when assembling values from smaller components,\n-- | because it provides a way to support two different types of output.\n-- |\n-- | Specializing `(&&&)` to function application would look like this:\n-- | ```\n-- | (&&&) :: forall a b c. (a -> b) -> (a -> c) -> (a -> (Tuple b c))\n-- | ```\n-- | We take two functions, `f` and `g`, with the same parameter type and we transform them into a\n-- | single function which takes one parameter and returns a `Tuple` of the results of running\n-- | `f` and `g` on the parameter, respectively.  This allows us to run two parallel computations\n-- | on the same input and return both results in a `Tuple`.\nfanout\n  :: forall p a b c\n   . Semigroupoid p\n  => Strong p\n  => p a b\n  -> p a c\n  -> p a (Tuple b c)\nfanout l r = lcmap (\\a -> Tuple a a) (l *** r)\n\ninfixr 3 fanout as &&&\n", "-- | A bunch of type classes representing common values shared between multiple\n-- | CSS properties, like `Auto`, `Inherit`, `None`, `Normal` and several more.\n-- |\n-- | All the common value type classes have an instance for the `Value` type,\n-- | making them easily derivable for custom value types.\n\nmodule CSS.Common where\n\nimport Prelude\nimport Data.Tuple (Tuple(..))\n\nimport CSS.Property (Prefixed(..), Value)\nimport CSS.String (class IsString, fromString)\n\nclass All a where\n  all :: a\n\nclass Auto a where\n  auto :: a\n\nclass Baseline a where\n  baseline :: a\n\nclass Center a where\n  center :: a\n\nclass Inherit a where\n  inherit :: a\n\nclass None a where\n  none :: a\n\nclass Normal a where\n  normal :: a\n\nclass Visible a where\n  visible :: a\n\nclass Hidden a where\n  hidden :: a\n\nclass Initial a where\n  initial :: a\n\nclass Unset a where\n  unset :: a\n\nclass Top a where\n  top :: a\n\nclass Middle a where\n  middle :: a\n\nclass Bottom a where\n  bottom :: a\n\nclass URL a where\n  url :: String -> a\n\n-- | The other type class is used to escape from the type safety introduced by\n-- | embedding CSS properties into the typed world of purescript-css.\n-- | `Other` allows you to cast any `Value` to a specific value type.\nclass Other a where\n  other :: Value -> a\n\ninstance allValue :: All Value where\n  all = fromString \"all\"\n\ninstance autoValue :: Auto Value where\n  auto = fromString \"auto\"\n\ninstance baselineValue :: Baseline Value where\n  baseline = fromString \"baseline\"\n\ninstance centerValue :: Center Value where\n  center = fromString \"center\"\n\ninstance inheritValue :: Inherit Value where\n  inherit = fromString \"inherit\"\n\ninstance normalValue :: Normal Value where\n  normal = fromString \"normal\"\n\ninstance noneValue :: None Value where\n  none = fromString \"none\"\n\ninstance visibleValue :: Visible Value where\n  visible = fromString \"visible\"\n\ninstance hiddenValue :: Hidden Value where\n  hidden = fromString \"hidden\"\n\ninstance otherValue :: Other Value where\n  other = identity\n\ninstance initialValue :: Initial Value where\n  initial = fromString \"initial\"\n\ninstance unsetValue :: Unset Value where\n  unset = fromString \"unset\"\n\ninstance topValue :: Top Value where\n  top = fromString \"top\"\n\ninstance middleValue :: Middle Value where\n  middle = fromString \"middle\"\n\ninstance bottomValue :: Bottom Value where\n  bottom = fromString \"bottom\"\n\ninstance urlValue :: URL Value where\n  url s = fromString (\"url(\\\"\" <> s <> \"\\\")\")\n\n-- | Common list browser prefixes to make\n-- | experimental properties work in different browsers.\nbrowsers :: Prefixed\nbrowsers = Prefixed\n  [ Tuple \"-webkit-\" \"\"\n  , Tuple \"-moz-\" \"\"\n  , Tuple \"-ms-\" \"\"\n  , Tuple \"-o-\" \"\"\n  , Tuple \"\" \"\"\n  ]\n\n-- | Syntax for CSS function call.\ncall :: forall s. IsString s => Monoid s => s -> s -> s\ncall fn arg = fn <> fromString \"(\" <> arg <> fromString \")\"\n", "module Data.Exists where\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | This type constructor can be used to existentially quantify over a type.\n-- |\n-- | Specifically, the type `Exists f` is isomorphic to the existential type `exists a. f a`.\n-- |\n-- | Existential types can be encoded using universal types (`forall`) for endofunctors in more general\n-- | categories. The benefit of this library is that, by using the FFI, we can create an efficient\n-- | representation of the existential by simply hiding type information.\n-- |\n-- | For example, consider the type `exists s. Tuple s (s -> Tuple s a)` which represents infinite streams\n-- | of elements of type `a`.\n-- |\n-- | This type can be constructed by creating a type constructor `StreamF` as follows:\n-- |\n-- | ```purescript\n-- | data StreamF a s = StreamF s (s -> Tuple s a)\n-- | ```\n-- |\n-- | We can then define the type of streams using `Exists`:\n-- |\n-- | ```purescript\n-- | type Stream a = Exists (StreamF a)\n-- | ```\nforeign import data Exists :: forall k. (k -> Type) -> Type\n\ntype role Exists representational\n\n-- | The `mkExists` function is used to introduce a value of type `Exists f`, by providing a value of\n-- | type `f a`, for some type `a` which will be hidden in the existentially-quantified type.\n-- |\n-- | For example, to create a value of type `Stream Number`, we might use `mkExists` as follows:\n-- |\n-- | ```purescript\n-- | nats :: Stream Number\n-- | nats = mkExists $ StreamF 0 (\\n -> Tuple (n + 1) n)\n-- | ```\nmkExists :: forall f a. f a -> Exists f\nmkExists = unsafeCoerce\n\n-- | The `runExists` function is used to eliminate a value of type `Exists f`. The rank 2 type ensures\n-- | that the existentially-quantified type does not escape its scope. Since the function is required\n-- | to work for _any_ type `a`, it will work for the existentially-quantified type.\n-- |\n-- | For example, we can write a function to obtain the head of a stream by using `runExists` as follows:\n-- |\n-- | ```purescript\n-- | head :: forall a. Stream a -> a\n-- | head = runExists head'\n-- |   where\n-- |   head' :: forall s. StreamF a s -> a\n-- |   head' (StreamF s f) = snd (f s)\n-- | ```\nrunExists :: forall f r. (forall a. f a -> r) -> Exists f -> r\nrunExists = unsafeCoerce\n", "module Data.These where\n\nimport Prelude\n\nimport Control.Extend (class Extend)\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Bitraversable (class Bitraversable, class Bifoldable, bitraverse)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Maybe (Maybe(..), isJust)\nimport Data.Traversable (class Traversable, class Foldable, foldMap, foldl, foldr)\nimport Data.Tuple (Tuple(..))\n\n-- | Data type isomorphic to `\u03B1 \u2228 \u03B2 \u2228 (\u03B1 \u2227 \u03B2)` or\n-- | `Either a (Either b (Tuple a b))`.\ndata These a b\n  = This a\n  | That b\n  | Both a b\n\nderive instance eqThese :: (Eq a, Eq b) => Eq (These a b)\nderive instance ordThese :: (Ord a, Ord b) => Ord (These a b)\n\ninstance semigroupThese :: (Semigroup a, Semigroup b) => Semigroup (These a b) where\n  append (This a) (This b) = This (a <> b)\n  append (This a) (That y) = Both a y\n  append (This a) (Both b y) = Both (a <> b) y\n  append (That x) (This b) = Both b x\n  append (That x) (That y) = That (x <> y)\n  append (That x) (Both b y) = Both b (x <> y)\n  append (Both a x) (This b) = Both (a <> b) x\n  append (Both a x) (That y) = Both a (x <> y)\n  append (Both a x) (Both b y) = Both (a <> b) (x <> y)\n\ninstance functorThese :: Functor (These a) where\n  map f (Both a b) = Both a (f b)\n  map f (That a) = That (f a)\n  map _ (This a) = This a\n\ninstance invariantThese :: Invariant (These a) where\n  imap = imapF\n\ninstance foldableThese :: Foldable (These a) where\n  foldr f z = foldr f z <<< theseRight\n  foldl f z = foldl f z <<< theseRight\n  foldMap f = foldMap f <<< theseRight\n\ninstance traversableThese :: Traversable (These a) where\n  traverse _ (This a) = pure $ This a\n  traverse f (That x) = That <$> f x\n  traverse f (Both a x) = Both a <$> f x\n  sequence (This a) = pure $ This a\n  sequence (That x) = That <$> x\n  sequence (Both a x) = Both a <$> x\n\ninstance bifunctorThese :: Bifunctor These where\n  bimap f _ (This a) = This (f a)\n  bimap _ g (That x) = That (g x)\n  bimap f g (Both a x) = Both (f a) (g x)\n\ninstance bifoldableThese :: Bifoldable These where\n  bifoldr f g z = these (_ `f` z) (_ `g` z) (\\x y -> x `f` (y `g` z))\n  bifoldl f g z = these (z `f` _) (z `g` _) (\\x y -> (z `f` x) `g` y)\n  bifoldMap f g = these f g (\\x y -> f x <> g y)\n\ninstance bitraversableThese :: Bitraversable These where\n  bitraverse f _ (This a) = This <$> f a\n  bitraverse _ g (That x) = That <$> g x\n  bitraverse f g (Both a x) = Both <$> f a <*> g x\n  bisequence = bitraverse identity identity\n\ninstance applyThese :: Semigroup a => Apply (These a) where\n  apply (This a) _ = This a\n  apply (That _) (This b) = This b\n  apply (That f) (That x) = That (f x)\n  apply (That f) (Both b x) = Both b (f x)\n  apply (Both a _) (This b) = This (a <> b)\n  apply (Both a f) (That x) = Both a (f x)\n  apply (Both a f) (Both b x) = Both (a <> b) (f x)\n\ninstance applicativeThese :: Semigroup a => Applicative (These a) where\n  pure = That\n\ninstance bindThese :: Semigroup a => Bind (These a) where\n  bind (This a) _ = This a\n  bind (That x) k = k x\n  bind (Both a x) k =\n    case k x of\n      This b -> This (a <> b)\n      That y -> Both a y\n      Both b y -> Both (a <> b) y\n\ninstance monadThese :: Semigroup a => Monad (These a)\n\ninstance extendEither :: Extend (These a) where\n  extend _ (This a) = This a\n  extend f x = map (const (f x)) x\n\ninstance showThese :: (Show a, Show b) => Show (These a b) where\n  show (This x) = \"(This \" <> show x <> \")\"\n  show (That y) = \"(That \" <> show y <> \")\"\n  show (Both x y) = \"(Both \" <> show x <> \" \" <> show y <> \")\"\n\n-- | Given functions to handle each constructor, collapse a `These` value\n-- | into single value.\nthese :: forall a b c. (a -> c) -> (b -> c) -> (a -> b -> c) -> These a b -> c\nthese l _ _ (This a) = l a\nthese _ r _ (That x) = r x\nthese _ _ lr (Both a x) = lr a x\n\nthisOrBoth :: forall a b. a -> Maybe b -> These a b\nthisOrBoth a Nothing = This a\nthisOrBoth a (Just b) = Both a b\n\nthatOrBoth :: forall a b. b -> Maybe a -> These a b\nthatOrBoth b Nothing = That b\nthatOrBoth b (Just a) = Both a b\n\n-- | Takes a pair of `Maybe`s and attempts to create a `These` from them.\nmaybeThese :: forall a b. Maybe a -> Maybe b -> Maybe (These a b)\nmaybeThese = case _, _ of\n  Just a, Nothing -> Just (This a)\n  Nothing, Just b -> Just (That b)\n  Just a, Just b -> Just (Both a b)\n  Nothing, Nothing -> Nothing\n\n-- | Takes two default values and a `These` value. If the `These` value is\n-- | `This` or `That`, the value wrapped in the `These` value and its\n-- | corresponding default value are wrapped into a `Tuple`.\n-- | Otherwise, the values stored in the `Both` are rewrapped into a `Tuple`.\nfromThese :: forall a b. a -> b -> These a b -> Tuple a b\nfromThese _ x (This a) = Tuple a x\nfromThese a _ (That x) = Tuple a x\nfromThese _ _ (Both a x) = Tuple a x\n\n-- | Returns an `a` value if possible.\ntheseLeft :: forall a b. These a b -> Maybe a\ntheseLeft (Both x _) = Just x\ntheseLeft (This x) = Just x\ntheseLeft _ = Nothing\n\n-- | Returns a `b` value if possible.\ntheseRight :: forall a b. These a b -> Maybe b\ntheseRight (Both _ x) = Just x\ntheseRight (That x) = Just x\ntheseRight _ = Nothing\n\n-- | Returns the `a` value if and only if the value is constructed with `This`.\nthis :: forall a b. These a b -> Maybe a\nthis = case _ of\n  This x -> Just x\n  _ -> Nothing\n\n-- | Returns the `b` value if and only if the value is constructed with `That`.\nthat :: forall a b. These a b -> Maybe b\nthat = case _ of\n  That x -> Just x\n  _ -> Nothing\n\n-- | Returns the `a` and `b` values if and only if they are constructed\n-- | with `Both`.\nboth :: forall a b. These a b -> Maybe (Tuple a b)\nboth = case _ of\n  Both a x -> Just (Tuple a x)\n  _ -> Nothing\n\n-- | Returns `true` when the `These` value is `This`\nisThis :: forall a b. These a b -> Boolean\nisThis = isJust <<< this\n\n-- | Returns `true` when the `These` value is `That`\nisThat :: forall a b. These a b -> Boolean\nisThat = isJust <<< that\n\n-- | Returns `true` when the `These` value is `Both`\nisBoth :: forall a b. These a b -> Boolean\nisBoth = isJust <<< both\n\n-- | Swap between `This` and `That`, and flips the order for `Both`.\nswap :: forall a b. These a b -> These b a\nswap = these That This (flip Both)\n\n-- | Re-associate `These` from left to right.\nassoc :: forall a b c. These (These a b) c -> These a (These b c)\nassoc = case _ of\n  This (This a) -> This a\n  This (That b) -> That (This b)\n  This (Both a b) -> Both a (This b)\n  That c -> That (That c)\n  Both (This a) c -> Both a (That c)\n  Both (That b) c -> That (Both b c)\n  Both (Both a b) c -> Both a (Both b c)\n\n", "export const log = function (s) {\n  return function () {\n    console.log(s);\n  };\n};\n\nexport const warn = function (s) {\n  return function () {\n    console.warn(s);\n  };\n};\n\nexport const error = function (s) {\n  return function () {\n    console.error(s);\n  };\n};\n\nexport const info = function (s) {\n  return function () {\n    console.info(s);\n  };\n};\n\nexport const debug = function (s) {\n  return function () {\n    console.debug(s);\n  };\n};\n\nexport const time = function (s) {\n  return function () {\n    console.time(s);\n  };\n};\n\nexport const timeLog = function (s) {\n  return function () {\n    console.timeLog(s);\n  };\n};\n\nexport const timeEnd = function (s) {\n  return function () {\n    console.timeEnd(s);\n  };\n};\n\nexport const clear = function () {\n  console.clear();\n};\n\nexport const group = function (s) {\n  return function () {\n    console.group(s);\n  };\n};\n\nexport const groupCollapsed = function (s) {\n  return function () {\n    console.groupCollapsed(s);\n  };\n};\n\nexport const groupEnd = function () {\n  console.groupEnd();\n};\n", "-- | AspectRatio can be used with a width or height to specify a `Size` in the\n-- | `Dimensions` module. For example, if you want to target 16:9 screens but\n-- | use 360 vertical units in your coordinate system (which divides evenly\n-- | into 720 and 1080), you could specify your `Size` as 640 wide by 360 high\n-- | or as 360 high with 16:9 ratio.\nmodule Gesso.AspectRatio\n  ( AspectRatio\n  , toNumber\n  , width\n  , height\n  , custom\n  , w16h9\n  , w16h10\n  , w2h1\n  , w4h3\n  , w1h1\n  ) where\n\nimport Prelude\n\n-- | The `AspectRatio` type follows the normal convention of width:height,\n-- | so `AspectRatio 16.0 9.0` is 16:9.\ndata AspectRatio = AspectRatio Number Number\n\ninstance showAspectRatio :: Show AspectRatio where\n  show = show <<< toNumber\n\nderive instance eqAspectRatio :: Eq AspectRatio\n\n-- | Convert an `AspectRatio` to a single number suitable for scaling another\n-- | number.\ntoNumber :: AspectRatio -> Number\ntoNumber (AspectRatio w h) = w / h\n\n-- | Get the width given a height and aspect ratio\nwidth :: Number -> AspectRatio -> Number\nwidth forHeight (AspectRatio w h) = forHeight * w / h\n\n-- | Get the height given a width and aspect ratio\nheight :: Number -> AspectRatio -> Number\nheight forWidth (AspectRatio w h) = forWidth * h / w\n\n-- | Although several common ratios are provided, sometimes an arbitrary ratio\n-- | is needed. `custom` creates an `AspectRatio` from any width and height.\n-- |\n-- | w16h9 = AspectRatio.custom 16.0 9.0\ncustom :: Number -> Number -> AspectRatio\ncustom w h = AspectRatio w h\n\n-- | 16:9, for example, high-definition television, 720p, 1080p, 4K, etc.\nw16h9 :: AspectRatio\nw16h9 = custom 16.0 9.0\n\nw16h10 :: AspectRatio\nw16h10 = custom 16.0 10.0\n\n-- | 2:1, between cinema (2.39:1) and 16:9. For example, some TV shows and\n-- | phones.\nw2h1 :: AspectRatio\nw2h1 = custom 2.0 1.0\n\n-- | 4:3, for example, standard-definition televsion and 1024x768 monitors.\nw4h3 :: AspectRatio\nw4h3 = custom 4.0 3.0\n\n-- | 1:1 - square - equal width and height.\nw1h1 :: AspectRatio\nw1h1 = custom 1.0 1.0\n", "module Halogen.Query.Input where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Newtype (class Newtype)\nimport Web.DOM (Element)\n\nnewtype RefLabel = RefLabel String\n\nderive instance newtypeRefLabel :: Newtype RefLabel _\nderive newtype instance eqRefLabel :: Eq RefLabel\nderive newtype instance ordRefLabel :: Ord RefLabel\n\ndata Input action\n  = RefUpdate RefLabel (Maybe Element)\n  | Action action\n\nderive instance functorInput :: Functor Input\n", "/* eslint-disable no-eq-null, eqeqeq */\n\nconst nullImpl = null;\nexport { nullImpl as null };\n\nexport function nullable(a, r, f) {\n  return a == null ? r : f(a);\n}\n\nexport function notNull(x) {\n  return x;\n}\n", "-- | This module defines types and functions for working with nullable types\n-- | using the FFI.\n\nmodule Data.Nullable\n  ( Nullable\n  , null\n  , notNull\n  , toMaybe\n  , toNullable\n  ) where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Function (on)\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Ord (class Ord1)\n\n-- | A nullable type. This type constructor is intended to be used for\n-- | interoperating with JavaScript functions which accept or return null\n-- | values.\n-- |\n-- | The runtime representation of `Nullable T` is the same as that of `T`,\n-- | except that it may also be `null`. For example, the JavaScript values\n-- | `null`, `[]`, and `[1,2,3]` may all be given the type\n-- | `Nullable (Array Int)`. Similarly, the JavaScript values `[]`, `[null]`,\n-- | and `[1,2,null,3]` may all be given the type `Array (Nullable Int)`.\n-- |\n-- | There is one pitfall with `Nullable`, which is that values of the type\n-- | `Nullable T` will not function as you might expect if the type `T` happens\n-- | to itself permit `null` as a valid runtime representation.\n-- |\n-- | In particular, values of the type `Nullable (Nullable T)` will \u2018collapse\u2019,\n-- | in the sense that the PureScript expressions `notNull null` and `null`\n-- | will both leave you with a value whose runtime representation is just\n-- | `null`. Therefore it is important to avoid using `Nullable T` in\n-- | situations where `T` itself can take `null` as a runtime representation.\n-- | If in doubt, use `Maybe` instead.\n-- |\n-- | `Nullable` does not permit lawful `Functor`, `Applicative`, or `Monad`\n-- | instances as a result of this pitfall, which is why these instances are\n-- | not provided.\nforeign import data Nullable :: Type -> Type\n\ntype role Nullable representational\n\n-- | The null value.\nforeign import null :: forall a. Nullable a\n\nforeign import nullable :: forall a r. Fn3 (Nullable a) r (a -> r) r\n\n-- | Wrap a non-null value.\nforeign import notNull :: forall a. a -> Nullable a\n\n-- | Takes `Nothing` to `null`, and `Just a` to `a`.\ntoNullable :: forall a. Maybe a -> Nullable a\ntoNullable = maybe null notNull\n\n-- | Represent `null` using `Maybe a` as `Nothing`. Note that this function\n-- | can violate parametricity, as it inspects the runtime representation of\n-- | its argument (see the warning about the pitfall of `Nullable` above).\ntoMaybe :: forall a. Nullable a -> Maybe a\ntoMaybe n = runFn3 nullable n Nothing Just\n\ninstance showNullable :: Show a => Show (Nullable a) where\n  show = maybe \"null\" show <<< toMaybe\n\ninstance eqNullable :: Eq a => Eq (Nullable a) where\n  eq = eq `on` toMaybe\n\ninstance eq1Nullable :: Eq1 Nullable where\n  eq1 = eq\n\ninstance ordNullable :: Ord a => Ord (Nullable a) where\n  compare = compare `on` toMaybe\n\ninstance ord1Nullable :: Ord1 Nullable where\n  compare1 = compare\n", "module Halogen.VDom.Machine\n  ( Machine\n  , Step'(..)\n  , Step\n  , mkStep\n  , unStep\n  , extract\n  , step\n  , halt\n  ) where\n\nimport Prelude\n\nimport Effect.Uncurried (EffectFn1, EffectFn2, mkEffectFn1, mkEffectFn2, runEffectFn1, runEffectFn2)\nimport Unsafe.Coerce (unsafeCoerce)\n\ntype Machine a b = EffectFn1 a (Step a b)\n\ndata Step' a b s = Step b s (EffectFn2 s a (Step a b)) (EffectFn1 s Unit)\n\nforeign import data Step \u2237 Type \u2192 Type \u2192 Type\n\nmkStep \u2237 \u2200 a b s. Step' a b s \u2192 Step a b\nmkStep = unsafeCoerce\n\nunStep :: \u2200 a b r. (\u2200 s. Step' a b s \u2192 r) \u2192 Step a b \u2192 r\nunStep = unsafeCoerce\n\n-- | Returns the output value of a `Step`.\nextract \u2237 \u2200 a b. Step a b \u2192 b\nextract = unStep \\(Step x _ _ _) \u2192 x\n\n-- | Runs the next step.\nstep \u2237 \u2200 a b. EffectFn2 (Step a b) a (Step a b)\nstep = coerce $ mkEffectFn2 \\(Step _ s k _) a \u2192 runEffectFn2 k s a\n  where\n  coerce \u2237 \u2200 s. EffectFn2 (Step' a b s) a (Step a b) \u2192 EffectFn2 (Step a b) a (Step a b)\n  coerce = unsafeCoerce\n\n-- | Runs the finalizer associated with a `Step`\nhalt \u2237 \u2200 a b. EffectFn1 (Step a b) Unit\nhalt = coerce $ mkEffectFn1 \\(Step _ s _ k) \u2192 runEffectFn1 k s\n  where\n  coerce \u2237 \u2200 s. EffectFn1 (Step' a b s) Unit \u2192 EffectFn1 (Step a b) Unit\n  coerce = unsafeCoerce\n", "\"use strict\";\n\nexport function unsafeGetAny(key, obj) {\n  return obj[key];\n}\n\nexport function unsafeHasAny(key, obj) {\n  return obj.hasOwnProperty(key);\n}\n\nexport function unsafeSetAny(key, val, obj) {\n    obj[key] = val;\n}\n\nexport function unsafeDeleteAny(key, obj) {\n  delete obj[key];\n}\n\nexport function forE(a, f) {\n  var b = [];\n  for (var i = 0; i < a.length; i++) {\n    b.push(f(i, a[i]));\n  }\n  return b;\n}\n\nexport function forEachE(a, f) {\n  for (var i = 0; i < a.length; i++) {\n    f(a[i]);\n  }\n}\n\nexport function forInE(o, f) {\n  var ks = Object.keys(o);\n  for (var i = 0; i < ks.length; i++) {\n    var k = ks[i];\n    f(k, o[k]);\n  }\n}\n\nexport function replicateE(n, f) {\n  for (var i = 0; i < n; i++) {\n    f();\n  }\n}\n\nexport function diffWithIxE(a1, a2, f1, f2, f3) {\n  var a3 = [];\n  var l1 = a1.length;\n  var l2 = a2.length;\n  var i  = 0;\n  while (1) {\n    if (i < l1) {\n      if (i < l2) {\n        a3.push(f1(i, a1[i], a2[i]));\n      } else {\n        f2(i, a1[i]);\n      }\n    } else if (i < l2) {\n      a3.push(f3(i, a2[i]));\n    } else {\n      break;\n    }\n    i++;\n  }\n  return a3;\n}\n\nexport function strMapWithIxE(as, fk, f) {\n  var o = {};\n  for (var i = 0; i < as.length; i++) {\n    var a = as[i];\n    var k = fk(a);\n    o[k] = f(k, i, a);\n  }\n  return o;\n}\n\nexport function diffWithKeyAndIxE(o1, as, fk, f1, f2, f3) {\n  var o2 = {};\n  for (var i = 0; i < as.length; i++) {\n    var a = as[i];\n    var k = fk(a);\n    if (o1.hasOwnProperty(k)) {\n      o2[k] = f1(k, i, o1[k], a);\n    } else {\n      o2[k] = f3(k, i, a);\n    }\n  }\n  for (var k in o1) {\n    if (k in o2) {\n      continue;\n    }\n    f2(k, o1[k]);\n  }\n  return o2;\n}\n\nexport function refEq(a, b) {\n  return a === b;\n}\n\nexport function createTextNode(s, doc) {\n  return doc.createTextNode(s);\n}\n\nexport function setTextContent(s, n) {\n  n.textContent = s;\n}\n\nexport function createElement(ns, name, doc) {\n  if (ns != null) {\n    return doc.createElementNS(ns, name);\n  } else {\n    return doc.createElement(name)\n  }\n}\n\nexport function insertChildIx(i, a, b) {\n  var n = b.childNodes.item(i) || null;\n  if (n !== a) {\n    b.insertBefore(a, n);\n  }\n}\n\nexport function removeChild(a, b) {\n  if (b && a.parentNode === b) {\n    b.removeChild(a);\n  }\n}\n\nexport function parentNode(a) {\n  return a.parentNode;\n}\n\nexport function setAttribute(ns, attr, val, el) {\n  if (ns != null) {\n    el.setAttributeNS(ns, attr, val);\n  } else {\n    el.setAttribute(attr, val);\n  }\n}\n\nexport function removeAttribute(ns, attr, el) {\n  if (ns != null) {\n    el.removeAttributeNS(ns, attr);\n  } else {\n    el.removeAttribute(attr);\n  }\n}\n\nexport function hasAttribute(ns, attr, el) {\n  if (ns != null) {\n    return el.hasAttributeNS(ns, attr);\n  } else {\n    return el.hasAttribute(attr);\n  }\n}\n\nexport function addEventListener(ev, listener, el) {\n  el.addEventListener(ev, listener, false);\n}\n\nexport function removeEventListener(ev, listener, el) {\n  el.removeEventListener(ev, listener, false);\n}\n\nexport var jsUndefined = void 0;\n", "const newImpl = function () {\n  return {};\n};\nexport { newImpl as new };\n\nexport function peekImpl(just) {\n  return function (nothing) {\n    return function (k) {\n      return function (m) {\n        return function () {\n          return {}.hasOwnProperty.call(m, k) ? just(m[k]) : nothing;\n        };\n      };\n    };\n  };\n}\n\nexport function poke(k) {\n  return function (v) {\n    return function (m) {\n      return function () {\n        m[k] = v;\n        return m;\n      };\n    };\n  };\n}\n\nconst deleteImpl = function (k) {\n  return function (m) {\n    return function () {\n      delete m[k];\n      return m;\n    };\n  };\n};\nexport { deleteImpl as delete };\n", "module Halogen.VDom.Util\n  ( newMutMap\n  , pokeMutMap\n  , deleteMutMap\n  , unsafeFreeze\n  , unsafeLookup\n  , unsafeGetAny\n  , unsafeHasAny\n  , unsafeSetAny\n  , unsafeDeleteAny\n  , forE\n  , forEachE\n  , forInE\n  , replicateE\n  , diffWithIxE\n  , diffWithKeyAndIxE\n  , strMapWithIxE\n  , refEq\n  , createTextNode\n  , setTextContent\n  , createElement\n  , insertChildIx\n  , removeChild\n  , parentNode\n  , setAttribute\n  , removeAttribute\n  , hasAttribute\n  , addEventListener\n  , removeEventListener\n  , JsUndefined\n  , jsUndefined\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried as Fn\nimport Data.Nullable (Nullable)\nimport Effect (Effect)\nimport Effect.Uncurried as EFn\nimport Foreign.Object (Object)\nimport Foreign.Object as Object\nimport Foreign.Object.ST (STObject)\nimport Foreign.Object.ST as STObject\nimport Halogen.VDom.Types (Namespace, ElemName)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Document (Document) as DOM\nimport Web.DOM.Element (Element) as DOM\nimport Web.DOM.Node (Node) as DOM\nimport Web.Event.EventTarget (EventListener) as DOM\n\nnewMutMap \u2237 \u2200 r a. Effect (STObject r a)\nnewMutMap = unsafeCoerce STObject.new\n\npokeMutMap \u2237 \u2200 r a. EFn.EffectFn3 String a (STObject r a) Unit\npokeMutMap = unsafeSetAny\n\ndeleteMutMap \u2237 \u2200 r a. EFn.EffectFn2 String (STObject r a) Unit\ndeleteMutMap = unsafeDeleteAny\n\nunsafeFreeze \u2237 \u2200 r a. STObject r a \u2192 Object a\nunsafeFreeze = unsafeCoerce\n\nunsafeLookup \u2237 \u2200 a. Fn.Fn2 String (Object a) a\nunsafeLookup = unsafeGetAny\n\nforeign import unsafeGetAny\n  \u2237 \u2200 a b. Fn.Fn2 String a b\n\nforeign import unsafeHasAny\n  \u2237 \u2200 a. Fn.Fn2 String a Boolean\n\nforeign import unsafeSetAny \u2237 \u2200 a b. EFn.EffectFn3 String a b Unit\n\nforeign import unsafeDeleteAny\n  \u2237 \u2200 a. EFn.EffectFn2 String a Unit\n\nforeign import forE\n  \u2237 \u2200 a b\n  . EFn.EffectFn2\n      (Array a)\n      (EFn.EffectFn2 Int a b)\n      (Array b)\n\nforeign import forEachE\n  \u2237 \u2200 a\n  . EFn.EffectFn2\n      (Array a)\n      (EFn.EffectFn1 a Unit)\n      Unit\n\nforeign import forInE\n  \u2237 \u2200 a\n  . EFn.EffectFn2\n      (Object.Object a)\n      (EFn.EffectFn2 String a Unit)\n      Unit\n\nforeign import replicateE\n  \u2237 \u2200 a\n  . EFn.EffectFn2\n      Int\n      (Effect a)\n      Unit\n\nforeign import diffWithIxE\n  \u2237 \u2200 b c d\n  . EFn.EffectFn5\n      (Array b)\n      (Array c)\n      (EFn.EffectFn3 Int b c d)\n      (EFn.EffectFn2 Int b Unit)\n      (EFn.EffectFn2 Int c d)\n      (Array d)\n\nforeign import diffWithKeyAndIxE\n  \u2237 \u2200 a b c d\n  . EFn.EffectFn6\n      (Object.Object a)\n      (Array b)\n      (b \u2192 String)\n      (EFn.EffectFn4 String Int a b c)\n      (EFn.EffectFn2 String a d)\n      (EFn.EffectFn3 String Int b c)\n      (Object.Object c)\n\nforeign import strMapWithIxE\n  \u2237 \u2200 a b\n  . EFn.EffectFn3\n      (Array a)\n      (a \u2192 String)\n      (EFn.EffectFn3 String Int a b)\n      (Object.Object b)\n\nforeign import refEq\n  \u2237 \u2200 a b. Fn.Fn2 a b Boolean\n\nforeign import createTextNode\n  \u2237 EFn.EffectFn2 String DOM.Document DOM.Node\n\nforeign import setTextContent\n  \u2237 EFn.EffectFn2 String DOM.Node Unit\n\nforeign import createElement\n  \u2237 EFn.EffectFn3 (Nullable Namespace) ElemName DOM.Document DOM.Element\n\nforeign import insertChildIx\n  \u2237 EFn.EffectFn3 Int DOM.Node DOM.Node Unit\n\nforeign import removeChild\n  \u2237 EFn.EffectFn2 DOM.Node DOM.Node Unit\n\nforeign import parentNode\n  \u2237 EFn.EffectFn1 DOM.Node DOM.Node\n\nforeign import setAttribute\n  \u2237 EFn.EffectFn4 (Nullable Namespace) String String DOM.Element Unit\n\nforeign import removeAttribute\n  \u2237 EFn.EffectFn3 (Nullable Namespace) String DOM.Element Unit\n\nforeign import hasAttribute\n  \u2237 EFn.EffectFn3 (Nullable Namespace) String DOM.Element Boolean\n\nforeign import addEventListener\n  \u2237 EFn.EffectFn3 String DOM.EventListener DOM.Element Unit\n\nforeign import removeEventListener\n  \u2237 EFn.EffectFn3 String DOM.EventListener DOM.Element Unit\n\nforeign import data JsUndefined \u2237 Type\n\nforeign import jsUndefined \u2237 JsUndefined\n", "var getProp = function (name) {\n  return function (doctype) {\n    return doctype[name];\n  };\n};\n\nexport const _namespaceURI = getProp(\"namespaceURI\");\nexport const _prefix = getProp(\"prefix\");\nexport const localName = getProp(\"localName\");\nexport const tagName = getProp(\"tagName\");\n\nexport function id(node) {\n  return function () {\n    return node.id;\n  };\n}\n\nexport function setId(id) {\n  return function (node) {\n    return function () {\n      node.id = id;\n    };\n  };\n}\n\nexport function className(node) {\n  return function () {\n    return node.className;\n  };\n}\n\nexport function classList(element) {\n  return function () {\n    return element.classList;\n  };\n}\n\nexport function setClassName(className) {\n  return function (node) {\n    return function () {\n      node.className = className;\n    };\n  };\n}\n\nexport function getElementsByTagName(localName) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByTagName(localName);\n    };\n  };\n}\n\nexport function _getElementsByTagNameNS(ns) {\n  return function (localName) {\n    return function (doc) {\n      return function () {\n        return doc.getElementsByTagNameNS(ns, localName);\n      };\n    };\n  };\n}\n\nexport function getElementsByClassName(classNames) {\n  return function (doc) {\n    return function () {\n      return doc.getElementsByClassName(classNames);\n    };\n  };\n}\n\nexport function setAttribute(name) {\n  return function (value) {\n    return function (element) {\n      return function () {\n        element.setAttribute(name, value);\n      };\n    };\n  };\n}\n\nexport function _getAttribute(name) {\n  return function (element) {\n    return function () {\n      return element.getAttribute(name);\n    };\n  };\n}\n\nexport function hasAttribute(name) {\n  return function (element) {\n    return function () {\n      return element.hasAttribute(name);\n    };\n  };\n}\n\nexport function removeAttribute(name) {\n  return function (element) {\n    return function () {\n      element.removeAttribute(name);\n    };\n  };\n}\n\nexport function matches(selector) {\n  return function(element) {\n    return function () {\n      return element.matches(selector);\n    };\n  };\n}\n\nexport function _closest(selector) {\n  return function(element) {\n    return function () {\n      return element.closest(selector);\n    };\n  };\n}\n\n// - CSSOM ---------------------------------------------------------------------\n\nexport function scrollTop(node) {\n  return function () {\n    return node.scrollTop;\n  };\n}\n\nexport function setScrollTop(scrollTop) {\n  return function (node) {\n    return function () {\n      node.scrollTop = scrollTop;\n    };\n  };\n}\n\nexport function scrollLeft(node) {\n  return function () {\n    return node.scrollLeft;\n  };\n}\n\nexport function setScrollLeft(scrollLeft) {\n  return function (node) {\n    return function () {\n      node.scrollLeft = scrollLeft;\n    };\n  };\n}\n\nexport function scrollWidth(el) {\n  return function () {\n    return el.scrollWidth;\n  };\n}\n\nexport function scrollHeight(el) {\n  return function () {\n    return el.scrollHeight;\n  };\n}\n\nexport function clientTop(el) {\n  return function () {\n    return el.clientTop;\n  };\n}\n\nexport function clientLeft(el) {\n  return function () {\n    return el.clientLeft;\n  };\n}\n\nexport function clientWidth(el) {\n  return function () {\n    return el.clientWidth;\n  };\n}\n\nexport function clientHeight(el) {\n  return function () {\n    return el.clientHeight;\n  };\n}\n\nexport function getBoundingClientRect(el) {\n  return function () {\n    var rect = el.getBoundingClientRect();\n    return {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height,\n      x: rect.x,\n      y: rect.y\n    };\n  };\n}\n\nexport function _attachShadow(props) {\n  return function (el) {\n    return function() {\n      return el.attachShadow(props);\n    };\n  };\n}\n", "var getEffProp = function (name) {\n  return function (node) {\n    return function () {\n      return node[name];\n    };\n  };\n};\n\nexport const children = getEffProp(\"children\");\nexport const _firstElementChild = getEffProp(\"firstElementChild\");\nexport const _lastElementChild = getEffProp(\"lastElementChild\");\nexport const childElementCount = getEffProp(\"childElementCount\");\n\nexport function _querySelector(selector) {\n  return function (node) {\n    return function () {\n      return node.querySelector(selector);\n    };\n  };\n}\n\nexport function querySelectorAll(selector) {\n  return function (node) {\n    return function () {\n      return node.querySelectorAll(selector);\n    };\n  };\n}\n", "module Web.DOM.Element\n  ( module Exports\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , namespaceURI\n  , prefix\n  , localName\n  , tagName\n  , id\n  , setId\n  , className\n  , classList\n  , setClassName\n  , getElementsByTagName\n  , getElementsByTagNameNS\n  , getElementsByClassName\n  , setAttribute\n  , getAttribute\n  , hasAttribute\n  , removeAttribute\n  , matches\n  , closest\n  , scrollTop\n  , setScrollTop\n  , scrollLeft\n  , setScrollLeft\n  , scrollWidth\n  , scrollHeight\n  , clientTop\n  , clientLeft\n  , clientWidth\n  , clientHeight\n  , getBoundingClientRect\n  , DOMRect\n  , ShadowRootInit\n  , attachShadow\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe, toNullable)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.ChildNode (ChildNode)\nimport Web.DOM.DOMTokenList (DOMTokenList)\nimport Web.DOM.Internal.Types (Element) as Exports\nimport Web.DOM.Internal.Types (Element, HTMLCollection, Node)\nimport Web.DOM.NonDocumentTypeChildNode (NonDocumentTypeChildNode)\nimport Web.DOM.ParentNode (QuerySelector) as Exports\nimport Web.DOM.ParentNode (ParentNode, QuerySelector)\nimport Web.DOM.ShadowRoot (ShadowRoot, ShadowRootMode)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\n\nfromNode :: Node -> Maybe Element\nfromNode = unsafeReadProtoTagged \"Element\"\n\nfromChildNode :: ChildNode -> Maybe Element\nfromChildNode = unsafeReadProtoTagged \"Element\"\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe Element\nfromNonDocumentTypeChildNode = unsafeReadProtoTagged \"Element\"\n\nfromParentNode :: ParentNode -> Maybe Element\nfromParentNode = unsafeReadProtoTagged \"Element\"\n\nfromEventTarget :: EventTarget -> Maybe Element\nfromEventTarget = unsafeReadProtoTagged \"Element\"\n\ntoNode :: Element -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: Element -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: Element -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: Element -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: Element -> EventTarget\ntoEventTarget = unsafeCoerce\n\nnamespaceURI :: Element -> Maybe String\nnamespaceURI = toMaybe <<< _namespaceURI\n\nprefix :: Element -> Maybe String\nprefix = toMaybe <<< _prefix\n\nforeign import _namespaceURI :: Element -> Nullable String\nforeign import _prefix :: Element -> Nullable String\nforeign import localName :: Element -> String\nforeign import tagName :: Element -> String\n\nforeign import id :: Element -> Effect String\nforeign import setId :: String -> Element -> Effect Unit\nforeign import className :: Element -> Effect String\nforeign import classList :: Element -> Effect DOMTokenList\nforeign import setClassName :: String -> Element -> Effect Unit\n\nforeign import getElementsByTagName :: String -> Element -> Effect HTMLCollection\n\ngetElementsByTagNameNS :: Maybe String -> String -> Element -> Effect HTMLCollection\ngetElementsByTagNameNS = _getElementsByTagNameNS <<< toNullable\n\nforeign import _getElementsByTagNameNS :: Nullable String -> String -> Element -> Effect HTMLCollection\n\nforeign import getElementsByClassName :: String -> Element -> Effect HTMLCollection\n\nforeign import setAttribute :: String -> String -> Element -> Effect Unit\n\ngetAttribute :: String -> Element -> Effect (Maybe String)\ngetAttribute attr = map toMaybe <<< _getAttribute attr\n\nforeign import _getAttribute :: String -> Element -> Effect (Nullable String)\nforeign import hasAttribute :: String -> Element -> Effect Boolean\nforeign import removeAttribute :: String -> Element -> Effect Unit\n\nforeign import matches :: QuerySelector -> Element -> Effect Boolean\n\nclosest :: QuerySelector -> Element -> Effect (Maybe Element)\nclosest qs = map toMaybe <<< _closest qs\n\nforeign import _closest :: QuerySelector -> Element -> Effect (Nullable Element)\n\nforeign import scrollTop :: Element -> Effect Number\nforeign import setScrollTop :: Number -> Element -> Effect Unit\n\nforeign import scrollLeft :: Element -> Effect Number\nforeign import setScrollLeft :: Number -> Element -> Effect Unit\n\nforeign import scrollWidth :: Element -> Effect Number\nforeign import scrollHeight :: Element -> Effect Number\nforeign import clientTop :: Element -> Effect Number\nforeign import clientLeft :: Element -> Effect Number\nforeign import clientWidth :: Element -> Effect Number\nforeign import clientHeight :: Element -> Effect Number\n\ntype DOMRect =\n  { top :: Number\n  , right :: Number\n  , bottom :: Number\n  , left :: Number\n  , width :: Number\n  , height :: Number\n  , x :: Number\n  , y :: Number\n  }\n\nforeign import getBoundingClientRect :: Element -> Effect DOMRect\n\ntype ShadowRootInit = {\n  mode :: ShadowRootMode,\n  delegatesFocus :: Boolean\n}\n\nattachShadow :: ShadowRootInit -> Element -> Effect ShadowRoot\nattachShadow = _attachShadow <<< initToProps\n\ntype ShadowRootProps = {\n  mode :: String,\n  delegatesFocus :: Boolean\n}\n\ninitToProps :: ShadowRootInit -> ShadowRootProps\ninitToProps init = {\n  mode: show init.mode,\n  delegatesFocus: init.delegatesFocus\n}\n\nforeign import _attachShadow :: ShadowRootProps -> Element -> Effect ShadowRoot\n", "export function typeOf(value) {\n  return typeof value;\n}\n\nexport function tagOf(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nexport function isNull(value) {\n  return value === null;\n}\n\nexport function isUndefined(value) {\n  return value === undefined;\n}\n\nexport const isArray = Array.isArray || function (value) {\n  return Object.prototype.toString.call(value) === \"[object Array]\";\n};\n", "-- | This module defines a type of _strict_ linked lists, and associated helper\n-- | functions and type class instances.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is an improvement over `Data.Array` when working with\n-- | immutable lists of data in a purely-functional setting, but does not have\n-- | good random-access performance.\n\nmodule Data.List\n  ( module Data.List.Types\n  , toUnfoldable\n  , fromFoldable\n\n  , singleton\n  , (..), range\n  , some\n  , someRec\n  , many\n  , manyRec\n\n  , null\n  , length\n\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , modifyAt\n  , alterAt\n\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , filterM\n  , mapMaybe\n  , catMaybes\n\n  , sort\n  , sortBy\n\n  , Pattern(..)\n  , stripPrefix\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n  , partition\n\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n  , (\\\\), difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , transpose\n\n  , foldM\n\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM, tailRecM2)\nimport Data.Bifunctor (bimap)\nimport Data.Foldable (class Foldable, foldr, any, foldl)\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.List.Internal (emptySet, insertAndLookupBy)\nimport Data.List.Types (List(..), (:))\nimport Data.List.Types (NonEmptyList(..)) as NEL\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.NonEmpty ((:|))\nimport Data.Traversable (scanl, scanr) as Exports\nimport Data.Traversable (sequence)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, unfoldr)\n\n-- | Convert a list into any unfoldable structure.\n-- |\n-- | Running time: `O(n)`\ntoUnfoldable :: forall f. Unfoldable f => List ~> f\ntoUnfoldable = unfoldr (\\xs -> (\\rec -> Tuple rec.head rec.tail) <$> uncons xs)\n\n-- | Construct a list from a foldable structure.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f. Foldable f => f ~> List\nfromFoldable = foldr Cons Nil\n\n--------------------------------------------------------------------------------\n-- List creation ---------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Create a list with a single element.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> List a\nsingleton a = a : Nil\n\n-- | An infix synonym for `range`.\ninfix 8 range as ..\n\n-- | Create a list containing a range of integers, including both endpoints.\nrange :: Int -> Int -> List Int\nrange start end | start == end = singleton start\n                | otherwise = go end start (if start > end then 1 else -1) Nil\n  where\n  go s e step rest | s == e = s : rest\n                   | otherwise = go (s + step) e step (s : rest)\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nsome v = Cons <$> v <*> defer (\\_ -> many v)\n\n-- | A stack-safe version of `some`, at the cost of a `MonadRec` constraint.\nsomeRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nsomeRec v = Cons <$> v <*> manyRec v\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\nmany v = some v <|> pure Nil\n\n-- | A stack-safe version of `many`, at the cost of a `MonadRec` constraint.\nmanyRec :: forall f a. MonadRec f => Alternative f => f a -> f (List a)\nmanyRec p = tailRecM go Nil\n  where\n  go :: List a -> f (Step (List a) (List a))\n  go acc = do\n    aa <- (Loop <$> p) <|> pure (Done unit)\n    pure $ bimap (_ : acc) (\\_ -> reverse acc) aa\n\n--------------------------------------------------------------------------------\n-- List size -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether a list is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. List a -> Boolean\nnull Nil = true\nnull _ = false\n\n-- | Get the length of a list\n-- |\n-- | Running time: `O(n)`\nlength :: forall a. List a -> Int\nlength = foldl (\\acc _ -> acc + 1) 0\n\n--------------------------------------------------------------------------------\n-- Extending lists -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Append an element to the end of a list, creating a new list.\n-- |\n-- | Running time: `O(n)`\nsnoc :: forall a. List a -> a -> List a\nsnoc xs x = foldr (:) (x : Nil) xs\n\n-- | Insert an element into a sorted list.\n-- |\n-- | Running time: `O(n)`\ninsert :: forall a. Ord a => a -> List a -> List a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted list, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | Running time: `O(n)`\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> List a -> List a\ninsertBy _ x Nil = singleton x\ninsertBy cmp x ys@(y : ys') =\n  case cmp x y of\n    GT -> y : (insertBy cmp x ys')\n    _  -> x : ys\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`.\nhead :: List ~> Maybe\nhead Nil = Nothing\nhead (x : _) = Just x\n\n-- | Get the last element in a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`.\nlast :: List ~> Maybe\nlast (x : Nil) = Just x\nlast (_ : xs)  = last xs\nlast _         = Nothing\n\n-- | Get all but the first element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\ntail :: forall a. List a -> Maybe (List a)\ntail Nil = Nothing\ntail (_ : xs) = Just xs\n\n-- | Get all but the last element of a list, or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\ninit :: forall a. List a -> Maybe (List a)\ninit lst = _.init <$> unsnoc lst\n\n-- | Break a list into its first element, and the remaining elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(1)`\nuncons :: forall a. List a -> Maybe { head :: a, tail :: List a }\nuncons Nil = Nothing\nuncons (x : xs) = Just { head: x, tail: xs }\n\n-- | Break a list into its last element, and the preceding elements,\n-- | or `Nothing` if the list is empty.\n-- |\n-- | Running time: `O(n)`\nunsnoc :: forall a. List a -> Maybe { init :: List a, last :: a }\nunsnoc lst = (\\h -> { init: reverse h.revInit, last: h.last }) <$> go lst Nil\n  where\n  go Nil _ = Nothing\n  go (x : Nil) acc = Just { revInit: acc, last: x }\n  go (x : xs) acc = go xs (x : acc)\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the element at the specified index, or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)` where `n` is the required index.\nindex :: forall a. List a -> Int -> Maybe a\nindex Nil _ = Nothing\nindex (a : _) 0 = Just a\nindex (_ : as) i = index as (i - 1)\n\n-- | An infix synonym for `index`.\ninfixl 8 index as !!\n\n-- | Find the index of the first element equal to the specified element.\nelemIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\nelemLastIndex :: forall a. Eq a => a -> List a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first index for which a predicate holds.\nfindIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindIndex fn = go 0\n  where\n  go :: Int -> List a -> Maybe Int\n  go n (x : xs) | fn x = Just n\n                | otherwise = go (n + 1) xs\n  go _ Nil = Nothing\n\n-- | Find the last index for which a predicate holds.\nfindLastIndex :: forall a. (a -> Boolean) -> List a -> Maybe Int\nfindLastIndex fn xs = ((length xs - 1) - _) <$> findIndex fn (reverse xs)\n\n-- | Insert an element into a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ninsertAt :: forall a. Int -> a -> List a -> Maybe (List a)\ninsertAt 0 x xs = Just (x : xs)\ninsertAt n x (y : ys) = (y : _) <$> insertAt (n - 1) x ys\ninsertAt _ _ _  = Nothing\n\n-- | Delete an element from a list at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\ndeleteAt :: forall a. Int -> List a -> Maybe (List a)\ndeleteAt 0 (_ : ys) = Just ys\ndeleteAt n (y : ys) = (y : _) <$> deleteAt (n - 1) ys\ndeleteAt _ _  = Nothing\n\n-- | Update the element at the specified index, returning a new\n-- | list or `Nothing` if the index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nupdateAt :: forall a. Int -> a -> List a -> Maybe (List a)\nupdateAt 0 x ( _ : xs) = Just (x : xs)\nupdateAt n x (x1 : xs) = (x1 : _) <$> updateAt (n - 1) x xs\nupdateAt _ _ _ = Nothing\n\n-- | Update the element at the specified index by applying a function to\n-- | the current value, returning a new list or `Nothing` if the index is\n-- | out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nmodifyAt :: forall a. Int -> (a -> a) -> List a -> Maybe (List a)\nmodifyAt n f = alterAt n (Just <<< f)\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new list or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | Running time: `O(n)`\nalterAt :: forall a. Int -> (a -> Maybe a) -> List a -> Maybe (List a)\nalterAt 0 f (y : ys) = Just $\n  case f y of\n    Nothing -> ys\n    Just y' -> y' : ys\nalterAt n f (y : ys) = (y : _) <$> alterAt (n - 1) f ys\nalterAt _ _ _  = Nothing\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Reverse a list.\n-- |\n-- | Running time: `O(n)`\nreverse :: List ~> List\nreverse = go Nil\n  where\n  go acc Nil = acc\n  go acc (x : xs) = go (x : acc) xs\n\n-- | Flatten a list of lists.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcat :: forall a. List (List a) -> List a\nconcat = (_ >>= identity)\n\n-- | Apply a function to each element in a list, and flatten the results\n-- | into a single, new list.\n-- |\n-- | Running time: `O(n)`, where `n` is the total number of elements.\nconcatMap :: forall a b. (a -> List b) -> List a -> List b\nconcatMap = flip bind\n\n-- | Filter a list, keeping the elements which satisfy a predicate function.\n-- |\n-- | Running time: `O(n)`\nfilter :: forall a. (a -> Boolean) -> List a -> List a\nfilter p = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs)\n    | p x = go (x : acc) xs\n    | otherwise = go acc xs\n\n-- | Filter where the predicate returns a monadic `Boolean`.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. [a] -> [[a]]\n-- | powerSet = filterM (const [true, false])\n-- | ```\nfilterM :: forall a m. Monad m => (a -> m Boolean) -> List a -> m (List a)\nfilterM _ Nil = pure Nil\nfilterM p (x : xs) = do\n  b <- p x\n  xs' <- filterM p xs\n  pure if b then x : xs' else xs'\n\n-- | Apply a function to each element in a list, keeping only the results which\n-- | contain a value.\n-- |\n-- | Running time: `O(n)`\nmapMaybe :: forall a b. (a -> Maybe b) -> List a -> List b\nmapMaybe f = go Nil\n  where\n  go acc Nil = reverse acc\n  go acc (x : xs) =\n    case f x of\n      Nothing -> go acc xs\n      Just y -> go (y : acc) xs\n\n-- | Filter a list of optional values, keeping only the elements which contain\n-- | a value.\ncatMaybes :: forall a. List (Maybe a) -> List a\ncatMaybes = mapMaybe identity\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an list in increasing order.\nsort :: forall a. Ord a => List a -> List a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of a list in increasing order, where elements are\n-- | compared using the specified ordering.\nsortBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nsortBy cmp = mergeAll <<< sequences\n  -- implementation lifted from http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#sort\n  where\n  sequences :: List a -> List (List a)\n  sequences (a : b : xs)\n    | a `cmp` b == GT = descending b (singleton a) xs\n    | otherwise = ascending b (a : _) xs\n  sequences xs = singleton xs\n\n  descending :: a -> List a -> List a -> List (List a)\n  descending a as (b : bs)\n    | a `cmp` b == GT = descending b (a : as) bs\n  descending a as bs = (a : as) : sequences bs\n\n  ascending :: a -> (List a -> List a) -> List a -> List (List a)\n  ascending a as (b : bs)\n    | a `cmp` b /= GT = ascending b (\\ys -> as (a : ys)) bs\n  ascending a as bs = ((as $ singleton a) : sequences bs)\n\n  mergeAll :: List (List a) -> List a\n  mergeAll (x : Nil) = x\n  mergeAll xs = mergeAll (mergePairs xs)\n\n  mergePairs :: List (List a) -> List (List a)\n  mergePairs (a : b : xs) = merge a b : mergePairs xs\n  mergePairs xs = xs\n\n  merge :: List a -> List a -> List a\n  merge as@(a : as') bs@(b : bs')\n    | a `cmp` b == GT = b : merge as bs'\n    | otherwise       = a : merge as' bs\n  merge Nil bs = bs\n  merge as Nil = as\n\n--------------------------------------------------------------------------------\n-- Sublists --------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | A newtype used in cases where there is a list to be matched.\nnewtype Pattern a = Pattern (List a)\n\nderive instance eqPattern :: Eq a => Eq (Pattern a)\nderive instance ordPattern :: Ord a => Ord (Pattern a)\nderive instance newtypePattern :: Newtype (Pattern a) _\n\ninstance showPattern :: Show a => Show (Pattern a) where\n  show (Pattern s) = \"(Pattern \" <> show s <> \")\"\n\n\n-- | If the list starts with the given prefix, return the portion of the\n-- | list left after removing it, as a Just value. Otherwise, return Nothing.\n-- | * `stripPrefix (Pattern (1:Nil)) (1:2:Nil) == Just (2:Nil)`\n-- | * `stripPrefix (Pattern Nil) (1:Nil) == Just (1:Nil)`\n-- | * `stripPrefix (Pattern (2:Nil)) (1:Nil) == Nothing`\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to strip.\nstripPrefix :: forall a. Eq a => Pattern a -> List a -> Maybe (List a)\nstripPrefix (Pattern p') s = tailRecM2 go p' s\n  where\n  go prefix input = case prefix, input of\n    Cons p ps, Cons i is | p == i -> Just $ Loop { a: ps, b: is }\n    Nil, is -> Just $ Done is\n    _, _ -> Nothing\n\n-- | Extract a sublist by a start and end index.\nslice :: Int -> Int -> List ~> List\nslice start end xs = take (end - start) (drop start xs)\n\n-- | Take the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to take.\ntake :: forall a. Int -> List a -> List a\ntake = go Nil\n  where\n  go acc n _ | n < 1 = reverse acc\n  go acc _ Nil = reverse acc\n  go acc n (x : xs) = go (x : acc) (n - 1) xs\n\n-- | Take the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to take.\ntakeEnd :: forall a. Int -> List a -> List a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Take those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ntakeWhile :: forall a. (a -> Boolean) -> List a -> List a\ntakeWhile p = go Nil\n  where\n  go acc (x : xs) | p x = go (x : acc) xs\n  go acc _ = reverse acc\n\n-- | Drop the specified number of elements from the front of a list.\n-- |\n-- | Running time: `O(n)` where `n` is the number of elements to drop.\ndrop :: forall a. Int -> List a -> List a\ndrop n xs | n < 1 = xs\ndrop _ Nil = Nil\ndrop n (_ : xs) = drop (n - 1) xs\n\n-- | Drop the specified number of elements from the end of a list.\n-- |\n-- | Running time: `O(2n - m)` where `n` is the number of elements in list\n-- | and `m` is number of elements to drop.\ndropEnd :: forall a. Int -> List a -> List a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Drop those elements from the front of a list which match a predicate.\n-- |\n-- | Running time (worst case): `O(n)`\ndropWhile :: forall a. (a -> Boolean) -> List a -> List a\ndropWhile p = go\n  where\n  go (x : xs) | p x = go xs\n  go xs = xs\n\n-- | Split a list into two parts:\n-- |\n-- | 1. the longest initial segment for which all elements satisfy the specified predicate\n-- | 2. the remaining elements\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) (1 : 3 : 2 : 4 : 5 : Nil) == { init: (1 : 3 : Nil), rest: (2 : 4 : 5 : Nil) }\n-- | ```\n-- |\n-- | Running time: `O(n)`\nspan :: forall a. (a -> Boolean) -> List a -> { init :: List a, rest :: List a }\nspan p (x : xs') | p x = case span p xs' of\n  { init: ys, rest: zs } -> { init: x : ys, rest: zs }\nspan _ xs = { init: Nil, rest: xs }\n\n-- | Group equal, consecutive elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | group (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : (NonEmptyList (NonEmpty 1 Nil)) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroup :: forall a. Eq a => List a -> List (NEL.NonEmptyList a)\ngroup = groupBy (==)\n\n-- | Group equal elements of a list into lists.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupAll (1 : 1 : 2 : 2 : 1 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (1 : 1 : Nil))) : (NonEmptyList (NonEmpty 2 (2 : Nil))) : Nil\n-- | ```\ngroupAll :: forall a. Ord a => List a -> List (NEL.NonEmptyList a)\ngroupAll = group <<< sort\n\n-- | Group equal, consecutive elements of a list into lists, using the specified\n-- | equivalence relation to determine equality.\n-- |\n-- | For example,\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) (1 : 3 : 2 : 4 : 3 : 3 : Nil) ==\n-- |   (NonEmptyList (NonEmpty 1 (3 : Nil))) : (NonEmptyList (NonEmpty 2 Nil)) : (NonEmptyList (NonEmpty 4 Nil)) : (NonEmptyList (NonEmpty 3 (3 : Nil))) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n)`\ngroupBy :: forall a. (a -> a -> Boolean) -> List a -> List (NEL.NonEmptyList a)\ngroupBy _ Nil = Nil\ngroupBy eq (x : xs) = case span (eq x) xs of\n  { init: ys, rest: zs } -> NEL.NonEmptyList (x :| ys) : groupBy eq zs\n\n-- | Sort, then group equal elements of a list into lists, using the provided comparison function.\n-- |\n-- | ```purescript\n-- | groupAllBy (compare `on` (_ `div` 10)) (32 : 31 : 21 : 22 : 11 : 33 : Nil) ==\n-- |   NonEmptyList (11 :| Nil) : NonEmptyList (21 :| 22 : Nil) : NonEmptyList (32 :| 31 : 33) : Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\ngroupAllBy :: forall a. (a -> a -> Ordering) -> List a -> List (NEL.NonEmptyList a)\ngroupAllBy p = groupBy (\\x y -> p x y == EQ) <<< sortBy p\n\n-- | Returns a lists of elements which do and do not satisfy a predicate.\n-- |\n-- | Running time: `O(n)`\npartition :: forall a. (a -> Boolean) -> List a -> { yes :: List a, no :: List a }\npartition p xs = foldr select { no: Nil, yes: Nil } xs\n  where\n    select x { no, yes } = if p x\n                           then { no, yes: x : yes }\n                           else { no: x : no, yes }\n\n-- | Returns all final segments of the argument, longest first. For example,\n-- |\n-- | ```purescript\n-- | tails (1 : 2 : 3 : Nil) == ((1 : 2 : 3 : Nil) : (2 : 3 : Nil) : (3 : Nil) : (Nil) : Nil)\n-- | ```\n-- | Running time: `O(n)`\ntails :: forall a. List a -> List (List a)\ntails Nil = singleton Nil\ntails list@(Cons _ tl)= list : tails tl\n\n--------------------------------------------------------------------------------\n-- Set-like operations ---------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nub 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnub :: forall a. Ord a => List a -> List a\nnub = nubBy compare\n\n-- | Remove duplicate elements from a list based on the provided comparison function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- |\n-- | ```purescript\n-- | nubBy (compare `on` Array.length) ([1]:[2]:[3,4]:Nil) == [1]:[3,4]:Nil\n-- | ```\n-- |\n-- | Running time: `O(n log n)`\nnubBy :: forall a. (a -> a -> Ordering) -> List a -> List a\nnubBy p = reverse <<< go emptySet Nil\n  where\n    go _ acc Nil = acc\n    go s acc (a : as) =\n      let { found, result: s' } = insertAndLookupBy p a s\n      in if found\n        then go s' acc as\n        else go s' (a : acc) as\n\n-- | Remove duplicate elements from a list.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq 1:2:1:3:3:Nil == 1:2:3:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubEq :: forall a. Eq a => List a -> List a\nnubEq = nubByEq eq\n\n-- | Remove duplicate elements from a list, using the provided equivalence function.\n-- | Keeps the first occurrence of each element in the input list,\n-- | in the same order they appear in the input list.\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | function, rather than an ordering function.\n-- |\n-- | ```purescript\n-- | mod3eq = eq `on` \\n -> mod n 3\n-- | nubByEq mod3eq 1:3:4:5:6:Nil == 1:3:5:Nil\n-- | ```\n-- |\n-- | Running time: `O(n^2)`\nnubByEq :: forall a. (a -> a -> Boolean) -> List a -> List a\nnubByEq _     Nil = Nil\nnubByEq eq' (x : xs) = x : nubByEq eq' (filter (\\y -> not (eq' x y)) xs)\n\n-- | Calculate the union of two lists.\n-- |\n-- | Running time: `O(n^2)`\nunion :: forall a. Eq a => List a -> List a -> List a\nunion = unionBy (==)\n\n-- | Calculate the union of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nunionBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first occurrence of an element from a list.\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> List a -> List a\ndelete = deleteBy (==)\n\n-- | Delete the first occurrence of an element from a list, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n)`\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> List a -> List a\ndeleteBy _ _ Nil = Nil\ndeleteBy eq' x (y : ys) | eq' x y = ys\ndeleteBy eq' x (y : ys) = y : deleteBy eq' x ys\n\ninfix 5 difference as \\\\\n\n-- | Delete the first occurrence of each element in the second list from the first list.\n-- |\n-- | Running time: `O(n^2)`\ndifference :: forall a. Eq a => List a -> List a -> List a\ndifference = foldl (flip delete)\n\n-- | Calculate the intersection of two lists.\n-- |\n-- | Running time: `O(n^2)`\nintersect :: forall a. Eq a => List a -> List a -> List a\nintersect = intersectBy (==)\n\n-- | Calculate the intersection of two lists, using the specified\n-- | function to determine equality of elements.\n-- |\n-- | Running time: `O(n^2)`\nintersectBy :: forall a. (a -> a -> Boolean) -> List a -> List a -> List a\nintersectBy _  Nil _   = Nil\nintersectBy _  _   Nil = Nil\nintersectBy eq xs  ys  = filter (\\x -> any (eq x) ys) xs\n\n--------------------------------------------------------------------------------\n-- Zipping ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Apply a function to pairs of elements at the same positions in two lists,\n-- | collecting the results in a new list.\n-- |\n-- | If one list is longer, elements will be discarded from the longer list.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) (1 : 2 : 3 : Nil) (4 : 5 : 6 : 7 Nil) == 4 : 10 : 18 : Nil\n-- | ```\n-- |\n-- | Running time: `O(min(m, n))`\nzipWith :: forall a b c. (a -> b -> c) -> List a -> List b -> List c\nzipWith f xs ys = reverse $ go xs ys Nil\n  where\n  go Nil _ acc = acc\n  go _ Nil acc = acc\n  go (a : as) (b : bs) acc = go as bs $ f a b : acc\n\n-- | A generalization of `zipWith` which accumulates results in some `Applicative`\n-- | functor.\nzipWithA :: forall m a b c. Applicative m => (a -> b -> m c) -> List a -> List b -> m (List c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Collect pairs of elements at the same positions in two lists.\n-- |\n-- | Running time: `O(min(m, n))`\nzip :: forall a b. List a -> List b -> List (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms a list of pairs into a list of first components and a list of\n-- | second components.\nunzip :: forall a b. List (Tuple a b) -> Tuple (List a) (List b)\nunzip = foldr (\\(Tuple a b) (Tuple as bs) -> Tuple (a : as) (b : bs)) (Tuple Nil Nil)\n\n--------------------------------------------------------------------------------\n-- Transpose -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | The 'transpose' function transposes the rows and columns of its argument.\n-- | For example,\n-- |\n-- |     transpose ((1:2:3:Nil) : (4:5:6:Nil) : Nil) ==\n-- |       ((1:4:Nil) : (2:5:Nil) : (3:6:Nil) : Nil)\n-- |\n-- | If some of the rows are shorter than the following rows, their elements are skipped:\n-- |\n-- |     transpose ((10:11:Nil) : (20:Nil) : Nil : (30:31:32:Nil) : Nil) ==\n-- |       ((10:20:30:Nil) : (11:31:Nil) : (32:Nil) : Nil)\ntranspose :: forall a. List (List a) -> List (List a)\ntranspose Nil = Nil\ntranspose (Nil : xss) = transpose xss\ntranspose ((x : xs) : xss) =\n  (x : mapMaybe head xss) : transpose (xs : mapMaybe tail xss)\n\n--------------------------------------------------------------------------------\n-- Folding ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Perform a fold using a monadic step function.\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> List a -> m b\nfoldM _ b Nil = pure b\nfoldM f b (a : as) = f b a >>= \\b' -> foldM f b' as\n", "module Data.List.NonEmpty\n  ( module Data.List.Types\n  , toUnfoldable\n  , fromFoldable\n  , fromList\n  , toList\n  , singleton\n  , length\n  , cons\n  , cons'\n  , snoc\n  , snoc'\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , updateAt\n  , modifyAt\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , filterM\n  , mapMaybe\n  , catMaybes\n  , appendFoldable\n  , sort\n  , sortBy\n  , take\n  , takeWhile\n  , drop\n  , dropWhile\n  , span\n  , group\n  , groupAll\n  , groupBy\n  , groupAllBy\n  , partition\n  , nub\n  , nubBy\n  , nubEq\n  , nubByEq\n  , union\n  , unionBy\n  , intersect\n  , intersectBy\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n  , foldM\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable)\nimport Data.List ((:))\nimport Data.List as L\nimport Data.List.Types (NonEmptyList(..))\nimport Data.Maybe (Maybe(..), fromMaybe, maybe)\nimport Data.NonEmpty ((:|))\nimport Data.NonEmpty as NE\nimport Data.Semigroup.Traversable (sequence1)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafeCrashWith)\n\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.Semigroup.Foldable (fold1, foldMap1, for1_, sequence1_, traverse1_) as Exports\nimport Data.Semigroup.Traversable (sequence1, traverse1, traverse1Default) as Exports\nimport Data.Traversable (scanl, scanr) as Exports\n\n-- | Internal function: any operation on a list that is guaranteed not to delete\n-- | all elements also applies to a NEL, this function is a helper for defining\n-- | those cases.\nwrappedOperation\n  :: forall a b\n   . String\n  -> (L.List a -> L.List b)\n  -> NonEmptyList a\n  -> NonEmptyList b\nwrappedOperation name f (NonEmptyList (x :| xs)) =\n  case f (x : xs) of\n    x' : xs' -> NonEmptyList (x' :| xs')\n    L.Nil -> unsafeCrashWith (\"Impossible: empty list in NonEmptyList \" <> name)\n\n-- | Like `wrappedOperation`, but for functions that operate on 2 lists.\nwrappedOperation2\n  :: forall a b c\n   . String\n  -> (L.List a -> L.List b -> L.List c)\n  -> NonEmptyList a\n  -> NonEmptyList b\n  -> NonEmptyList c\nwrappedOperation2 name f (NonEmptyList (x :| xs)) (NonEmptyList (y :| ys)) =\n  case f (x : xs) (y : ys) of\n    x' : xs' -> NonEmptyList (x' :| xs')\n    L.Nil -> unsafeCrashWith (\"Impossible: empty list in NonEmptyList \" <> name)\n\n-- | Lifts a function that operates on a list to work on a NEL. This does not\n-- | preserve the non-empty status of the result.\nlift :: forall a b. (L.List a -> b) -> NonEmptyList a -> b\nlift f (NonEmptyList (x :| xs)) = f (x : xs)\n\ntoUnfoldable :: forall f. Unfoldable f => NonEmptyList ~> f\ntoUnfoldable =\n  unfoldr (\\xs -> (\\rec -> Tuple rec.head rec.tail) <$> L.uncons xs) <<< toList\n\nfromFoldable :: forall f a. Foldable f => f a -> Maybe (NonEmptyList a)\nfromFoldable = fromList <<< L.fromFoldable\n\nfromList :: forall a. L.List a -> Maybe (NonEmptyList a)\nfromList L.Nil = Nothing\nfromList (x : xs) = Just (NonEmptyList (x :| xs))\n\ntoList :: NonEmptyList ~> L.List\ntoList (NonEmptyList (x :| xs)) = x : xs\n\nsingleton :: forall a. a -> NonEmptyList a\nsingleton = NonEmptyList <<< NE.singleton\n\ncons :: forall a. a -> NonEmptyList a -> NonEmptyList a\ncons y (NonEmptyList (x :| xs)) = NonEmptyList (y :| x : xs)\n\ncons' :: forall a. a -> L.List a -> NonEmptyList a\ncons' x xs = NonEmptyList (x :| xs)\n\nsnoc :: forall a. NonEmptyList a -> a -> NonEmptyList a\nsnoc (NonEmptyList (x :| xs)) y = NonEmptyList (x :| L.snoc xs y)\n\nsnoc' :: forall a. L.List a -> a -> NonEmptyList a\nsnoc' (x : xs) y = NonEmptyList (x :| L.snoc xs y)\nsnoc' L.Nil y = singleton y\n\nhead :: forall a. NonEmptyList a -> a\nhead (NonEmptyList (x :| _)) = x\n\nlast :: forall a. NonEmptyList a -> a\nlast (NonEmptyList (x :| xs)) = fromMaybe x (L.last xs)\n\ntail :: NonEmptyList ~> L.List\ntail (NonEmptyList (_ :| xs)) = xs\n\ninit :: NonEmptyList ~> L.List\ninit (NonEmptyList (x :| xs)) = maybe L.Nil (x : _) (L.init xs)\n\nuncons :: forall a. NonEmptyList a -> { head :: a, tail :: L.List a }\nuncons (NonEmptyList (x :| xs)) = { head: x, tail: xs }\n\nunsnoc :: forall a. NonEmptyList a -> { init :: L.List a, last :: a }\nunsnoc (NonEmptyList (x :| xs)) = case L.unsnoc xs of\n  Nothing -> { init: L.Nil, last: x }\n  Just un -> { init: x : un.init, last: un.last }\n\nlength :: forall a. NonEmptyList a -> Int\nlength (NonEmptyList (_ :| xs)) = 1 + L.length xs\n\nindex :: forall a. NonEmptyList a -> Int -> Maybe a\nindex (NonEmptyList (x :| xs)) i\n  | i == 0 = Just x\n  | otherwise = L.index xs (i - 1)\n\ninfixl 8 index as !!\n\nelemIndex :: forall a. Eq a => a -> NonEmptyList a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\nelemLastIndex :: forall a. Eq a => a -> NonEmptyList a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\nfindIndex :: forall a. (a -> Boolean) -> NonEmptyList a -> Maybe Int\nfindIndex f (NonEmptyList (x :| xs))\n  | f x = Just 0\n  | otherwise = (_ + 1) <$> L.findIndex f xs\n\nfindLastIndex :: forall a. (a -> Boolean) -> NonEmptyList a -> Maybe Int\nfindLastIndex f (NonEmptyList (x :| xs)) =\n  case L.findLastIndex f xs of\n    Just i -> Just (i + 1)\n    Nothing\n      | f x -> Just 0\n      | otherwise -> Nothing\n\ninsertAt :: forall a. Int -> a -> NonEmptyList a -> Maybe (NonEmptyList a)\ninsertAt i a (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (a :| x : xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.insertAt (i - 1) a xs\n\nupdateAt :: forall a. Int -> a -> NonEmptyList a -> Maybe (NonEmptyList a)\nupdateAt i a (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (a :| xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.updateAt (i - 1) a xs\n\nmodifyAt :: forall a. Int -> (a -> a) -> NonEmptyList a -> Maybe (NonEmptyList a)\nmodifyAt i f (NonEmptyList (x :| xs))\n  | i == 0 = Just (NonEmptyList (f x :| xs))\n  | otherwise = NonEmptyList <<< (x :| _) <$> L.modifyAt (i - 1) f xs\n\nreverse :: forall a. NonEmptyList a -> NonEmptyList a\nreverse = wrappedOperation \"reverse\" L.reverse\n\nfilter :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\nfilter = lift <<< L.filter\n\nfilterM :: forall m a. Monad m => (a -> m Boolean) -> NonEmptyList a -> m (L.List a)\nfilterM = lift <<< L.filterM\n\nmapMaybe :: forall a b. (a -> Maybe b) -> NonEmptyList a -> L.List b\nmapMaybe = lift <<< L.mapMaybe\n\ncatMaybes :: forall a. NonEmptyList (Maybe a) -> L.List a\ncatMaybes = lift L.catMaybes\n\nconcat :: forall a. NonEmptyList (NonEmptyList a) -> NonEmptyList a\nconcat = (_ >>= identity)\n\nconcatMap :: forall a b. (a -> NonEmptyList b) -> NonEmptyList a -> NonEmptyList b\nconcatMap = flip bind\n\nappendFoldable :: forall t a. Foldable t => NonEmptyList a -> t a -> NonEmptyList a\nappendFoldable (NonEmptyList (x :| xs)) ys =\n  NonEmptyList (x :| (xs <> L.fromFoldable ys))\n\nsort :: forall a. Ord a => NonEmptyList a -> NonEmptyList a\nsort xs = sortBy compare xs\n\nsortBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList a\nsortBy = wrappedOperation \"sortBy\" <<< L.sortBy\n\ntake :: forall a. Int -> NonEmptyList a -> L.List a\ntake = lift <<< L.take\n\ntakeWhile :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\ntakeWhile = lift <<< L.takeWhile\n\ndrop :: forall a. Int -> NonEmptyList a -> L.List a\ndrop = lift <<< L.drop\n\ndropWhile :: forall a. (a -> Boolean) -> NonEmptyList a -> L.List a\ndropWhile = lift <<< L.dropWhile\n\nspan :: forall a. (a -> Boolean) -> NonEmptyList a -> { init :: L.List a, rest :: L.List a }\nspan = lift <<< L.span\n\ngroup :: forall a. Eq a => NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroup = wrappedOperation \"group\" L.group\n\ngroupAll :: forall a. Ord a => NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupAll = wrappedOperation \"groupAll\" L.groupAll\n\ngroupBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupBy = wrappedOperation \"groupBy\" <<< L.groupBy\n\ngroupAllBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList (NonEmptyList a)\ngroupAllBy = wrappedOperation \"groupAllBy\" <<< L.groupAllBy\n\npartition :: forall a. (a -> Boolean) -> NonEmptyList a -> { yes :: L.List a, no :: L.List a }\npartition = lift <<< L.partition\n\nnub :: forall a. Ord a => NonEmptyList a -> NonEmptyList a\nnub = wrappedOperation \"nub\" L.nub\n\nnubBy :: forall a. (a -> a -> Ordering) -> NonEmptyList a -> NonEmptyList a\nnubBy = wrappedOperation \"nubBy\" <<< L.nubBy\n\nnubEq :: forall a. Eq a => NonEmptyList a -> NonEmptyList a\nnubEq = wrappedOperation \"nubEq\" L.nubEq\n\nnubByEq :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a\nnubByEq = wrappedOperation \"nubByEq\" <<< L.nubByEq\n\nunion :: forall a. Eq a => NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nunion = wrappedOperation2 \"union\" L.union\n\nunionBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nunionBy = wrappedOperation2 \"unionBy\" <<< L.unionBy\n\nintersect :: forall a. Eq a => NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nintersect = wrappedOperation2 \"intersect\" L.intersect\n\nintersectBy :: forall a. (a -> a -> Boolean) -> NonEmptyList a -> NonEmptyList a -> NonEmptyList a\nintersectBy = wrappedOperation2 \"intersectBy\" <<< L.intersectBy\n\nzipWith :: forall a b c. (a -> b -> c) -> NonEmptyList a -> NonEmptyList b -> NonEmptyList c\nzipWith f (NonEmptyList (x :| xs)) (NonEmptyList (y :| ys)) =\n  NonEmptyList (f x y :| L.zipWith f xs ys)\n\nzipWithA :: forall m a b c. Applicative m => (a -> b -> m c) -> NonEmptyList a -> NonEmptyList b -> m (NonEmptyList c)\nzipWithA f xs ys = sequence1 (zipWith f xs ys)\n\nzip :: forall a b. NonEmptyList a -> NonEmptyList b -> NonEmptyList (Tuple a b)\nzip = zipWith Tuple\n\nunzip :: forall a b. NonEmptyList (Tuple a b) -> Tuple (NonEmptyList a) (NonEmptyList b)\nunzip ts = Tuple (map fst ts) (map snd ts)\n\nfoldM :: forall m a b. Monad m => (b -> a -> m b) -> b -> NonEmptyList a -> m b\nfoldM f b (NonEmptyList (a :| as)) = f b a >>= \\b' -> L.foldM f b' as\n", "export function _copyST(m) {\n  return function () {\n    var r = {};\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r[k] = m[k];\n      }\n    }\n    return r;\n  };\n}\n\nexport const empty = {};\n\nexport function runST(f) {\n  return f();\n}\n\nexport function _fmapObject(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _mapWithKey(m0, f) {\n  var m = {};\n  for (var k in m0) {\n    if (hasOwnProperty.call(m0, k)) {\n      m[k] = f(k)(m0[k]);\n    }\n  }\n  return m;\n}\n\nexport function _foldM(bind) {\n  return function (f) {\n    return function (mz) {\n      return function (m) {\n        var acc = mz;\n        function g(k) {\n          return function (z) {\n            return f(z)(k)(m[k]);\n          };\n        }\n        for (var k in m) {\n          if (hasOwnProperty.call(m, k)) {\n            acc = bind(acc)(g(k));\n          }\n        }\n        return acc;\n      };\n    };\n  };\n}\n\nexport function _foldSCObject(m, z, f, fromMaybe) {\n  var acc = z;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      var maybeR = f(acc)(k)(m[k]);\n      var r = fromMaybe(null)(maybeR);\n      if (r === null) return acc;\n      else acc = r;\n    }\n  }\n  return acc;\n}\n\nexport function all(f) {\n  return function (m) {\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k) && !f(k)(m[k])) return false;\n    }\n    return true;\n  };\n}\n\nexport function size(m) {\n  var s = 0;\n  for (var k in m) {\n    if (hasOwnProperty.call(m, k)) {\n      ++s;\n    }\n  }\n  return s;\n}\n\nexport function _lookup(no, yes, k, m) {\n  return k in m ? yes(m[k]) : no;\n}\n\nexport function _lookupST(no, yes, k, m) {\n  return function () {\n    return k in m ? yes(m[k]) : no;\n  };\n}\n\nexport function toArrayWithKey(f) {\n  return function (m) {\n    var r = [];\n    for (var k in m) {\n      if (hasOwnProperty.call(m, k)) {\n        r.push(f(k)(m[k]));\n      }\n    }\n    return r;\n  };\n}\n\nexport const keys = Object.keys || toArrayWithKey(function (k) {\n  return function () { return k; };\n});\n", "-- | This module defines a type of native homogeneous Javascript Objects.\n-- |\n-- | To maximize performance, Javascript objects are not wrapped,\n-- | and some native code is used even when it's not necessary.\n\nmodule Foreign.Object\n  ( Object\n  , empty\n  , isEmpty\n  , size\n  , singleton\n  , insert\n  , lookup\n  , toUnfoldable\n  , toAscUnfoldable\n  , fromFoldable\n  , fromFoldableWith\n  , fromFoldableWithIndex\n  , fromHomogeneous\n  , delete\n  , pop\n  , member\n  , alter\n  , update\n  , mapWithKey\n  , filterWithKey\n  , filterKeys\n  , filter\n  , keys\n  , values\n  , union\n  , unionWith\n  , unions\n  , isSubmap\n  , fold\n  , foldMap\n  , foldM\n  , foldMaybe\n  , all\n  , thawST\n  , freezeST\n  , runST\n  , toArrayWithKey\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST (ST)\nimport Control.Monad.ST as ST\nimport Data.Array as A\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldl, foldr, for_)\nimport Data.FoldableWithIndex (class FoldableWithIndex, forWithIndex_)\nimport Data.Function.Uncurried (Fn2, runFn2, Fn4, runFn4)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.Maybe (Maybe(..), maybe, fromMaybe)\nimport Data.Traversable (class Traversable, traverse)\nimport Data.TraversableWithIndex (class TraversableWithIndex, traverseWithIndex)\nimport Data.Tuple (Tuple(..), fst, uncurry)\nimport Data.Unfoldable (class Unfoldable)\nimport Foreign.Object.ST (STObject)\nimport Foreign.Object.ST as OST\nimport Type.Row.Homogeneous (class Homogeneous)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | `Object a` represents a homogeneous JS Object with values of type `a`.\nforeign import data Object :: Type -> Type\n\ntype role Object representational\n\nforeign import _copyST :: forall a b r. a -> ST r b\n\n-- | Convert an immutable Object into a mutable Object\nthawST :: forall a r. Object a -> ST r (STObject r a)\nthawST = _copyST\n\n-- | Convert a mutable Object into an immutable Object\nfreezeST :: forall a r. STObject r a -> ST r (Object a)\nfreezeST = _copyST\n\n-- | Freeze a mutable Object, creating an immutable Object. Use this function as you would use\n-- | `Control.Monad.ST.run` (from the `purescript-st` package) to freeze a mutable reference.\n-- |\n-- | The rank-2 type prevents the Object from escaping the scope of `runST`.\nforeign import runST :: forall a. (forall r. ST r (STObject r a)) -> Object a\n\nmutate :: forall a b. (forall r. STObject r a -> ST r b) -> Object a -> Object a\nmutate f m = runST do\n  s <- thawST m\n  _ <- f s\n  pure s\n\nforeign import _fmapObject :: forall a b. Fn2 (Object a) (a -> b) (Object b)\n\ninstance functorObject :: Functor Object where\n  map f m = runFn2 _fmapObject m f\n\ninstance functorWithIndexObject :: FunctorWithIndex String Object where\n  mapWithIndex = mapWithKey\n\nforeign import _foldM :: forall a m z. (m -> (z -> m) -> m) -> (z -> String -> a -> m) -> m -> Object a -> m\n\n-- | Fold the keys and values of an object\nfold :: forall a z. (z -> String -> a -> z) -> z -> Object a -> z\nfold = _foldM ((#))\n\n-- | Fold the keys and values of an object, accumulating values using some\n-- | `Monoid`.\nfoldMap :: forall a m. Monoid m => (String -> a -> m) -> Object a -> m\nfoldMap f = fold (\\acc k v -> acc <> f k v) mempty\n\n-- | Fold the keys and values of an object, accumulating values and effects in\n-- | some `Monad`.\nfoldM :: forall a m z. Monad m => (z -> String -> a -> m z) -> z -> Object a -> m z\nfoldM f z = _foldM bind f (pure z)\n\ninstance foldableObject :: Foldable Object where\n  foldl f = fold (\\z _ -> f z)\n  foldr f z m = foldr f z (values m)\n  foldMap f = foldMap (const f)\n\ninstance foldableWithIndexObject :: FoldableWithIndex String Object where\n  foldlWithIndex f = fold (flip f)\n  foldrWithIndex f z m = foldr (uncurry f) z (toArrayWithKey Tuple m)\n  foldMapWithIndex = foldMap\n\ninstance traversableObject :: Traversable Object where\n  traverse = traverseWithIndex <<< const\n  sequence = traverse identity\n\ninstance traversableWithIndexObject :: TraversableWithIndex String Object where\n  traverseWithIndex f ms =\n    fold (\\acc k v -> flip (insert k) <$> acc <*> f k v) (pure empty) ms\n\n-- Unfortunately the above are not short-circuitable (consider using purescript-machines)\n-- so we need special cases:\n\nforeign import _foldSCObject :: forall a z. Fn4 (Object a) z (z -> String -> a -> Maybe z) (forall b. b -> Maybe b -> b) z\n\n-- | Fold the keys and values of a map.\n-- |\n-- | This function allows the folding function to terminate the fold early,\n-- | using `Maybe`.\nfoldMaybe :: forall a z. (z -> String -> a -> Maybe z) -> z -> Object a -> z\nfoldMaybe f z m = runFn4 _foldSCObject m z f fromMaybe\n\n-- | Test whether all key/value pairs in a `Object` satisfy a predicate.\nforeign import all :: forall a. (String -> a -> Boolean) -> Object a -> Boolean\n\ninstance eqObject :: Eq a => Eq (Object a) where\n  eq m1 m2 = (isSubmap m1 m2) && (isSubmap m2 m1)\n\ninstance eq1Object :: Eq1 Object where\n  eq1 = eq\n\n-- Internal use\ntoAscArray :: forall v. Object v -> Array (Tuple String v)\ntoAscArray = toAscUnfoldable\n\ninstance ordObject :: Ord a => Ord (Object a) where\n  compare m1 m2 = compare (toAscArray m1) (toAscArray m2)\n\ninstance showObject :: Show a => Show (Object a) where\n  show m = \"(fromFoldable \" <> show (toArray m) <> \")\"\n\n-- | An empty map\nforeign import empty :: forall a. Object a\n\n-- | Test whether one map contains all of the keys and values contained in another map\nisSubmap :: forall a. Eq a => Object a -> Object a -> Boolean\nisSubmap m1 m2 = all f m1 where\n  f k v = runFn4 _lookup false ((==) v) k m2\n\n-- | Test whether a map is empty\nisEmpty :: forall a. Object a -> Boolean\nisEmpty = all (\\_ _ -> false)\n\n-- | Calculate the number of key/value pairs in a map\nforeign import size :: forall a. Object a -> Int\n\n-- | Create an `Object a` with one key/value pair\nsingleton :: forall a. String -> a -> Object a\nsingleton k v = runST (OST.poke k v =<< OST.new)\n\nforeign import _lookup :: forall a z. Fn4 z (a -> z) String (Object a) z\n\n-- | Lookup the value for a key in a map\nlookup :: forall a. String -> Object a -> Maybe a\nlookup = runFn4 _lookup Nothing Just\n\n-- | Test whether a `String` appears as a key in a map\nmember :: forall a. String -> Object a -> Boolean\nmember = runFn4 _lookup false (const true)\n\n-- | Insert or replace a key/value pair in a map\ninsert :: forall a. String -> a -> Object a -> Object a\ninsert k v = mutate (OST.poke k v)\n\n-- | Delete a key and value from a map\ndelete :: forall a. String -> Object a -> Object a\ndelete k = mutate (OST.delete k)\n\n-- | Delete a key and value from a map, returning the value\n-- | as well as the subsequent map\npop :: forall a. String -> Object a -> Maybe (Tuple a (Object a))\npop k m = lookup k m <#> \\a -> Tuple a (delete k m)\n\n-- | Insert, remove or update a value for a key in a map\nalter :: forall a. (Maybe a -> Maybe a) -> String -> Object a -> Object a\nalter f k m = case f (k `lookup` m) of\n  Nothing -> delete k m\n  Just v -> insert k v m\n\n-- | Remove or update a value for a key in a map\nupdate :: forall a. (a -> Maybe a) -> String -> Object a -> Object a\nupdate f k m = alter (maybe Nothing f) k m\n\n-- | Create an `Object a` from a foldable collection of key/value pairs\nfromFoldable :: forall f a. Foldable f => f (Tuple String a) -> Object a\nfromFoldable l = runST do\n  s <- OST.new\n  ST.foreach (A.fromFoldable l) \\(Tuple k v) -> void $ OST.poke k v s\n  pure s\n\n-- | Create an `Object a` from a `String`-indexed foldable collection\nfromFoldableWithIndex :: forall f a. FoldableWithIndex String f => f a -> Object a\nfromFoldableWithIndex l = runST do\n  s <- OST.new\n  forWithIndex_ l \\k v -> OST.poke k v s\n  pure s\n\nforeign import _lookupST :: forall a r z. Fn4 z (a -> z) String (STObject r a) (ST r z)\n\n-- | Create an `Object a` from a foldable collection of key/value pairs, using the\n-- | specified function to combine values for duplicate keys.\nfromFoldableWith :: forall f a. Foldable f => (a -> a -> a) -> f (Tuple String a) -> Object a\nfromFoldableWith f l = runST (do\n  s <- OST.new\n  for_ l (\\(Tuple k v) -> runFn4 _lookupST v (f v) k s >>= \\v' -> OST.poke k v' s)\n  pure s)\n\n-- | Create an `Object a` from a homogeneous record, i.e. all of the record\n-- | fields are of the same type.\nfromHomogeneous :: forall r a. Homogeneous r a => { | r } -> Object a\nfromHomogeneous = unsafeCoerce\n\nforeign import toArrayWithKey :: forall a b . (String -> a -> b) -> Object a -> Array b\n\n-- | Unfolds a map into a list of key/value pairs\ntoUnfoldable :: forall f a. Unfoldable f => Object a -> f (Tuple String a)\ntoUnfoldable = A.toUnfoldable <<< toArrayWithKey Tuple\n\n-- | Unfolds a map into a list of key/value pairs which is guaranteed to be\n-- | sorted by key\ntoAscUnfoldable :: forall f a. Unfoldable f => Object a -> f (Tuple String a)\ntoAscUnfoldable = A.toUnfoldable <<< A.sortWith fst <<< toArrayWithKey Tuple\n\n-- Internal\ntoArray :: forall a. Object a -> Array (Tuple String a)\ntoArray = toArrayWithKey Tuple\n\n-- | Get an array of the keys in a map\nforeign import keys :: forall a. Object a -> Array String\n\n-- | Get a list of the values in a map\nvalues :: forall a. Object a -> Array a\nvalues = toArrayWithKey (\\_ v -> v)\n\n-- | Compute the union of two maps, preferring the first map in the case of\n-- | duplicate keys.\nunion :: forall a. Object a -> Object a -> Object a\nunion m = mutate (\\s -> foldM (\\s' k v -> OST.poke k v s') s m)\n\n-- | Compute the union of two maps, using the specified function\n-- | to combine values for duplicate keys.\nunionWith :: forall a. (a -> a -> a) -> Object a -> Object a -> Object a\nunionWith f m1 m2 =\n  mutate (\\s1 -> foldM (\\s2 k v1 -> OST.poke k (runFn4 _lookup v1 (\\v2 -> f v1 v2) k m2) s2) s1 m1) m2\n\n-- | Compute the union of a collection of maps\nunions :: forall f a. Foldable f => f (Object a) -> Object a\nunions = foldl union empty\n\nforeign import _mapWithKey :: forall a b. Fn2 (Object a) (String -> a -> b) (Object b)\n\n-- | Apply a function of two arguments to each key/value pair, producing a new map\nmapWithKey :: forall a b. (String -> a -> b) -> Object a -> Object b\nmapWithKey f m = runFn2 _mapWithKey m f\n\ninstance semigroupObject :: (Semigroup a) => Semigroup (Object a) where\n  append = unionWith (<>)\n\ninstance monoidObject :: (Semigroup a) => Monoid (Object a) where\n  mempty = empty\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | fails to hold.\nfilterWithKey :: forall a. (String -> a -> Boolean) -> Object a -> Object a\nfilterWithKey predicate m = runST go\n  where\n  go :: forall r. ST r (STObject r a)\n  go = do\n    m' <- OST.new\n    foldM step m' m\n    where\n      step acc k v = if predicate k v then OST.poke k v acc else pure acc\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the key fails to hold.\nfilterKeys :: (String -> Boolean) -> Object ~> Object\nfilterKeys predicate = filterWithKey $ const <<< predicate\n\n-- | Filter out those key/value pairs of a map for which a predicate\n-- | on the value fails to hold.\nfilter :: forall a. (a -> Boolean) -> Object a -> Object a\nfilter predicate = filterWithKey $ const predicate\n", "export function eventListener(fn) {\n  return function () {\n    return function (event) {\n      return fn(event)();\n    };\n  };\n}\n\nexport function addEventListenerWithOptions(type) {\n  return function (listener) {\n    return function (options) {\n      return function (target) {\n        return function () {\n          return target.addEventListener(type, listener, options);\n        };\n      };\n    };\n  };\n}\n\nexport function addEventListener(type) {\n  return function (listener) {\n    return function (useCapture) {\n      return function (target) {\n        return function () {\n          return target.addEventListener(type, listener, useCapture);\n        };\n      };\n    };\n  };\n}\n\nexport function removeEventListener(type) {\n  return function (listener) {\n    return function (useCapture) {\n      return function (target) {\n        return function () {\n          return target.removeEventListener(type, listener, useCapture);\n        };\n      };\n    };\n  };\n}\n\nexport function dispatchEvent(event) {\n  return function (target) {\n    return function () {\n      return target.dispatchEvent(event);\n    };\n  };\n}\n", "module Halogen.HTML.Core\n  ( HTML(..)\n  , renderWidget\n  , widget\n  , text\n  , element\n  , keyed\n  , prop\n  , attr\n  , handler\n  , ref\n  , class IsProp\n  , toPropValue\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport DOM.HTML.Indexed.AutocompleteType (AutocompleteType, renderAutocompleteType)\nimport DOM.HTML.Indexed.ButtonType (ButtonType, renderButtonType)\nimport DOM.HTML.Indexed.CrossOriginValue (CrossOriginValue, renderCrossOriginValue)\nimport DOM.HTML.Indexed.DirValue (DirValue, renderDirValue)\nimport DOM.HTML.Indexed.FormMethod (FormMethod, renderFormMethod)\nimport DOM.HTML.Indexed.InputAcceptType (InputAcceptType, renderInputAcceptType)\nimport DOM.HTML.Indexed.InputType (InputType, renderInputType)\nimport DOM.HTML.Indexed.KindValue (KindValue, renderKindValue)\nimport DOM.HTML.Indexed.MenuType (MenuType, renderMenuType)\nimport DOM.HTML.Indexed.MenuitemType (MenuitemType, renderMenuitemType)\nimport DOM.HTML.Indexed.OrderedListType (OrderedListType, renderOrderedListType)\nimport DOM.HTML.Indexed.PreloadValue (PreloadValue, renderPreloadValue)\nimport DOM.HTML.Indexed.ScopeValue (ScopeValue, renderScopeValue)\nimport DOM.HTML.Indexed.StepValue (StepValue, renderStepValue)\nimport DOM.HTML.Indexed.WrapValue (WrapValue, renderWrapValue)\nimport Data.Bifunctor (class Bifunctor, bimap, rmap)\nimport Data.Maybe (Maybe(..))\nimport Data.MediaType (MediaType)\nimport Data.Newtype (class Newtype, un, unwrap)\nimport Data.Tuple (Tuple)\nimport Halogen.Query.Input (Input)\nimport Halogen.VDom (ElemName(..), Namespace(..)) as Exports\nimport Halogen.VDom.DOM.Prop (ElemRef(..), Prop(..), PropValue, propFromBoolean, propFromInt, propFromNumber, propFromString)\nimport Halogen.VDom.DOM.Prop (Prop(..), PropValue) as Exports\nimport Halogen.VDom.Types as VDom\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Element (Element)\nimport Web.Event.Event (Event, EventType)\nimport Web.HTML.Common (AttrName(..), ClassName(..), PropName(..)) as Exports\nimport Web.HTML.Common (AttrName(..), PropName(..))\n\nnewtype HTML w i = HTML (VDom.VDom (Array (Prop (Input i))) w)\n\nderive instance newtypeHTML :: Newtype (HTML w i) _\n\ninstance bifunctorHTML :: Bifunctor HTML where\n  bimap f g (HTML vdom) = HTML (bimap (map (map (map g))) f vdom)\n\ninstance functorHTML :: Functor (HTML p) where\n  map = rmap\n\nrenderWidget :: forall w x i j. (i -> j) -> (w -> HTML x j) -> HTML w i -> HTML x j\nrenderWidget f g (HTML vdom) =\n  HTML (VDom.renderWidget (map (map (map f))) (un HTML <<< g) vdom)\n\nwidget :: forall p q. p -> HTML p q\nwidget = HTML <<< VDom.Widget\n\n-- | Constructs a text node `HTML` value.\ntext :: forall w i. String -> HTML w i\ntext = HTML <<< VDom.Text\n\n-- | A smart constructor for HTML elements.\nelement :: forall w i. Maybe VDom.Namespace -> VDom.ElemName -> Array (Prop i) -> Array (HTML w i) -> HTML w i\nelement ns =\n  coe (\\name props children -> VDom.Elem ns name props children)\n  where\n  coe\n    :: (VDom.ElemName -> Array (Prop i) -> Array (VDom.VDom (Array (Prop i)) w) -> VDom.VDom (Array (Prop i)) w)\n    -> VDom.ElemName\n    -> Array (Prop i)\n    -> Array (HTML w i)\n    -> HTML w i\n  coe = unsafeCoerce\n\n-- | A smart constructor for HTML elements with keyed children.\nkeyed :: forall w i. Maybe VDom.Namespace -> VDom.ElemName -> Array (Prop i) -> Array (Tuple String (HTML w i)) -> HTML w i\nkeyed ns = coe (\\name props children -> VDom.Keyed ns name props children)\n  where\n  coe\n    :: (VDom.ElemName -> Array (Prop i) -> Array (Tuple String (VDom.VDom (Array (Prop i)) w)) -> VDom.VDom (Array (Prop i)) w)\n    -> VDom.ElemName\n    -> Array (Prop i)\n    -> Array (Tuple String (HTML w i))\n    -> HTML w i\n  coe = unsafeCoerce\n\n-- | Create a HTML property.\nprop :: forall value i. IsProp value => PropName value -> value -> Prop i\nprop (PropName name) = Property name <<< toPropValue\n\n-- | Create a HTML attribute.\nattr :: forall i. Maybe VDom.Namespace -> AttrName -> String -> Prop i\nattr ns (AttrName name) = Attribute ns name\n\n-- | Create an event handler.\nhandler :: forall i. EventType -> (Event -> Maybe i) -> Prop i\nhandler = Handler\n\nref :: forall i. (Maybe Element -> Maybe i) -> Prop i\nref f = Ref $ f <<< case _ of\n  Created x -> Just x\n  Removed _ -> Nothing\n\nclass IsProp a where\n  toPropValue :: a -> PropValue\n\ninstance isPropString :: IsProp String where\n  toPropValue = propFromString\n\ninstance isPropInt :: IsProp Int where\n  toPropValue = propFromInt\n\ninstance isPropNumber :: IsProp Number where\n  toPropValue = propFromNumber\n\ninstance isPropBoolean :: IsProp Boolean where\n  toPropValue = propFromBoolean\n\ninstance isPropMediaType :: IsProp MediaType where\n  toPropValue = propFromString <<< unwrap\n\ninstance isPropButtonType :: IsProp ButtonType where\n  toPropValue = propFromString <<< renderButtonType\n\ninstance isPropCrossOriginValue :: IsProp CrossOriginValue where\n  toPropValue = propFromString <<< renderCrossOriginValue\n\ninstance isPropDirValue :: IsProp DirValue where\n  toPropValue = propFromString <<< renderDirValue\n\ninstance isPropFormMethod :: IsProp FormMethod where\n  toPropValue = propFromString <<< renderFormMethod\n\ninstance isPropInputType :: IsProp InputType where\n  toPropValue = propFromString <<< renderInputType\n\ninstance isPropKindValue :: IsProp KindValue where\n  toPropValue = propFromString <<< renderKindValue\n\ninstance isPropMenuitemType :: IsProp MenuitemType where\n  toPropValue = propFromString <<< renderMenuitemType\n\ninstance isPropMenuType :: IsProp MenuType where\n  toPropValue = propFromString <<< renderMenuType\n\ninstance isPropAutocompleteType :: IsProp AutocompleteType where\n  toPropValue = propFromString <<< renderAutocompleteType\n\ninstance isPropOrderedListType :: IsProp OrderedListType where\n  toPropValue = propFromString <<< renderOrderedListType\n\ninstance isPropPreloadValue :: IsProp PreloadValue where\n  toPropValue = propFromString <<< renderPreloadValue\n\ninstance isPropScopeValue :: IsProp ScopeValue where\n  toPropValue = propFromString <<< renderScopeValue\n\ninstance isPropStepValue :: IsProp StepValue where\n  toPropValue = propFromString <<< renderStepValue\n\ninstance isPropWrapValue :: IsProp WrapValue where\n  toPropValue = propFromString <<< renderWrapValue\n\ninstance isPropInputAcceptType :: IsProp InputAcceptType where\n  toPropValue = propFromString <<< renderInputAcceptType\n", "-- | A closed signature of type-indexed (refined) HTML properties; these can be\n-- | used to ensure correctness by construction, and then erased into the\n-- | standard unrefined versions.\nmodule Halogen.HTML.Properties\n  ( IProp(..)\n  , prop\n  , attr\n  , attrNS\n  , ref\n  , expand\n\n  , alt\n  , charset\n  , class_\n  , classes\n  , cols\n  , rows\n  , colSpan\n  , rowSpan\n  , for\n  , height\n  , width\n  , href\n  , id\n  , name\n  , rel\n  , src\n  , srcDoc\n  , style\n  , scope\n  , target\n  , title\n  , download\n\n  , method\n  , action\n  , enctype\n  , noValidate\n\n  , type_\n  , value\n  , min\n  , max\n  , step\n  , disabled\n  , enabled\n  , required\n  , readOnly\n  , spellcheck\n  , checked\n  , selected\n  , selectedIndex\n  , placeholder\n  , autocomplete\n  , list\n  , autofocus\n  , multiple\n  , pattern\n  , accept\n\n  , autoplay\n  , controls\n  , loop\n  , muted\n  , poster\n  , preload\n\n  , draggable\n  , tabIndex\n\n  , module I\n  ) where\n\nimport Prelude\n\nimport DOM.HTML.Indexed (CSSPixel) as I\nimport DOM.HTML.Indexed.AutocompleteType (AutocompleteType(..)) as I\nimport DOM.HTML.Indexed.ButtonType (ButtonType(..)) as I\nimport DOM.HTML.Indexed.FormMethod (FormMethod(..)) as I\nimport DOM.HTML.Indexed.InputAcceptType (InputAcceptType(..)) as I\nimport DOM.HTML.Indexed.InputType (InputType(..)) as I\nimport DOM.HTML.Indexed.MenuType (MenuType(..)) as I\nimport DOM.HTML.Indexed.MenuitemType (MenuitemType(..)) as I\nimport DOM.HTML.Indexed.OrderedListType (OrderedListType(..)) as I\nimport DOM.HTML.Indexed.PreloadValue (PreloadValue(..)) as I\nimport DOM.HTML.Indexed.ScopeValue (ScopeValue(..)) as I\nimport DOM.HTML.Indexed.StepValue (StepValue(..)) as I\nimport Data.Maybe (Maybe(..))\nimport Data.MediaType (MediaType)\nimport Data.Newtype (class Newtype, unwrap)\nimport Data.String (joinWith)\nimport Halogen.HTML.Core (class IsProp, AttrName(..), ClassName, Namespace, PropName(..), Prop)\nimport Halogen.HTML.Core as Core\nimport Halogen.Query.Input (Input(..), RefLabel)\nimport Prim.Row as Row\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Element (Element)\n\n-- | The phantom row `r` can be thought of as a context which is synthesized in\n-- | the course of constructing a refined HTML expression.\nnewtype IProp (r :: Row Type) i = IProp (Prop (Input i))\n\nderive instance newtypeIProp :: Newtype (IProp r i) _\nderive instance functorIProp :: Functor (IProp r)\n\n-- | Creates an indexed HTML property.\nprop\n  :: forall value r i\n   . IsProp value\n  => PropName value\n  -> value\n  -> IProp r i\nprop = (unsafeCoerce :: (PropName value -> value -> Prop (Input i)) -> PropName value -> value -> IProp r i) Core.prop\n\n-- | Creates an indexed HTML attribute.\nattr :: forall r i. AttrName -> String -> IProp r i\nattr =\n  Core.attr Nothing #\n    ( unsafeCoerce\n        :: (AttrName -> String -> Prop (Input i))\n        -> AttrName\n        -> String\n        -> IProp r i\n    )\n\n-- | Creates an indexed HTML attribute.\nattrNS :: forall r i. Namespace -> AttrName -> String -> IProp r i\nattrNS =\n  pure >>> Core.attr >>>\n    ( unsafeCoerce\n        :: (AttrName -> String -> Prop (Input i))\n        -> AttrName\n        -> String\n        -> IProp r i\n    )\n\n-- | The `ref` property allows an input to be raised once a `HTMLElement` has\n-- | been created or destroyed in the DOM for the element that the property is\n-- | attached to.\nref :: forall r i. RefLabel -> IProp r i\nref = (unsafeCoerce :: ((Maybe Element -> Maybe (Input i)) -> Prop (Input i)) -> (Maybe Element -> Maybe (Input i)) -> IProp r i) Core.ref <<< go\n  where\n  go :: RefLabel -> Maybe Element -> Maybe (Input i)\n  go p mel = Just (RefUpdate p mel)\n\n-- | Every `IProp lt i` can be cast to some `IProp gt i` as long as `lt` is a\n-- | subset of `gt`.\nexpand :: forall lt gt a i. Row.Union lt a gt => IProp lt i -> IProp gt i\nexpand = unsafeCoerce\n\nalt :: forall r i. String -> IProp (alt :: String | r) i\nalt = prop (PropName \"alt\")\n\ncharset :: forall r i. String -> IProp (charset :: String | r) i\ncharset = prop (PropName \"charset\")\n\nclass_ :: forall r i. ClassName -> IProp (class :: String | r) i\nclass_ = prop (PropName \"className\") <<< unwrap\n\nclasses :: forall r i. Array ClassName -> IProp (class :: String | r) i\nclasses = prop (PropName \"className\") <<< joinWith \" \" <<< map unwrap\n\ncols :: forall r i. Int -> IProp (cols :: Int | r) i\ncols = prop (PropName \"cols\")\n\nrows :: forall r i. Int -> IProp (rows :: Int | r) i\nrows = prop (PropName \"rows\")\n\ncolSpan :: forall r i. Int -> IProp (colSpan :: Int | r) i\ncolSpan = prop (PropName \"colSpan\")\n\nrowSpan :: forall r i. Int -> IProp (rowSpan :: Int | r) i\nrowSpan = prop (PropName \"rowSpan\")\n\nfor :: forall r i. String -> IProp (for :: String | r) i\nfor = prop (PropName \"htmlFor\")\n\nheight :: forall r i. I.CSSPixel -> IProp (height :: I.CSSPixel | r) i\nheight = prop (PropName \"height\")\n\nwidth :: forall r i. I.CSSPixel -> IProp (width :: I.CSSPixel | r) i\nwidth = prop (PropName \"width\")\n\nhref :: forall r i. String -> IProp (href :: String | r) i\nhref = prop (PropName \"href\")\n\nid :: forall r i. String -> IProp (id :: String | r) i\nid = prop (PropName \"id\")\n\nname :: forall r i. String -> IProp (name :: String | r) i\nname = prop (PropName \"name\")\n\nrel :: forall r i. String -> IProp (rel :: String | r) i\nrel = prop (PropName \"rel\")\n\nsrc :: forall r i. String -> IProp (src :: String | r) i\nsrc = prop (PropName \"src\")\n\nsrcDoc :: forall r i. String -> IProp (srcDoc :: String | r) i\nsrcDoc = prop (PropName \"srcdoc\")\n\n-- | Sets the `style` attribute to the specified string.\n-- |\n-- | ```purs\n-- | ... [ style \"height: 50px;\" ]\n-- | ```\n-- |\n-- | If you prefer to use typed CSS for this attribute, you can use the purescript-halogen-css library:\n-- | https://github.com/purescript-halogen/purescript-halogen-css\nstyle :: forall r i. String -> IProp (style :: String | r) i\nstyle = attr (AttrName \"style\")\n\nscope :: forall r i. I.ScopeValue -> IProp (scope :: I.ScopeValue | r) i\nscope = prop (PropName \"scope\")\n\ntarget :: forall r i. String -> IProp (target :: String | r) i\ntarget = prop (PropName \"target\")\n\ntitle :: forall r i. String -> IProp (title :: String | r) i\ntitle = prop (PropName \"title\")\n\ndownload :: forall r i. String -> IProp (download :: String | r) i\ndownload = prop (PropName \"download\")\n\nmethod :: forall r i. I.FormMethod -> IProp (method :: I.FormMethod | r) i\nmethod = prop (PropName \"method\")\n\naction :: forall r i. String -> IProp (action :: String | r) i\naction = prop (PropName \"action\")\n\nenctype :: forall r i. MediaType -> IProp (enctype :: MediaType | r) i\nenctype = prop (PropName \"enctype\")\n\nnoValidate :: forall r i. Boolean -> IProp (noValidate :: Boolean | r) i\nnoValidate = prop (PropName \"noValidate\")\n\ntype_ :: forall r i value. IsProp value => value -> IProp (type :: value | r) i\ntype_ = prop (PropName \"type\")\n\nvalue :: forall r i value. IsProp value => value -> IProp (value :: value | r) i\nvalue = prop (PropName \"value\")\n\nmin :: forall r i. Number -> IProp (min :: Number | r) i\nmin = prop (PropName \"min\")\n\nmax :: forall r i. Number -> IProp (max :: Number | r) i\nmax = prop (PropName \"max\")\n\nstep :: forall r i. I.StepValue -> IProp (step :: I.StepValue | r) i\nstep = prop (PropName \"step\")\n\nenabled :: forall r i. Boolean -> IProp (disabled :: Boolean | r) i\nenabled = disabled <<< not\n\ndisabled :: forall r i. Boolean -> IProp (disabled :: Boolean | r) i\ndisabled = prop (PropName \"disabled\")\n\nrequired :: forall r i. Boolean -> IProp (required :: Boolean | r) i\nrequired = prop (PropName \"required\")\n\nreadOnly :: forall r i. Boolean -> IProp (readOnly :: Boolean | r) i\nreadOnly = prop (PropName \"readOnly\")\n\nspellcheck :: forall r i. Boolean -> IProp (spellcheck :: Boolean | r) i\nspellcheck = prop (PropName \"spellcheck\")\n\nchecked :: forall r i. Boolean -> IProp (checked :: Boolean | r) i\nchecked = prop (PropName \"checked\")\n\nselected :: forall r i. Boolean -> IProp (selected :: Boolean | r) i\nselected = prop (PropName \"selected\")\n\nselectedIndex :: forall r i. Int -> IProp (selectedIndex :: Int | r) i\nselectedIndex = prop (PropName \"selectedIndex\")\n\nplaceholder :: forall r i. String -> IProp (placeholder :: String | r) i\nplaceholder = prop (PropName \"placeholder\")\n\nautocomplete :: forall r i. I.AutocompleteType -> IProp (autocomplete :: I.AutocompleteType | r) i\nautocomplete = prop (PropName \"autocomplete\")\n\nlist :: forall r i. String -> IProp (list :: String | r) i\nlist = attr (AttrName \"list\")\n\nautofocus :: forall r i. Boolean -> IProp (autofocus :: Boolean | r) i\nautofocus = prop (PropName \"autofocus\")\n\nmultiple :: forall r i. Boolean -> IProp (multiple :: Boolean | r) i\nmultiple = prop (PropName \"multiple\")\n\naccept :: forall r i. I.InputAcceptType -> IProp (accept :: I.InputAcceptType | r) i\naccept = prop (PropName \"accept\")\n\npattern :: forall r i. String -> IProp (pattern :: String | r) i\npattern = prop (PropName \"pattern\")\n\nautoplay :: forall r i. Boolean -> IProp (autoplay :: Boolean | r) i\nautoplay = prop (PropName \"autoplay\")\n\ncontrols :: forall r i. Boolean -> IProp (controls :: Boolean | r) i\ncontrols = prop (PropName \"controls\")\n\nloop :: forall r i. Boolean -> IProp (loop :: Boolean | r) i\nloop = prop (PropName \"loop\")\n\nmuted :: forall r i. Boolean -> IProp (muted :: Boolean | r) i\nmuted = prop (PropName \"muted\")\n\nposter :: forall r i. String -> IProp (poster :: String | r) i\nposter = prop (PropName \"poster\")\n\npreload :: forall r i. I.PreloadValue -> IProp (preload :: I.PreloadValue | r) i\npreload = prop (PropName \"preload\")\n\ndraggable :: forall r i. Boolean -> IProp (draggable :: Boolean | r) i\ndraggable = prop (PropName \"draggable\")\n\ntabIndex :: forall r i. Int -> IProp (tabIndex :: Int | r) i\ntabIndex = prop (PropName \"tabIndex\")\n", "-- | `Application` houses functions and configuration that are shared between\n-- | all Gesso applications, regardless of the rendering component.\nmodule Gesso.Application\n  ( AppSpec\n  , InputReceiver\n  , OutputProducer\n  , RenderFunction\n  , TimestampedUpdate\n  , UpdateFunction\n  , WindowMode(..)\n  , defaultApp\n  ) where\n\nimport Prelude\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Gesso.Dimensions as D\nimport Gesso.Time as T\n\n-- | An `AppSpec` is a record consisting of the following fields:\n-- |\n-- | - `window` is a [`WindowMode`](#t:WindowMode) that defines how the screen\n-- |   element should size and position itself.\n-- | - `render` is a `[RenderFunction](#t:RenderFunction)` which defines what is\n-- |   drawn on the component.\n-- | - `update` is an `[UpdateFunction](#t:UpdateFunction)` which runs on each\n-- |   frame, just before `render`.\n-- | - `output` is an [`OutputProducer`](#t:OutputProducer) which defines how\n-- |   (or if) the component should send information out to the host\n-- |   application.\n-- | - `input` is an [`InputReceiver`](#t:InputReceiver) that defines how the\n-- |   state should change in response to receiving input from the host\n-- |   application.\ntype AppSpec context local input output =\n  { window :: WindowMode\n  , render :: RenderFunction context local\n  , update :: UpdateFunction local\n  , output :: OutputProducer local output\n  , input :: InputReceiver local input\n  }\n\n-- | A default [`AppSpec`](#t:AppSpec) which can be modified piecemeal like\n-- | Halogen's `EvalSpec`. It does nothing on its own.\ndefaultApp\n  :: forall context local input output\n   . AppSpec context local input output\ndefaultApp =\n  { window: Fixed D.sizeless\n  , render: \\_ _ _ _ -> pure unit\n  , update: \\_ _ _ -> pure Nothing\n  , output: \\_ _ _ _ -> pure Nothing\n  , input: \\_ _ _ _ -> pure Nothing\n  }\n\n-- | There are three modes that determine the size and position of a Gesso\n-- | canvas component:\n-- |\n-- | - `Fixed` creates a screen of the specified size\n-- | - `Stretch` expands to fill its containing element\n-- | - `FullScreen` takes up the entire page from the top left corner to the\n-- |   bottom right.\ndata WindowMode\n  = Fixed D.Size\n  | Stretch\n  | Fullscreen\n\n-- | An alias for a canvas rendering function.\n-- |\n-- | - `local` is the local state of the application\n-- | - `T.Delta` is a record containing current and previous timestamps and the\n-- |   time elapsed since the previous frame.\n-- | - `D.Scaler` is a record containg scaling functions for converting drawing\n-- |   coordinates to pixel coordinates.\n-- | - `context` is the context type for the canvas element, like `Context2D`\n-- |\n-- | The render function may run any operations in `Effect`, not just functions\n-- | related to drawing on the canvas.\ntype RenderFunction context local =\n  local -> T.Delta -> D.Scaler -> context -> Effect Unit\n\n-- | An `UpdateFunction` gets a `Delta` record from `Gesso.Time`, a `Scaler`\n-- | from `Gesso.Dimensions`, and the current local state, and may return an\n-- | updated local state if changes are necessary (or `Nothing` if there was no\n-- | change). This type is also used by Interaction handlers and when receiving\n-- | input from a host application.\ntype UpdateFunction local =\n  T.Delta -> TimestampedUpdate local\n\n-- | A partially applied [`UpdateFunction`](#t:UpdateFunction) that already has\n-- | a `Delta` record.\ntype TimestampedUpdate local =\n  D.Scaler -> local -> Effect (Maybe local)\n\n-- | An alias for a function that receives input from the host application and\n-- | produces an update function in response.\ntype InputReceiver local input = input -> UpdateFunction local\n\n-- | An alias for a function that compares old and new local states and may\n-- | send output based on the difference. The old state comes first and the new\n-- | state comes second.\ntype OutputProducer local output =\n  T.Delta -> D.Scaler -> local -> local -> Effect (Maybe output)\n", "export function canvasElementToImageSource(e) {\n  return e;\n}\n\nexport function tryLoadImageImpl(src) {\n  return function(e) {\n    return function(f) {\n      return function () {\n        var img = new Image();\n        img.src = src;\n        img.addEventListener(\"load\", function() {\n          f(img)();\n        }, false);\n        img.addEventListener(\"error\", function() {\n          e();\n        }, false);\n      };\n    };\n  };\n}\n\nexport function getCanvasElementByIdImpl(id, Just, Nothing) {\n  return function() {\n    var el = document.getElementById(id);\n    if (el && el instanceof HTMLCanvasElement) {\n      return Just(el);\n    } else {\n      return Nothing;\n    }\n  };\n}\n\nexport function getContext2D(c) {\n  return function() {\n    return c.getContext(\"2d\");\n  };\n}\n\nexport function getCanvasWidth(canvas) {\n  return function() {\n    return canvas.width;\n  };\n}\n\nexport function getCanvasHeight(canvas) {\n  return function() {\n    return canvas.height;\n  };\n}\n\nexport function setCanvasWidth(canvas) {\n  return function(width) {\n    return function() {\n      canvas.width = width;\n    };\n  };\n}\n\nexport function setCanvasHeight(canvas) {\n  return function(height) {\n    return function() {\n      canvas.height = height;\n    };\n  };\n}\n\nexport function canvasToDataURL(canvas) {\n  return function() {\n    return canvas.toDataURL();\n  };\n}\n\nexport function setLineWidth(ctx) {\n  return function(width) {\n    return function() {\n      ctx.lineWidth = width;\n    };\n  };\n}\n\nexport function setLineDash(ctx) {\n  return function(dash) {\n    return function() {\n      ctx.setLineDash(dash);\n    };\n  };\n}\n\nexport function setFillStyle(ctx) {\n  return function(style) {\n    return function() {\n      ctx.fillStyle = style;\n    };\n  };\n}\n\nexport function setStrokeStyle(ctx) {\n  return function(style) {\n    return function() {\n      ctx.strokeStyle = style;\n    };\n  };\n}\n\nexport function setShadowColor(ctx) {\n  return function(color) {\n    return function() {\n      ctx.shadowColor = color;\n    };\n  };\n}\n\nexport function setShadowBlur(ctx) {\n  return function(blur) {\n    return function() {\n      ctx.shadowBlur = blur;\n    };\n  };\n}\n\nexport function setShadowOffsetX(ctx) {\n  return function(offsetX) {\n    return function() {\n      ctx.shadowOffsetX = offsetX;\n    };\n  };\n}\n\nexport function setShadowOffsetY(ctx) {\n  return function(offsetY) {\n    return function() {\n      ctx.shadowOffsetY = offsetY;\n    };\n  };\n}\n\nexport function setMiterLimit(ctx) {\n  return function(limit) {\n    return function() {\n      ctx.miterLimit = limit;\n    };\n  };\n}\n\nexport function setLineCapImpl(ctx) {\n  return function(cap) {\n    return function() {\n      ctx.lineCap = cap;\n    };\n  };\n}\n\nexport function setLineJoinImpl(ctx) {\n  return function(join) {\n    return function() {\n      ctx.lineJoin = join;\n    };\n  };\n}\n\nexport function setGlobalCompositeOperationImpl(ctx) {\n  return function(op) {\n    return function() {\n      ctx.globalCompositeOperation = op;\n    };\n  };\n}\n\nexport function setGlobalAlpha(ctx) {\n  return function(alpha) {\n    return function() {\n      ctx.globalAlpha = alpha;\n    };\n  };\n}\n\nexport function beginPath(ctx) {\n  return function() {\n    ctx.beginPath();\n  };\n}\n\nexport function stroke(ctx) {\n  return function() {\n    ctx.stroke();\n  };\n}\n\nexport function fill(ctx) {\n  return function() {\n    ctx.fill();\n  };\n}\n\nexport function clip(ctx) {\n  return function() {\n    ctx.clip();\n  };\n}\n\nexport function lineTo(ctx) {\n  return function(x) {\n    return function(y) {\n      return function() {\n        ctx.lineTo(x, y);\n      };\n    };\n  };\n}\n\nexport function moveTo(ctx) {\n  return function(x) {\n    return function(y) {\n      return function() {\n        ctx.moveTo(x, y);\n      };\n    };\n  };\n}\n\nexport function closePath(ctx) {\n  return function() {\n    ctx.closePath();\n  };\n}\n\nexport function arc(ctx) {\n  return function(a) {\n    return function() {\n      ctx.arc(a.x, a.y, a.radius, a.start, a.end, a.useCounterClockwise);\n    };\n  };\n}\n\nexport function rect(ctx) {\n  return function(r) {\n    return function() {\n      ctx.rect(r.x, r.y, r.width, r.height);\n    };\n  };\n}\n\nexport function fillRect(ctx) {\n  return function(r) {\n    return function() {\n      ctx.fillRect(r.x, r.y, r.width, r.height);\n    };\n  };\n}\n\nexport function strokeRect(ctx) {\n  return function(r) {\n    return function() {\n      ctx.strokeRect(r.x, r.y, r.width, r.height);\n    };\n  };\n}\n\nexport function clearRect(ctx) {\n  return function(r) {\n    return function() {\n      ctx.clearRect(r.x, r.y, r.width, r.height);\n    };\n  };\n}\n\nexport function scale(ctx) {\n  return function(t) {\n    return function() {\n      ctx.scale(t.scaleX, t.scaleY);\n    };\n  };\n}\n\nexport function rotate(ctx) {\n  return function(angle) {\n    return function() {\n      ctx.rotate(angle);\n    };\n  };\n}\n\nexport function translate(ctx) {\n  return function(t) {\n    return function() {\n      ctx.translate(t.translateX, t.translateY);\n    };\n  };\n}\n\nexport function transform(ctx) {\n  return function(t) {\n    return function() {\n      ctx.transform(t.a, t.b, t.c, t.d, t.e, t.f);\n    };\n  };\n}\n\nexport function setTransform(ctx) {\n  return function(t) {\n    return function() {\n      ctx.setTransform(t.a, t.b, t.c, t.d, t.e, t.f);\n    };\n  };\n}\n\nexport function textAlignImpl(ctx) {\n  return function() {\n    return ctx.textAlign;\n  };\n}\n\nexport function setTextAlignImpl(ctx) {\n  return function(textAlign) {\n    return function() {\n      ctx.textAlign = textAlign;\n    };\n  };\n}\n\nexport function textBaselineImpl(ctx) {\n  return function () {\n    return ctx.textBaseline;\n  };\n}\n\nexport function setTextBaselineImpl(ctx) {\n  return function (textBaseline) {\n    return function () {\n      ctx.textBaseline = textBaseline;\n    };\n  };\n}\n\nexport function font(ctx) {\n  return function() {\n    return ctx.font;\n  };\n}\n\nexport function setFont(ctx) {\n  return function(fontspec) {\n    return function() {\n      ctx.font = fontspec;\n    };\n  };\n}\n\nexport function fillText(ctx) {\n  return function(text) {\n    return function(x) {\n      return function(y) {\n        return function() {\n          ctx.fillText(text, x, y);\n        };\n      };\n    };\n  };\n}\n\nexport function strokeText(ctx) {\n  return function(text) {\n    return function(x) {\n      return function(y) {\n        return function() {\n          ctx.strokeText(text, x, y);\n        };\n      };\n    };\n  };\n}\n\nexport function measureText(ctx) {\n  return function(text) {\n    return function() {\n      return ctx.measureText(text);\n    };\n  };\n}\n\nexport function save(ctx) {\n  return function() {\n    ctx.save();\n  };\n}\n\nexport function restore(ctx) {\n  return function() {\n    ctx.restore();\n  };\n}\n\nexport function imageDataWidth(image) {\n  return image.width;\n}\n\nexport function imageDataHeight(image) {\n  return image.height;\n}\n\nexport function imageDataBuffer(image) {\n  return image.data;\n}\n\nexport function getImageData(ctx) {\n  return function(x) {\n    return function(y) {\n      return function(w) {\n        return function(h) {\n          return function() {\n            return ctx.getImageData(x, y, w, h);\n          };\n        };\n      };\n    };\n  };\n}\n\nexport function putImageDataFull(ctx) {\n  return function(image_data) {\n    return function(x) {\n      return function(y) {\n        return function(dx) {\n          return function(dy) {\n            return function(dw) {\n              return function(dh) {\n                return function() {\n                  ctx.putImageData(image_data, x, y, dx, dy, dw, dh);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n}\n\nexport function putImageData(ctx) {\n  return function(image_data) {\n    return function(x) {\n      return function(y) {\n        return function() {\n          ctx.putImageData(image_data, x, y);\n        };\n      };\n    };\n  };\n}\n\nexport function createImageData(ctx) {\n  return function(sw) {\n    return function(sh) {\n      return function() {\n        return ctx.createImageData(sw, sh);\n      };\n    };\n  };\n}\n\nexport function createImageDataCopy(ctx) {\n  return function(image_data) {\n    return function() {\n      return ctx.createImageData(image_data);\n    };\n  };\n}\n\nexport function createImageDataWith(arr) {\n  return function(sw) {\n    return function() {\n      return new ImageData(arr, sw);\n    };\n  };\n}\n\nexport function drawImage(ctx) {\n  return function(image_source) {\n    return function(dx) {\n      return function(dy) {\n        return function() {\n          ctx.drawImage(image_source, dx, dy);\n        };\n      };\n    };\n  };\n}\n\nexport function drawImageScale(ctx) {\n  return function(image_source) {\n    return function(dx) {\n      return function(dy) {\n        return function(dWidth) {\n          return function(dHeight) {\n            return function() {\n              ctx.drawImage(image_source, dx, dy, dWidth, dHeight);\n            };\n          };\n        };\n      };\n    };\n  };\n}\n\nexport function drawImageFull(ctx) {\n  return function(image_source) {\n    return function(sx) {\n      return function(sy) {\n        return function(sWidth) {\n          return function(sHeight) {\n            return function(dx) {\n              return function(dy) {\n                return function(dWidth) {\n                  return function(dHeight) {\n                    return function() {\n                      ctx.drawImage(image_source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n}\n\nexport function createPatternImpl(ctx) {\n  return function(img) {\n    return function(repeat) {\n      return function() {\n        return ctx.createPattern(img, repeat);\n      };\n    };\n  };\n}\n\nexport function setPatternFillStyle(ctx) {\n  return function(pattern) {\n    return function() {\n      ctx.fillStyle = pattern;\n    };\n  };\n}\n\nexport function createLinearGradient(ctx) {\n  return function(linearGradient) {\n    return function() {\n      return ctx.createLinearGradient(linearGradient.x0, linearGradient.y0, linearGradient.x1, linearGradient.y1);\n    };\n  };\n}\n\nexport function createRadialGradient(ctx) {\n  return function(radialGradient) {\n    return function() {\n      return ctx.createRadialGradient(radialGradient.x0, radialGradient.y0, radialGradient.r0, radialGradient.x1, radialGradient.y1, radialGradient.r1);\n    };\n  };\n}\n\nexport function addColorStop(gradient) {\n  return function(stop) {\n    return function(color) {\n      return function() {\n        gradient.addColorStop(stop, color);\n      };\n    };\n  };\n}\n\nexport function setGradientFillStyle(ctx) {\n  return function(gradient) {\n    return function() {\n      ctx.fillStyle = gradient;\n    };\n  };\n}\n\nexport function quadraticCurveTo(ctx) {\n  return function(qCurve) {\n    return function() {\n      ctx.quadraticCurveTo(qCurve.cpx, qCurve.cpy, qCurve.x, qCurve.y);\n    };\n  };\n}\n\nexport function bezierCurveTo(ctx) {\n  return function(bCurve) {\n    return function() {\n      ctx.bezierCurveTo(bCurve.cp1x, bCurve.cp1y, bCurve.cp2x, bCurve.cp2y, bCurve.x, bCurve.y);\n    };\n  };\n}\n", "-- | This module defines foreign types and functions for working with the 2D\n-- | Canvas API.\n\nmodule Graphics.Canvas\n  ( CanvasElement\n  , Context2D\n  , ImageData\n  , CanvasImageSource\n  , Arc\n  , Composite(..)\n  , Dimensions\n  , LineCap(..)\n  , LineJoin(..)\n  , Rectangle\n  , ScaleTransform\n  , TextMetrics\n  , Transform\n  , TranslateTransform\n  , TextAlign(..)\n  , TextBaseline(..)\n  , CanvasPattern\n  , PatternRepeat(..)\n  , CanvasGradient\n  , LinearGradient\n  , RadialGradient\n  , QuadraticCurve\n  , BezierCurve\n\n  , getCanvasElementById\n  , getContext2D\n  , getCanvasWidth\n  , setCanvasWidth\n  , getCanvasHeight\n  , setCanvasHeight\n  , getCanvasDimensions\n  , setCanvasDimensions\n  , canvasToDataURL\n\n  , setLineWidth\n  , setLineDash\n  , setFillStyle\n  , setStrokeStyle\n  , setShadowBlur\n  , setShadowOffsetX\n  , setShadowOffsetY\n  , setShadowColor\n  , setMiterLimit\n\n  , setLineCap\n  , setLineJoin\n  , setGlobalCompositeOperation\n  , setGlobalAlpha\n\n  , beginPath\n  , stroke\n  , fill\n  , clip\n  , lineTo\n  , moveTo\n  , closePath\n  , strokePath\n  , fillPath\n\n  , arc\n\n  , rect\n  , fillRect\n  , strokeRect\n  , clearRect\n\n  , scale\n  , rotate\n  , translate\n  , transform\n  , setTransform\n\n  , textAlign\n  , setTextAlign\n  , textBaseline\n  , setTextBaseline\n  , font\n  , setFont\n  , fillText\n  , strokeText\n  , measureText\n\n  , save\n  , restore\n  , withContext\n\n  , tryLoadImage\n  , getImageData\n  , putImageData\n  , putImageDataFull\n  , createImageData\n  , createImageDataCopy\n  , createImageDataWith\n  , imageDataWidth\n  , imageDataHeight\n  , imageDataBuffer\n\n  , canvasElementToImageSource\n  , drawImage\n  , drawImageScale\n  , drawImageFull\n\n  , createPattern\n  , setPatternFillStyle\n\n  , createLinearGradient\n  , createRadialGradient\n  , addColorStop\n  , setGradientFillStyle\n\n  , quadraticCurveTo\n  , bezierCurveTo\n  ) where\n\nimport Prelude\n\nimport Effect (Effect)\nimport Effect.Exception.Unsafe (unsafeThrow)\nimport Data.ArrayBuffer.Types (Uint8ClampedArray)\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..))\n\n-- | A canvas HTML element.\nforeign import data CanvasElement :: Type\n\n-- | A 2D graphics context.\nforeign import data Context2D :: Type\n\n-- | An image data object, used to store raster data outside the canvas.\nforeign import data ImageData :: Type\n\n-- | Opaque object for drawing elements and things to the canvas.\nforeign import data CanvasImageSource :: Type\n\n-- | Opaque object describing a pattern.\nforeign import data CanvasPattern :: Type\n\n-- | Opaque object describing a gradient.\nforeign import data CanvasGradient :: Type\n\nforeign import canvasElementToImageSource :: CanvasElement -> CanvasImageSource\n\nforeign import tryLoadImageImpl\n  :: String\n  -> Effect Unit\n  -> (CanvasImageSource -> Effect Unit)\n  -> Effect Unit\n\n-- | Asynchronously load an image file by specifying its path.\ntryLoadImage\n  :: String\n  -> (Maybe CanvasImageSource -> Effect Unit)\n  -> Effect Unit\ntryLoadImage path k = tryLoadImageImpl path (k Nothing) (k <<< Just)\n\nforeign import getCanvasElementByIdImpl\n  :: forall r\n   . Fn3 String\n         (CanvasElement -> r)\n         r\n         (Effect r)\n\n-- | Get a canvas element by ID, or `Nothing` if the element does not exist.\ngetCanvasElementById :: String -> Effect (Maybe CanvasElement)\ngetCanvasElementById elId = runFn3 getCanvasElementByIdImpl elId Just Nothing\n\n-- | Get the 2D graphics context for a canvas element.\nforeign import getContext2D :: CanvasElement -> Effect Context2D\n\n-- | Get the canvas width in pixels.\nforeign import getCanvasWidth :: CanvasElement -> Effect Number\n\n-- | Get the canvas height in pixels.\nforeign import getCanvasHeight :: CanvasElement -> Effect Number\n\n-- | Set the canvas width in pixels.\nforeign import setCanvasWidth :: CanvasElement -> Number -> Effect Unit\n\n-- | Set the canvas height in pixels.\nforeign import setCanvasHeight :: CanvasElement -> Number -> Effect Unit\n\n-- | Canvas dimensions (width and height) in pixels.\ntype Dimensions = { width :: Number, height :: Number }\n\n-- | Get the canvas dimensions in pixels.\ngetCanvasDimensions :: CanvasElement -> Effect Dimensions\ngetCanvasDimensions ce = do\n  w <- getCanvasWidth  ce\n  h <- getCanvasHeight ce\n  pure {width : w, height : h}\n\n-- | Set the canvas dimensions in pixels.\nsetCanvasDimensions :: CanvasElement -> Dimensions -> Effect Unit\nsetCanvasDimensions ce d = setCanvasHeight ce d.height *> setCanvasWidth ce d.width\n\n-- | Create a data URL for the current canvas contents\nforeign import canvasToDataURL :: CanvasElement -> Effect String\n\n-- | Set the current line width.\nforeign import setLineWidth :: Context2D -> Number -> Effect Unit\n\n-- | Set the current line dash pattern.\nforeign import setLineDash :: Context2D -> Array Number -> Effect Unit\n\n-- | Set the current fill style/color.\nforeign import setFillStyle :: Context2D -> String -> Effect Unit\n\n-- | Set the current stroke style/color.\nforeign import setStrokeStyle :: Context2D -> String -> Effect Unit\n\n-- | Set the current shadow color.\nforeign import setShadowColor :: Context2D -> String -> Effect Unit\n\n-- | Set the current shadow blur radius.\nforeign import setShadowBlur :: Context2D -> Number -> Effect Unit\n\n-- | Set the current shadow x-offset.\nforeign import setShadowOffsetX :: Context2D -> Number -> Effect Unit\n\n-- | Set the current shadow y-offset.\nforeign import setShadowOffsetY :: Context2D -> Number -> Effect Unit\n\n-- | Set the current miter limit.\nforeign import setMiterLimit :: Context2D -> Number -> Effect Unit\n\n-- | Enumerates the different types of line cap.\ndata LineCap = Round | Square | Butt\n\nderive instance eqLineCap :: Eq LineCap\n\nforeign import setLineCapImpl :: Context2D -> String -> Effect Unit\n\n-- | Set the current line cap type.\nsetLineCap :: Context2D -> LineCap -> Effect Unit\nsetLineCap context Round  = setLineCapImpl context \"round\"\nsetLineCap context Square = setLineCapImpl context \"square\"\nsetLineCap context Butt   = setLineCapImpl context \"butt\"\n\n-- Note that we can't re-use `Round` from LineCap, so I've added `Join` to all of these\n\n-- | Enumerates the different types of line join\ndata LineJoin = BevelJoin | RoundJoin | MiterJoin\n\nderive instance eqLineJoin :: Eq LineJoin\n\nforeign import setLineJoinImpl :: Context2D -> String -> Effect Unit\n\n-- | Set the current line join type.\nsetLineJoin :: Context2D -> LineJoin -> Effect Unit\nsetLineJoin context BevelJoin = setLineJoinImpl context \"bevel\"\nsetLineJoin context RoundJoin = setLineJoinImpl context \"round\"\nsetLineJoin context MiterJoin = setLineJoinImpl context \"miter\"\n\n-- | Enumerates the different types of composite operations and blend modes.\ndata Composite\n  -- Composite Operations\n   = SourceOver\n   | SourceIn\n   | SourceOut\n   | SourceAtop\n   | DestinationOver\n   | DestinationIn\n   | DestinationOut\n   | DestinationAtop\n   | Lighter\n   | Copy\n   | Xor\n\n   -- Blend Modes\n   | Multiply\n   | Screen\n   | Overlay\n   | Darken\n   | Lighten\n   | ColorDodge\n   | ColorBurn\n   | HardLight\n   | SoftLight\n   | Difference\n   | Exclusion\n   | Hue\n   | Saturation\n   | Color\n   | Luminosity\n\nderive instance eqComposite :: Eq Composite\n\ninstance showComposite :: Show Composite where\n  show SourceOver      = \"SourceOver\"\n  show SourceIn        = \"SourceIn\"\n  show SourceOut       = \"SourceOut\"\n  show SourceAtop      = \"SourceAtop\"\n  show DestinationOver = \"DestinationOver\"\n  show DestinationIn   = \"DestinationIn\"\n  show DestinationOut  = \"DestinationOut\"\n  show DestinationAtop = \"DestinationAtop\"\n  show Lighter         = \"Lighter\"\n  show Copy            = \"Copy\"\n  show Xor             = \"Xor\"\n  show Multiply        = \"Multiply\"\n  show Screen          = \"Screen\"\n  show Overlay         = \"Overlay\"\n  show Darken          = \"Darken\"\n  show Lighten         = \"Lighten\"\n  show ColorDodge      = \"ColorDodge\"\n  show ColorBurn       = \"ColorBurn\"\n  show HardLight       = \"HardLight\"\n  show SoftLight       = \"SoftLight\"\n  show Difference      = \"Difference\"\n  show Exclusion       = \"Exclusion\"\n  show Hue             = \"Hue\"\n  show Saturation      = \"Saturation\"\n  show Color           = \"Color\"\n  show Luminosity      = \"Luminosity\"\n\nforeign import setGlobalCompositeOperationImpl :: Context2D -> String -> Effect Unit\n\n-- | Set the current composite operation.\nsetGlobalCompositeOperation :: Context2D -> Composite -> Effect Unit\nsetGlobalCompositeOperation ctx composite = setGlobalCompositeOperationImpl ctx (toString composite)\n  where\n    toString SourceOver      = \"source-over\"\n    toString SourceIn        = \"source-in\"\n    toString SourceOut       = \"source-out\"\n    toString SourceAtop      = \"source-atop\"\n    toString DestinationOver = \"destination-over\"\n    toString DestinationIn   = \"destination-in\"\n    toString DestinationOut  = \"destination-out\"\n    toString DestinationAtop = \"destination-atop\"\n    toString Lighter         = \"lighter\"\n    toString Copy            = \"copy\"\n    toString Xor             = \"xor\"\n    toString Multiply        = \"multiply\"\n    toString Screen          = \"screen\"\n    toString Overlay         = \"overlay\"\n    toString Darken          = \"darken\"\n    toString Lighten         = \"lighten\"\n    toString ColorDodge      = \"color-dodge\"\n    toString ColorBurn       = \"color-burn\"\n    toString HardLight       = \"hard-light\"\n    toString SoftLight       = \"soft-light\"\n    toString Difference      = \"difference\"\n    toString Exclusion       = \"exclusion\"\n    toString Hue             = \"hue\"\n    toString Saturation      = \"saturation\"\n    toString Color           = \"color\"\n    toString Luminosity      = \"luminosity\"\n\n-- | Set the current global alpha level.\nforeign import setGlobalAlpha :: Context2D -> Number -> Effect Unit\n\n-- | Begin a path object.\nforeign import beginPath :: Context2D -> Effect Unit\n\n-- | Stroke the current object.\nforeign import stroke :: Context2D -> Effect Unit\n\n-- | Fill the current object.\nforeign import fill :: Context2D -> Effect Unit\n\n-- | Clip to the current object.\nforeign import clip :: Context2D -> Effect Unit\n\n-- | Move the path to the specified coordinates, drawing a line segment.\nforeign import lineTo  :: Context2D -> Number -> Number -> Effect Unit\n\n-- | Move the path to the specified coordinates, without drawing a line segment.\nforeign import moveTo  :: Context2D -> Number -> Number -> Effect Unit\n\n-- | Close the current path.\nforeign import closePath  :: Context2D -> Effect Unit\n\n-- | A convenience function for drawing a stroked path.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | strokePath ctx $ do\n-- |   moveTo ctx 10.0 10.0\n-- |   lineTo ctx 20.0 20.0\n-- |   lineTo ctx 10.0 20.0\n-- |   closePath ctx\n-- | ```\nstrokePath :: forall a. Context2D -> Effect a -> Effect a\nstrokePath ctx path = do\n  _ <- beginPath ctx\n  a <- path\n  _ <- stroke ctx\n  pure a\n\n-- | A convenience function for drawing a filled path.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | fillPath ctx $ do\n-- |   moveTo ctx 10.0 10.0\n-- |   lineTo ctx 20.0 20.0\n-- |   lineTo ctx 10.0 20.0\n-- |   closePath ctx\n-- | ```\nfillPath :: forall a. Context2D -> Effect a -> Effect a\nfillPath ctx path = do\n  _ <- beginPath ctx\n  a <- path\n  _ <- fill ctx\n  pure a\n\n-- | A type representing an arc object:\n-- |\n-- | - The center coordinates `x` and `y`,\n-- | - The radius `r`,\n-- | - The starting and ending angles, `start` and `end`.\n-- | - Whether to draw the arc counter-clockwise (true) or clockwise (false) direction.\n-- |   Normally, this value is `false`.\ntype Arc =\n  { x :: Number\n  , y :: Number\n  , radius :: Number\n  , start :: Number\n  , end   :: Number\n  , useCounterClockwise :: Boolean\n  }\n\n-- | Render an arc object.\nforeign import arc :: Context2D -> Arc -> Effect Unit\n\n-- | A type representing a rectangle object:\n-- |\n-- | - The top-left corner coordinates `x` and `y`,\n-- | - The width and height `w` and `h`.\ntype Rectangle =\n  { x :: Number\n  , y :: Number\n  , width :: Number\n  , height :: Number\n  }\n\n-- | Render a rectangle.\nforeign import rect :: Context2D -> Rectangle -> Effect Unit\n\n-- | Fill a rectangle.\nforeign import fillRect :: Context2D -> Rectangle -> Effect Unit\n\n-- | Stroke a rectangle.\nforeign import strokeRect :: Context2D -> Rectangle -> Effect Unit\n\n-- | Clear a rectangle.\nforeign import clearRect :: Context2D -> Rectangle -> Effect Unit\n\n-- | An object representing a scaling transform:\n-- |\n-- | - The scale factors in the `x` and `y` directions, `scaleX` and `scaleY`.\ntype ScaleTransform =\n  { scaleX :: Number\n  , scaleY :: Number\n  }\n\n-- | Apply a scaling transform.\nforeign import scale  :: Context2D -> ScaleTransform -> Effect Unit\n\n-- | Apply a rotation.\nforeign import rotate :: Context2D -> Number -> Effect Unit\n\n-- | An object representing a translation:\n-- |\n-- | - The translation amounts in the `x` and `y` directions, `translateX` and `translateY`.\ntype TranslateTransform =\n  { translateX :: Number\n  , translateY :: Number\n  }\n\n-- | Apply a translation\nforeign import translate :: Context2D -> TranslateTransform -> Effect Unit\n\n-- | An object representing a general transformation as a homogeneous matrix.\ntype Transform =\n  { a :: Number\n  , b :: Number\n  , c :: Number\n  , d :: Number\n  , e :: Number\n  , f :: Number\n  }\n\n-- | Apply a general transformation to the current transformation matrix\nforeign import transform :: Context2D -> Transform -> Effect Unit\n\n-- | Set the transformation matrix\nforeign import setTransform :: Context2D -> Transform -> Effect Unit\n\n-- | Enumerates types of text alignment.\ndata TextAlign\n  = AlignLeft | AlignRight | AlignCenter | AlignStart | AlignEnd\n\nderive instance eqTextAlign :: Eq TextAlign\n\ninstance showTextAlign :: Show TextAlign where\n  show AlignLeft = \"AlignLeft\"\n  show AlignRight = \"AlignRight\"\n  show AlignCenter = \"AlignCenter\"\n  show AlignStart = \"AlignStart\"\n  show AlignEnd = \"AlignEnd\"\n\nforeign import textAlignImpl :: Context2D -> Effect String\n\n-- | Get the current text alignment.\ntextAlign :: Context2D -> Effect TextAlign\ntextAlign ctx = unsafeParseTextAlign <$> textAlignImpl ctx\n  where\n  unsafeParseTextAlign :: String -> TextAlign\n  unsafeParseTextAlign \"left\" = AlignLeft\n  unsafeParseTextAlign \"right\" = AlignRight\n  unsafeParseTextAlign \"center\" = AlignCenter\n  unsafeParseTextAlign \"start\" = AlignStart\n  unsafeParseTextAlign \"end\" = AlignEnd\n  unsafeParseTextAlign align = unsafeThrow $ \"invalid TextAlign: \" <> align\n  -- ^ dummy to silence compiler warnings\n\nforeign import setTextAlignImpl :: Context2D -> String -> Effect Unit\n\n-- | Set the current text alignment.\nsetTextAlign :: Context2D -> TextAlign -> Effect Unit\nsetTextAlign ctx textalign =\n  setTextAlignImpl ctx (toString textalign)\n  where\n    toString AlignLeft = \"left\"\n    toString AlignRight = \"right\"\n    toString AlignCenter = \"center\"\n    toString AlignStart = \"start\"\n    toString AlignEnd = \"end\"\n\n-- | Enumerates types of text baseline.\ndata TextBaseline\n  = BaselineTop\n  | BaselineHanging\n  | BaselineMiddle\n  | BaselineAlphabetic\n  | BaselineIdeographic\n  | BaselineBottom\n\ninstance showTextBaseline :: Show TextBaseline where\n  show BaselineTop = \"BaselineTop\"\n  show BaselineHanging = \"BaselineHanging\"\n  show BaselineMiddle = \"BaselineMiddle\"\n  show BaselineAlphabetic = \"BaselineAlphabetic\"\n  show BaselineIdeographic = \"BaselineIdeographic\"\n  show BaselineBottom = \"BaselineBottom\"\n\nforeign import textBaselineImpl :: Context2D -> Effect String\n\n-- | Get the current text baseline.\ntextBaseline :: Context2D -> Effect TextBaseline\ntextBaseline ctx = unsafeParseTextBaseline <$> textBaselineImpl ctx\n  where\n  unsafeParseTextBaseline :: String -> TextBaseline\n  unsafeParseTextBaseline \"top\" = BaselineTop\n  unsafeParseTextBaseline \"hanging\" = BaselineHanging\n  unsafeParseTextBaseline \"middle\" = BaselineMiddle\n  unsafeParseTextBaseline \"alphabetic\" = BaselineAlphabetic\n  unsafeParseTextBaseline \"ideographic\" = BaselineIdeographic\n  unsafeParseTextBaseline \"bottom\" = BaselineBottom\n  unsafeParseTextBaseline align = unsafeThrow $ \"invalid TextBaseline: \" <> align\n  -- ^ dummy to silence compiler warnings\n\nforeign import setTextBaselineImpl :: Context2D -> String -> Effect Unit\n\n-- | Set the current text baseline.\nsetTextBaseline :: Context2D -> TextBaseline -> Effect Unit\nsetTextBaseline ctx textbaseline =\n  setTextBaselineImpl ctx (toString textbaseline)\n  where\n    toString BaselineTop = \"top\"\n    toString BaselineHanging = \"hanging\"\n    toString BaselineMiddle = \"middle\"\n    toString BaselineAlphabetic = \"alphabetic\"\n    toString BaselineIdeographic = \"ideographic\"\n    toString BaselineBottom = \"bottom\"\n\n-- | Text metrics:\n-- |\n-- | - The text width in pixels.\ntype TextMetrics = { width :: Number }\n\n-- | Get the current font.\nforeign import font :: Context2D -> Effect String\n\n-- | Set the current font.\nforeign import setFont :: Context2D -> String -> Effect Unit\n\n-- | Fill some text.\nforeign import fillText :: Context2D -> String -> Number -> Number -> Effect Unit\n\n-- | Stroke some text.\nforeign import strokeText :: Context2D -> String -> Number -> Number -> Effect Unit\n\n-- | Measure some text.\nforeign import measureText :: Context2D -> String -> Effect TextMetrics\n\n-- | Save the current context.\nforeign import save  :: Context2D -> Effect Unit\n\n-- | Restore the previous context.\nforeign import restore  :: Context2D -> Effect Unit\n\n-- | A convenience function: run the action, preserving the existing context.\n-- |\n-- | For example, outside this block, the fill style is preseved:\n-- |\n-- | ```purescript\n-- | withContext ctx $ do\n-- |   setFillStyle ctx \"red\"\n-- |   ...\n-- | ```\nwithContext :: forall a. Context2D -> Effect a -> Effect a\nwithContext ctx action = do\n  _ <- save ctx\n  a <- action\n  _ <- restore ctx\n  pure a\n\n-- | Get image data for a portion of the canvas.\nforeign import getImageData :: Context2D -> Number -> Number -> Number -> Number -> Effect ImageData\n\n-- | Set image data for a portion of the canvas.\nforeign import putImageDataFull :: Context2D -> ImageData -> Number -> Number -> Number -> Number -> Number -> Number -> Effect Unit\n\n-- | Set image data for a portion of the canvas.\nforeign import putImageData :: Context2D -> ImageData -> Number -> Number -> Effect Unit\n\n-- | Create an image data object.\nforeign import createImageData :: Context2D -> Number -> Number -> Effect ImageData\n\n-- | Create a copy of an image data object.\nforeign import createImageDataCopy :: Context2D -> ImageData -> Effect ImageData\n\n-- | Create an image data object given a `Uint8ClampedArray` containing the underlying pixel representation of the image.\n-- | The height is inferred from the array's size and the given width.\nforeign import createImageDataWith :: Uint8ClampedArray -> Int -> Effect ImageData\n\n-- | Get the width of an `ImageData` object.\nforeign import imageDataWidth :: ImageData -> Int\n\n-- | Get the height of an `ImageData` object.\nforeign import imageDataHeight :: ImageData -> Int\n\n-- | Get the underlying buffer from an `ImageData` object.\nforeign import imageDataBuffer :: ImageData -> Uint8ClampedArray\n\nforeign import drawImage :: Context2D -> CanvasImageSource -> Number -> Number -> Effect Unit\n\nforeign import drawImageScale :: Context2D -> CanvasImageSource -> Number -> Number -> Number -> Number -> Effect Unit\n\nforeign import drawImageFull :: Context2D -> CanvasImageSource -> Number -> Number -> Number -> Number -> Number -> Number -> Number -> Number -> Effect Unit\n\n-- | Enumerates the different types of pattern repetitions.\ndata PatternRepeat = Repeat | RepeatX | RepeatY | NoRepeat\n\nderive instance eqPatternRepeat :: Eq PatternRepeat\n\ninstance showPatternRepeat :: Show PatternRepeat where\n  show Repeat = \"Repeat\"\n  show RepeatX = \"RepeatX\"\n  show RepeatY = \"RepeatY\"\n  show NoRepeat = \"NoRepeat\"\n\nforeign import createPatternImpl :: Context2D -> CanvasImageSource -> String ->  Effect CanvasPattern\n\n-- | Create a new canvas pattern (repeatable image).\ncreatePattern :: Context2D -> CanvasImageSource -> PatternRepeat -> Effect CanvasPattern\ncreatePattern context img repeat = createPatternImpl context img (toString repeat)\n  where\n    toString Repeat = \"repeat\"\n    toString RepeatX = \"repeat-x\"\n    toString RepeatY = \"repeat-y\"\n    toString NoRepeat = \"no-repeat\"\n\n-- | Set the Context2D fillstyle to the CanvasPattern.\nforeign import setPatternFillStyle :: Context2D -> CanvasPattern -> Effect Unit\n\n-- | A type representing a linear gradient.\n-- |  -  Starting point coordinates: (`x0`, `y0`)\n-- |  -  Ending point coordinates: (`x1`, `y1`)\n\ntype LinearGradient =\n    { x0 :: Number\n    , y0 :: Number\n    , x1 :: Number\n    , y1 :: Number\n    }\n\n-- | Create a linear CanvasGradient.\nforeign import createLinearGradient :: Context2D -> LinearGradient -> Effect CanvasGradient\n\n-- | A type representing a radial gradient.\n-- |  -  Starting circle center coordinates: (`x0`, `y0`)\n-- |  -  Starting circle radius: `r0`\n-- |  -  Ending circle center coordinates: (`x1`, `y1`)\n-- |  -  Ending circle radius: `r1`\n\ntype RadialGradient =\n    { x0 :: Number\n    , y0 :: Number\n    , r0 :: Number\n    , x1 :: Number\n    , y1 :: Number\n    , r1 :: Number\n    }\n\n-- | Create a radial CanvasGradient.\nforeign import createRadialGradient :: Context2D -> RadialGradient -> Effect CanvasGradient\n\n-- | Add a single color stop to a CanvasGradient.\nforeign import addColorStop :: CanvasGradient -> Number -> String -> Effect Unit\n\n-- | Set the Context2D fillstyle to the CanvasGradient.\nforeign import setGradientFillStyle :: Context2D -> CanvasGradient -> Effect Unit\n\n-- | A type representing a quadratic B\u00E9zier curve.\n-- |  - B\u00E9zier control point: (`cpx`, `cpy`)\n-- |  - Ending point coordinates: (`x`, `y`)\n\ntype QuadraticCurve =\n    { cpx :: Number\n    , cpy :: Number\n    , x   :: Number\n    , y   :: Number\n    }\n\n-- | Draw a quadratic B\u00E9zier curve.\nforeign import quadraticCurveTo :: Context2D -> QuadraticCurve -> Effect Unit\n\n-- | A type representing a cubic B\u00E9zier curve.\n-- |  - First B\u00E9zier control point: (`cp1x`, `cp1y`)\n-- |  - Second B\u00E9zier control point: (`cp2x`, `cp2y`)\n-- |  - Ending point: (`x`, `y`)\n\ntype BezierCurve =\n    { cp1x :: Number\n    , cp1y :: Number\n    , cp2x :: Number\n    , cp2y :: Number\n    , x    :: Number\n    , y    :: Number\n    }\n\n-- | Draw a cubic B\u00E9zier curve.\nforeign import bezierCurveTo :: Context2D -> BezierCurve -> Effect Unit\n", "export function _getElementById(id) {\n  return function (node) {\n    return function () {\n      return node.getElementById(id);\n    };\n  };\n}\n", "module Web.DOM.NonElementParentNode\n  ( NonElementParentNode\n  , getElementById\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Web.DOM.Element (Element)\n\nforeign import data NonElementParentNode :: Type\n\n-- | The first element within node's descendants with a matching ID, or null if\n-- | no such element exists.\nforeign import _getElementById :: String -> NonElementParentNode -> Effect (Nullable Element)\n\ngetElementById :: String -> NonElementParentNode -> Effect (Maybe Element)\ngetElementById eid = map toMaybe <<< _getElementById eid\n", "const windowImpl = function () {\n  return window;\n};\nexport { windowImpl as window };\n", "export function _documentElement(doc) {\n  return doc.documentElement;\n}\n\nexport function _head(doc) {\n  return doc.head;\n}\n\nexport function _body(doc) {\n  return doc.body;\n}\n\nexport function _readyState(doc) {\n  return doc.readyState;\n}\n\nexport function _visibilityState(doc) {\n  return doc.readyState;\n}\n\nexport function _activeElement(doc) {\n  return doc.activeElement;\n}\n\nexport function _currentScript(doc) {\n  return doc.currentScript;\n}\n\nexport function _referrer(doc) {\n  return doc.referrer;\n}\n\nexport function _title(doc) {\n  return doc.title;\n}\n\nexport function _setTitle(title, doc) {\n  doc.title = title;\n}\n", "module Web.HTML.HTMLDocument.ReadyState where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..))\n\ndata ReadyState\n  = Loading\n  | Interactive\n  | Complete\n\nderive instance eqReadyState :: Eq ReadyState\nderive instance ordReadyState :: Ord ReadyState\n\ninstance showReadyState :: Show ReadyState where\n  show = case _ of\n    Loading -> \"Loading\"\n    Interactive -> \"Interactive\"\n    Complete -> \"Complete\"\n\nprint :: ReadyState -> String\nprint = case _ of\n  Loading -> \"loading\"\n  Interactive -> \"interactive\"\n  Complete -> \"complete\"\n\nparse :: String -> Maybe ReadyState\nparse = case _ of\n  \"loading\" -> Just Loading\n  \"interactive\" -> Just Interactive\n  \"complete\" -> Just Complete\n  _ -> Nothing\n", "export function _read(nothing, just, value) {\n  var tag = Object.prototype.toString.call(value);\n  if (tag.indexOf(\"[object HTML\") === 0 && tag.indexOf(\"Element]\") === tag.length - 8) {\n    return just(value);\n  } else {\n    return nothing;\n  }\n}\n\n// ----------------------------------------------------------------------------\n\nexport function title(elt) {\n  return function () {\n    return elt.title;\n  };\n}\n\nexport function setTitle(title) {\n  return function (elt) {\n    return function () {\n      elt.title = title;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function lang(elt) {\n  return function () {\n    return elt.lang;\n  };\n}\n\nexport function setLang(lang) {\n  return function (elt) {\n    return function () {\n      elt.lang = lang;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function dir(elt) {\n  return function () {\n    return elt.dir;\n  };\n}\n\nexport function setDir(dir) {\n  return function (elt) {\n    return function () {\n      elt.dir = dir;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function hidden(elt) {\n  return function () {\n    return elt.hidden;\n  };\n}\n\nexport function setHidden(hidden) {\n  return function (elt) {\n    return function () {\n      elt.hidden = hidden;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function tabIndex(elt) {\n  return function () {\n    return elt.tabIndex;\n  };\n}\n\nexport function setTabIndex(tabIndex) {\n  return function (elt) {\n    return function () {\n      elt.tabIndex = tabIndex;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function draggable(elt) {\n  return function () {\n    return elt.draggable;\n  };\n}\n\nexport function setDraggable(draggable) {\n  return function (elt) {\n    return function () {\n      elt.draggable = draggable;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function contentEditable(elt) {\n  return function () {\n    return elt.contentEditable;\n  };\n}\n\nexport function setContentEditable(contentEditable) {\n  return function (elt) {\n    return function () {\n      elt.contentEditable = contentEditable;\n    };\n  };\n}\n\nexport function isContentEditable(elt) {\n  return function () {\n    return elt.isContentEditable;\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function spellcheck(elt) {\n  return function () {\n    return elt.spellcheck;\n  };\n}\n\nexport function setSpellcheck(spellcheck) {\n  return function (elt) {\n    return function () {\n      elt.spellcheck = spellcheck;\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function click(elt) {\n  return function () {\n    return elt.click();\n  };\n}\n\nexport function focus(elt) {\n  return function () {\n    return elt.focus();\n  };\n}\n\nexport function blur(elt) {\n  return function () {\n    return elt.blur();\n  };\n}\n\n// - CSSOM ---------------------------------------------------------------------\n\nexport function _offsetParent(el) {\n  return function () {\n    return el.offsetParent;\n  };\n}\n\nexport function offsetTop(el) {\n  return function () {\n    return el.offsetTop;\n  };\n}\n\nexport function offsetLeft(el) {\n  return function () {\n    return el.offsetLeft;\n  };\n}\n\nexport function offsetWidth(el) {\n  return function () {\n    return el.offsetWidth;\n  };\n}\n\nexport function offsetHeight(el) {\n  return function () {\n    return el.offsetHeight;\n  };\n}\n", "module Web.HTML.HTMLElement\n  ( HTMLElement\n  , fromElement\n  , fromNode\n  , fromChildNode\n  , fromNonDocumentTypeChildNode\n  , fromParentNode\n  , fromEventTarget\n  , toElement\n  , toNode\n  , toChildNode\n  , toNonDocumentTypeChildNode\n  , toParentNode\n  , toEventTarget\n  , title\n  , setTitle\n  , lang\n  , setLang\n  , dir\n  , setDir\n  , hidden\n  , setHidden\n  , tabIndex\n  , setTabIndex\n  , draggable\n  , setDraggable\n  , contentEditable\n  , setContentEditable\n  , isContentEditable\n  , spellcheck\n  , setSpellcheck\n  , click\n  , focus\n  , blur\n  , offsetParent\n  , offsetTop\n  , offsetLeft\n  , offsetWidth\n  , offsetHeight\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..))\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (ChildNode)\nimport Web.DOM.Element (Element)\nimport Web.DOM.Internal.Types (Node)\nimport Web.DOM.NonDocumentTypeChildNode (NonDocumentTypeChildNode)\nimport Web.DOM.ParentNode (ParentNode)\nimport Web.Event.EventTarget (EventTarget)\n\nforeign import data HTMLElement :: Type\n\nforeign import _read :: forall a. Fn3 (forall x. Maybe x) (forall x. x -> Maybe x) a (Maybe HTMLElement)\n\nfromElement :: Element -> Maybe HTMLElement\nfromElement x = runFn3 _read Nothing Just x\n\nfromNode :: Node -> Maybe HTMLElement\nfromNode x = runFn3 _read Nothing Just x\n\nfromChildNode :: ChildNode -> Maybe HTMLElement\nfromChildNode x = runFn3 _read Nothing Just x\n\nfromNonDocumentTypeChildNode :: NonDocumentTypeChildNode -> Maybe HTMLElement\nfromNonDocumentTypeChildNode x = runFn3 _read Nothing Just x\n\nfromParentNode :: ParentNode -> Maybe HTMLElement\nfromParentNode x = runFn3 _read Nothing Just x\n\nfromEventTarget :: EventTarget -> Maybe HTMLElement\nfromEventTarget x = runFn3 _read Nothing Just x\n\ntoElement :: HTMLElement -> Element\ntoElement = unsafeCoerce\n\ntoNode :: HTMLElement -> Node\ntoNode = unsafeCoerce\n\ntoChildNode :: HTMLElement -> ChildNode\ntoChildNode = unsafeCoerce\n\ntoNonDocumentTypeChildNode :: HTMLElement -> NonDocumentTypeChildNode\ntoNonDocumentTypeChildNode = unsafeCoerce\n\ntoParentNode :: HTMLElement -> ParentNode\ntoParentNode = unsafeCoerce\n\ntoEventTarget :: HTMLElement -> EventTarget\ntoEventTarget = unsafeCoerce\n\nforeign import title :: HTMLElement -> Effect String\nforeign import setTitle :: String -> HTMLElement -> Effect Unit\n\nforeign import lang :: HTMLElement -> Effect String\nforeign import setLang :: String -> HTMLElement -> Effect Unit\n\nforeign import dir :: HTMLElement -> Effect String\nforeign import setDir :: String -> HTMLElement -> Effect Unit\n\nforeign import hidden :: HTMLElement -> Effect Boolean\nforeign import setHidden :: Boolean -> HTMLElement -> Effect Unit\n\nforeign import tabIndex :: HTMLElement -> Effect Int\nforeign import setTabIndex :: Int -> HTMLElement -> Effect Unit\n\nforeign import draggable :: HTMLElement -> Effect Boolean\nforeign import setDraggable :: Boolean -> HTMLElement -> Effect Unit\n\nforeign import contentEditable :: HTMLElement -> Effect String\nforeign import setContentEditable :: String -> HTMLElement -> Effect Unit\nforeign import isContentEditable :: HTMLElement -> Effect Boolean\n\nforeign import spellcheck :: HTMLElement -> Effect Boolean\nforeign import setSpellcheck :: Boolean -> HTMLElement -> Effect Unit\n\nforeign import click :: HTMLElement -> Effect Unit\nforeign import focus :: HTMLElement -> Effect Unit\nforeign import blur :: HTMLElement -> Effect Unit\n\nforeign import _offsetParent :: HTMLElement -> Effect (Nullable Element)\n\noffsetParent :: HTMLElement -> Effect (Maybe Element)\noffsetParent = map toMaybe <<< _offsetParent\n\nforeign import offsetTop :: HTMLElement -> Effect Number\nforeign import offsetLeft :: HTMLElement -> Effect Number\nforeign import offsetWidth :: HTMLElement -> Effect Number\nforeign import offsetHeight :: HTMLElement -> Effect Number\n", "export const mkEffectFn1 = function mkEffectFn1(fn) {\n  return function(x) {\n    return fn(x)();\n  };\n};\n\nexport const mkEffectFn2 = function mkEffectFn2(fn) {\n  return function(a, b) {\n    return fn(a)(b)();\n  };\n};\n\nexport const mkEffectFn3 = function mkEffectFn3(fn) {\n  return function(a, b, c) {\n    return fn(a)(b)(c)();\n  };\n};\n\nexport const mkEffectFn4 = function mkEffectFn4(fn) {\n  return function(a, b, c, d) {\n    return fn(a)(b)(c)(d)();\n  };\n};\n\nexport const mkEffectFn5 = function mkEffectFn5(fn) {\n  return function(a, b, c, d, e) {\n    return fn(a)(b)(c)(d)(e)();\n  };\n};\n\nexport const mkEffectFn6 = function mkEffectFn6(fn) {\n  return function(a, b, c, d, e, f) {\n    return fn(a)(b)(c)(d)(e)(f)();\n  };\n};\n\nexport const mkEffectFn7 = function mkEffectFn7(fn) {\n  return function(a, b, c, d, e, f, g) {\n    return fn(a)(b)(c)(d)(e)(f)(g)();\n  };\n};\n\nexport const mkEffectFn8 = function mkEffectFn8(fn) {\n  return function(a, b, c, d, e, f, g, h) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)();\n  };\n};\n\nexport const mkEffectFn9 = function mkEffectFn9(fn) {\n  return function(a, b, c, d, e, f, g, h, i) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)();\n  };\n};\n\nexport const mkEffectFn10 = function mkEffectFn10(fn) {\n  return function(a, b, c, d, e, f, g, h, i, j) {\n    return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)();\n  };\n};\n\nexport const runEffectFn1 = function runEffectFn1(fn) {\n  return function(a) {\n    return function() {\n      return fn(a);\n    };\n  };\n};\n\nexport const runEffectFn2 = function runEffectFn2(fn) {\n  return function(a) {\n    return function(b) {\n      return function() {\n        return fn(a, b);\n      };\n    };\n  };\n};\n\nexport const runEffectFn3 = function runEffectFn3(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function() {\n          return fn(a, b, c);\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn4 = function runEffectFn4(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function() {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn5 = function runEffectFn5(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function() {\n              return fn(a, b, c, d, e);\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn6 = function runEffectFn6(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function() {\n                return fn(a, b, c, d, e, f);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn7 = function runEffectFn7(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function() {\n                  return fn(a, b, c, d, e, f, g);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn8 = function runEffectFn8(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function() {\n                    return fn(a, b, c, d, e, f, g, h);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn9 = function runEffectFn9(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function() {\n                      return fn(a, b, c, d, e, f, g, h, i);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n\nexport const runEffectFn10 = function runEffectFn10(fn) {\n  return function(a) {\n    return function(b) {\n      return function(c) {\n        return function(d) {\n          return function(e) {\n            return function(f) {\n              return function(g) {\n                return function(h) {\n                  return function(i) {\n                    return function(j) {\n                      return function() {\n                        return fn(a, b, c, d, e, f, g, h, i, j);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n};\n", "export function document(window) {\n  return function () {\n    return window.document;\n  };\n}\n\nexport function navigator(window) {\n  return function () {\n    return window.navigator;\n  };\n}\n\nexport function location(window) {\n  return function () {\n    return window.location;\n  };\n}\n\nexport function history(window) {\n  return function() {\n    return window.history;\n  };\n}\n\nexport function innerWidth(window) {\n  return function () {\n    return window.innerWidth;\n  };\n}\n\nexport function innerHeight(window) {\n  return function () {\n    return window.innerHeight;\n  };\n}\n\nexport function alert(str) {\n  return function (window) {\n    return function () {\n      window.alert(str);\n    };\n  };\n}\n\nexport function confirm(str) {\n  return function (window) {\n    return function () {\n      return window.confirm(str);\n    };\n  };\n}\n\nexport function moveBy(xDelta) {\n  return function (yDelta) {\n    return function (window) {\n      return function () {\n        window.moveBy(xDelta, yDelta);\n      };\n    };\n  };\n}\n\nexport function moveTo(width) {\n  return function (height) {\n    return function (window) {\n      return function () {\n        window.moveTo(width, height);\n      };\n    };\n  };\n}\n\nexport function _open(url) {\n  return function (name) {\n    return function (features) {\n      return function (window) {\n        return function () {\n          return window.open(url, name, features);\n        };\n      };\n    };\n  };\n}\n\nexport function close(window) {\n  return function () {\n    return window.close();\n  };\n}\n\nexport function outerHeight(window) {\n  return function () {\n    return window.outerHeight;\n  };\n}\n\nexport function outerWidth(window) {\n  return function () {\n    return window.outerWidth;\n  };\n}\n\nexport function print(window) {\n  return function () {\n    window.print();\n  };\n}\n\nexport function _prompt(str) {\n  return function (defaultText) {\n    return function (window) {\n      return function () {\n        return window.prompt(str, defaultText);\n      };\n    };\n  };\n}\n\nexport function resizeBy(xDelta) {\n  return function (yDelta) {\n    return function (window) {\n      return function () {\n        window.resizeBy(xDelta, yDelta);\n      };\n    };\n  };\n}\n\nexport function resizeTo(width) {\n  return function (height) {\n    return function (window) {\n      return function () {\n        window.resizeTo(width, height);\n      };\n    };\n  };\n}\n\nexport function screenX(window) {\n  return function () {\n    return window.screenX;\n  };\n}\n\nexport function screenY(window) {\n  return function () {\n    return window.screenY;\n  };\n}\n\nexport function scroll(xCoord) {\n  return function (yCoord) {\n    return function (window) {\n      return function () {\n        window.scroll(xCoord, yCoord);\n      };\n    };\n  };\n}\n\nexport function scrollBy(xCoord) {\n  return function (yCoord) {\n    return function (window) {\n      return function () {\n        window.scrollBy(xCoord, yCoord);\n      };\n    };\n  };\n}\n\nexport function scrollX(window) {\n  return function () {\n    return window.scrollX;\n  };\n}\n\nexport function scrollY(window) {\n  return function () {\n    return window.scrollY;\n  };\n}\n\nexport function localStorage(window) {\n  return function () {\n    return window.localStorage;\n  };\n}\n\nexport function sessionStorage(window) {\n  return function () {\n    return window.sessionStorage;\n  };\n}\n\nexport function requestAnimationFrame(fn) {\n  return function(window) {\n    return function() {\n      return window.requestAnimationFrame(fn);\n    };\n  };\n}\n\nexport function cancelAnimationFrame(id) {\n  return function(window) {\n    return function() {\n      return window.cancelAnimationFrame(id);\n    };\n  };\n}\n\nexport function requestIdleCallback(opts) {\n  return function(fn) {\n    return function(window) {\n      return function() {\n        return window.requestIdleCallback(fn, opts);\n      };\n    };\n  };\n}\n\nexport function cancelIdleCallback(id) {\n  return function(window) {\n    return function() {\n      return window.cancelIdleCallback(id);\n    };\n  };\n}\n\nexport function parent(window) {\n  return function() {\n    return window.parent;\n  };\n}\n\nexport function _opener(window) {\n  return function() {\n    return window.opener;\n  };\n}\n", "module Web.HTML.Window\n  ( Window\n  , toEventTarget\n  , fromEventTarget\n  , document\n  , navigator\n  , location\n  , history\n  , innerWidth\n  , innerHeight\n  , alert\n  , confirm\n  , moveBy\n  , moveTo\n  , open\n  , close\n  , outerHeight\n  , outerWidth\n  , print\n  , prompt\n  , promptDefault\n  , resizeBy\n  , resizeTo\n  , screenX\n  , screenY\n  , scroll\n  , scrollBy\n  , scrollX\n  , scrollY\n  , localStorage\n  , sessionStorage\n  , requestAnimationFrame\n  , cancelAnimationFrame\n  , RequestAnimationFrameId\n  , requestIdleCallback\n  , cancelIdleCallback\n  , RequestIdleCallbackId\n  , parent\n  , opener\n  ) where\n\nimport Data.Maybe (Maybe)\nimport Data.Nullable (Nullable, toMaybe)\nimport Effect (Effect)\nimport Prelude (class Eq, class Ord, Unit, (<$>))\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.Event.EventTarget (EventTarget)\nimport Web.HTML.HTMLDocument (HTMLDocument)\nimport Web.HTML.History (History)\nimport Web.HTML.Location (Location)\nimport Web.HTML.Navigator (Navigator)\nimport Web.Internal.FFI (unsafeReadProtoTagged)\nimport Web.Storage.Storage (Storage)\n\nforeign import data Window :: Type\n\ntoEventTarget :: Window -> EventTarget\ntoEventTarget = unsafeCoerce\n\nfromEventTarget :: EventTarget -> Maybe Window\nfromEventTarget = unsafeReadProtoTagged \"Window\"\n\nforeign import document :: Window -> Effect HTMLDocument\n\nforeign import navigator :: Window -> Effect Navigator\n\nforeign import location :: Window -> Effect Location\n\nforeign import history :: Window -> Effect History\n\nforeign import innerWidth :: Window -> Effect Int\n\nforeign import innerHeight :: Window -> Effect Int\n\nforeign import alert :: String -> Window -> Effect Unit\n\nforeign import confirm :: String -> Window -> Effect Boolean\n\nforeign import moveBy :: Int -> Int -> Window -> Effect Unit\n\nforeign import moveTo :: Int -> Int -> Window -> Effect Unit\n\nopen :: String -> String -> String -> Window -> Effect (Maybe Window)\nopen url' name features window = toMaybe <$> _open url' name features window\n\nforeign import _open\n  :: String\n  -> String\n  -> String\n  -> Window\n  -> Effect (Nullable Window)\n\nforeign import close :: Window -> Effect Unit\n\nforeign import outerHeight :: Window -> Effect Int\n\nforeign import outerWidth :: Window -> Effect Int\n\nforeign import print :: Window -> Effect Unit\n\nprompt :: String -> Window -> Effect (Maybe String)\nprompt msg window = toMaybe <$> _prompt msg \"\" window\n\npromptDefault :: String -> String -> Window -> Effect (Maybe String)\npromptDefault msg defaultText window = toMaybe <$> _prompt msg defaultText window\n\nforeign import _prompt :: String -> String -> Window -> Effect (Nullable String)\n\nforeign import resizeBy :: Int -> Int -> Window -> Effect Unit\n\nforeign import resizeTo :: Int -> Int -> Window -> Effect Unit\n\nforeign import screenX :: Window -> Effect Int\n\nforeign import screenY :: Window -> Effect Int\n\nforeign import scroll :: Int -> Int -> Window -> Effect Unit\n\nforeign import scrollBy :: Int -> Int -> Window -> Effect Unit\n\nforeign import scrollX :: Window -> Effect Number\n\nforeign import scrollY :: Window -> Effect Number\n\nforeign import localStorage :: Window -> Effect Storage\n\nforeign import sessionStorage :: Window -> Effect Storage\n\nnewtype RequestAnimationFrameId = RequestAnimationFrameId Int\n\nderive instance eqRequestAnimationFrameId :: Eq RequestAnimationFrameId\nderive instance ordRequestAnimationFrameId :: Ord RequestAnimationFrameId\n\nforeign import requestAnimationFrame :: Effect Unit -> Window -> Effect RequestAnimationFrameId\n\nforeign import cancelAnimationFrame :: RequestAnimationFrameId -> Window -> Effect Unit\n\nnewtype RequestIdleCallbackId = RequestIdleCallbackId Int\n\nderive instance eqRequestIdleCallbackId :: Eq RequestIdleCallbackId\nderive instance ordRequestIdleCallbackId :: Ord RequestIdleCallbackId\n\n-- | Set timeout to `0` to get the same behaviour as when it is `undefined` in\n-- | [JavaScript](https://w3c.github.io/requestidlecallback/#h-the-requestidle-callback-method).\nforeign import requestIdleCallback :: { timeout :: Int } -> Effect Unit -> Window -> Effect RequestIdleCallbackId\n\nforeign import cancelIdleCallback :: RequestIdleCallbackId -> Window -> Effect Unit\n\nforeign import parent :: Window -> Effect Window\n\nforeign import _opener :: Window -> Effect (Nullable Window)\n\nopener :: Window -> Effect (Maybe Window)\nopener window = toMaybe <$> _opener window\n", "module Gesso.Canvas.Element\n  ( Canvas\n  , getCanvasByAppName\n  , getCanvasClientRect\n  , getContextByAppName\n  , style\n  ) where\n\nimport Prelude\n\nimport CSS (CSS)\nimport CSS as CSS\nimport Data.Maybe (Maybe, fromMaybe)\nimport Data.Traversable (traverse)\nimport Effect (Effect)\nimport Gesso.Application as Application\nimport Gesso.Dimensions as Dimensions\nimport Graphics.Canvas (Context2D, getCanvasElementById, getContext2D)\nimport Halogen.HTML (AttrName(..), attr)\nimport Halogen.HTML.Properties (IProp)\nimport Web.DOM.Element (Element, getBoundingClientRect)\nimport Web.DOM.NonElementParentNode (getElementById)\nimport Web.HTML (window)\nimport Web.HTML.HTMLDocument (toNonElementParentNode)\nimport Web.HTML.Window (document)\n\n-- | Wrapper for a `Web.DOM.Element.Element` to tag elements that came from this\n-- | module.\nnewtype Canvas = Canvas Element\n\n-- | Wrapper for `getElementById` which returns a `Canvas`.\n-- |\n-- | `getElementById` from `Web.DOM.NonElementParentNode`, which returns a\n-- | `Web.DOM.Element.Element`, is different from `getCanvasElementById` from\n-- | `Graphics.Canvas`, which returns a `Graphics.Canvas.CanvasElement`, so\n-- | they're unfortunately incompatible.\ngetCanvasByAppName :: String -> Effect (Maybe Canvas)\ngetCanvasByAppName name =\n  window\n    >>= document\n      >>> map toNonElementParentNode\n    >>= getElementById name\n      >>> map (map Canvas)\n\n-- | Get the bounding client rect for a `Canvas` element and convert it to a\n-- | `ClientRect` value.\ngetCanvasClientRect :: Canvas -> Effect Dimensions.ClientRect\ngetCanvasClientRect (Canvas canvas) =\n  Dimensions.fromDOMRect <$> getBoundingClientRect canvas\n\n-- | Attempt to get the `Context2D` for this component's `canvas` element.\ngetContextByAppName :: String -> Effect (Maybe Context2D)\ngetContextByAppName name = getCanvasElementById name >>= traverse getContext2D\n\nstyle :: forall r i. Application.WindowMode -> IProp (style :: String | r) i\nstyle =\n  attr (AttrName \"style\")\n    <<< fromMaybe \"\"\n    <<< CSS.renderedInline\n    <<< CSS.rules []\n    <<< CSS.runS\n    <<< windowCss\n\n-- | Get the appropriate CSS for the screen element based on the `WindowMode`.\nwindowCss :: Application.WindowMode -> CSS\nwindowCss = case _ of\n  Application.Fixed size -> fix size\n  Application.Stretch -> stretched\n  Application.Fullscreen -> full\n  where\n  common = do\n    CSS.key (CSS.fromString \"outline\") \"none\"\n\n  fix size = do\n    Dimensions.toSizeCss size\n    common\n\n  stretched = do\n    CSS.width $ CSS.pct 100.0\n    CSS.height $ CSS.pct 100.0\n    common\n\n  full = do\n    CSS.width $ CSS.pct 100.0\n    CSS.height $ CSS.pct 100.0\n    CSS.position CSS.absolute\n    CSS.left $ CSS.pct 50.0\n    CSS.top $ CSS.pct 50.0\n    CSS.transform $ CSS.translate (CSS.pct $ -50.0) (CSS.pct $ -50.0)\n    common\n\n", "module Web.HTML.Event.EventTypes where\n\nimport Web.Event.Event (EventType(..))\n\nabort :: EventType\nabort = EventType \"abort\"\n\nafterprint :: EventType\nafterprint = EventType \"afterprint\"\n\nafterscriptexecute :: EventType\nafterscriptexecute = EventType \"afterscriptexecute\"\n\nbeforeprint :: EventType\nbeforeprint = EventType \"beforeprint\"\n\nbeforescriptexecute :: EventType\nbeforescriptexecute = EventType \"beforescriptexecute\"\n\nblur :: EventType\nblur = EventType \"blur\"\n\ncancel :: EventType\ncancel = EventType \"cancel\"\n\nchange :: EventType\nchange = EventType \"change\"\n\nclick :: EventType\nclick = EventType \"click\"\n\nclose :: EventType\nclose = EventType \"close\"\n\ncopy :: EventType\ncopy = EventType \"copy\"\n\ncut :: EventType\ncut = EventType \"cut\"\n\ndomcontentloaded :: EventType\ndomcontentloaded = EventType \"DOMContentLoaded\"\n\nerror :: EventType\nerror = EventType \"error\"\n\nfocus :: EventType\nfocus = EventType \"focus\"\n\ninput :: EventType\ninput = EventType \"input\"\n\ninvalid :: EventType\ninvalid = EventType \"invalid\"\n\nlanguagechange :: EventType\nlanguagechange = EventType \"languagechange\"\n\nload :: EventType\nload = EventType \"load\"\n\nloadend :: EventType\nloadend = EventType \"loadend\"\n\nloadstart :: EventType\nloadstart = EventType \"loadstart\"\n\nmessage :: EventType\nmessage = EventType \"message\"\n\noffline :: EventType\noffline = EventType \"offline\"\n\nonline :: EventType\nonline = EventType \"online\"\n\npaste :: EventType\npaste = EventType \"paste\"\n\nprogress :: EventType\nprogress = EventType \"progress\"\n\nreadystatechange :: EventType\nreadystatechange = EventType \"readystatechange\"\n\nreset :: EventType\nreset = EventType \"reset\"\n\nselect :: EventType\nselect = EventType \"select\"\n\nstorage :: EventType\nstorage = EventType \"storage\"\n\nsubmit :: EventType\nsubmit = EventType \"submit\"\n\ntoggle :: EventType\ntoggle = EventType \"toggle\"\n\nunload :: EventType\nunload = EventType \"unload\"\n", "export function _requestAnimationFrame(fn) {\n  return function (window) {\n    return function () {\n      return window.requestAnimationFrame(fn);\n    };\n  };\n};\n\nexport function cancelAnimationFrame(id) {\n  return function (window) {\n    return function () {\n      return window.cancelAnimationFrame(id);\n    };\n  };\n};\n\nexport function _now() {\n  return performance.now();\n}\n", "-- | Timestamps, time deltas, and `requestAnimationFrame`\nmodule Gesso.Time\n  ( Delta\n  , Interval\n  , Last\n  , Now\n  , RequestAnimationFrameId\n  , cancelAnimationFrame\n  , delta\n  , elapse\n  , hz\n  , requestAnimationFrame\n  , stamp\n  , stampInterval\n  ) where\n\nimport Prelude\n\nimport Data.List (List(..), head, (:))\nimport Data.Maybe (maybe)\nimport Data.Number (isFinite)\nimport Effect (Effect)\nimport Effect.Uncurried (EffectFn1, mkEffectFn1)\nimport Web.HTML (Window)\n\n-- | A `RequestAnimationFrameId` is returned when calling\n-- | `requestAnimationFrame`. This can be used to cancel the request.\nnewtype RequestAnimationFrameId = RequestAnimationFrameId Int\n\n-- | Cancel a request for an animation frame using the `RequestAnimationFrameId`\n-- | returned by `requestAnimationFrame`.\nforeign import cancelAnimationFrame\n  :: RequestAnimationFrameId -> Window -> Effect Unit\n\nforeign import _requestAnimationFrame\n  :: EffectFn1 Now Unit -> Window -> Effect RequestAnimationFrameId\n\n-- | An interface to `window.requestAnimationFrame` which passes the timestamp\n-- | argument to the callback function.\n-- |\n-- | Provided because `requestAnimationFrame` in `Web.HTML.Window` only accepts\n-- | an `Effect Unit` instead of a function of `Number -> Effect Unit`.\nrequestAnimationFrame\n  :: (Now -> Effect Unit)\n  -> Window\n  -> Effect RequestAnimationFrameId\nrequestAnimationFrame = _requestAnimationFrame <<< mkEffectFn1\n\n-- | The current time in milliseconds, or the time at which a value became\n-- | `Stamped`.\nnewtype Now = Now Number\n\n-- | A time in the past, in milliseconds.\nnewtype Last = Last Number\n\n-- | Convert a current time into a previous time.\nelapse :: Now -> Last\nelapse (Now t) = Last t\n\n-- | A current time, a previous time, and the difference between them. All\n-- | values are in milliseconds.\n-- |\n-- | For per-frame updates and the rendering function, `last` is the time of the\n-- | previous animation frame and `now` is the time of the current animation\n-- | frame.\n-- |\n-- | For fixed-rate updates, `last` is the scheduled time of the previous\n-- | fixed-rate update and `now` is the update's scheduled time.\n-- |\n-- | For interaction events and Halogen queries, `last` is the time of the\n-- | previous animation frame and `now` is the event's arrival time.\ntype Delta = { now :: Number, last :: Number, delta :: Number }\n\n-- | Create a Delta from a current time and a previous time.\ndelta :: Now -> Last -> Delta\ndelta (Now now) (Last last) = { now, last, delta: now - last }\n\n-- | Get the current `DOMHighResTimeStamp` from `performance.now`.\n-- |\n-- | See [`DOMHighResTimeStamp`](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp)\nforeign import _now :: Effect Now\n\n-- | An item and a specific time associated with that item. Used for comparing\n-- | timestamped values produced by [`stamp`](#v:stamp) and\n-- | [`stampInterval`](#v:stampInterval).\ntype Stamped a = { time :: Number, item :: a }\n\n-- | For a `last` timestamp and a function `f :: Delta -> a` (such as\n-- | `UpdateFunction s :: Delta -> TimestampedUpdate s` in\n-- | [`Application`](Gesso.Application.html#t:UpdateFunction)), create a\n-- | `Delta` between `last` and now, apply the delta to `f`, and return the\n-- | current time and the result of `f delta`.\nstamp :: forall a. Last -> (Delta -> a) -> Effect (Stamped a)\nstamp last f = do\n  n@(Now t) <- _now\n  let d = delta n last\n  pure { time: t, item: f d }\n\n-- | A interval of time, in milliseconds, to space out repeating an action, or\n-- | `Never` perform the action.\ndata Interval\n  = Interval Number\n  | Never\n\n-- | Construct an `Interval` from Hz or frames per second. Invalid frequencies\n-- | (`\u00B1Infinity`, `NaN`, zero, or negative) result in a `Never` interval.\nhz :: Number -> Interval\nhz fps\n  | not (isFinite fps) = Never\n  | fps <= 0.0 = Never\n  | otherwise = Interval $ 1.0 / fps\n\n-- | Results of repeatedly timestamping a function at certain interval:\n-- |\n-- | * `last`: the timestamp of the latest item in the list\n-- | * `items`: a list of repeated applications of `Delta`s to the function,\n-- |   with timestamps\ntype StampedBatch a =\n  { last :: Last\n  , items :: List (Stamped a)\n  }\n\n-- | A dummy `StampedBatch` for `Never` intervals. Contains a valid `Last` time\n-- | just in case.\nemptyBatch :: forall a. Effect (StampedBatch a)\nemptyBatch = { last: _, items: Nil } <$> elapse <$> _now\n\n-- | Repeatedly timestamp a function at a given interval, starting at the last\n-- | time plus the interval, as long as the timestamp is not after the current\n-- | time.\n-- |\n-- | The `last` value returned should be saved by the caller to pass in as the\n-- | `last` argument for the next call to `stampInterval`.\nstampInterval\n  :: forall a\n   . Last\n  -> (Delta -> a)\n  -> Interval\n  -> Effect (StampedBatch a)\nstampInterval last fn = case _ of\n  Never -> emptyBatch\n  Interval ms -> batch <$> schedule Nil last <$> _now\n    where\n    batch :: List (Stamped a) -> StampedBatch a\n    batch items = { last: lastTime items, items }\n\n    lastTime :: List (Stamped a) -> Last\n    lastTime l = maybe last (Last <<< _.time) $ head l\n\n    schedule :: List (Stamped a) -> Last -> Now -> List (Stamped a)\n    schedule items prev@(Last p) now@(Now n)\n      | p + ms >= n = items\n      | otherwise = schedule items' (elapse cur) now\n          where\n          cur@(Now c) = Now $ p + ms\n          items' = { time: c, item: fn (delta cur prev) } : items\n", "module Data.Coyoneda\n  ( Coyoneda(..)\n  , CoyonedaF\n  , coyoneda\n  , unCoyoneda\n  , liftCoyoneda\n  , lowerCoyoneda\n  , hoistCoyoneda\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, alt)\nimport Control.Alternative (class Alternative, class Plus, empty)\nimport Control.Comonad (class Comonad, extract)\nimport Control.Extend (class Extend, (<<=))\nimport Control.Monad.Trans.Class (class MonadTrans)\nimport Control.MonadPlus (class MonadPlus)\nimport Data.Distributive (class Distributive, collect)\nimport Data.Eq (class Eq1, eq1)\nimport Data.Exists (Exists, runExists, mkExists)\nimport Data.Foldable (class Foldable, foldMap, foldl, foldr)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Ord (class Ord1, compare1)\nimport Data.Semigroup.Foldable (class Foldable1, foldMap1, foldr1Default, foldl1Default)\nimport Data.Semigroup.Traversable (class Traversable1, sequence1, traverse1)\nimport Data.Traversable (class Traversable, traverse)\n\n-- | `Coyoneda` is encoded as an existential type using `Data.Exists`.\n-- |\n-- | This type constructor encodes the contents of the existential package.\ndata CoyonedaF f a i = CoyonedaF (i -> a) (f i)\n\n-- | The `Coyoneda` `Functor`.\n-- |\n-- | `Coyoneda f` is a `Functor` for any type constructor `f`. In fact,\n-- | it is the _free_ `Functor` for `f`, i.e. any natural transformation\n-- | `nat :: f ~> g`, can be factor through `liftCoyoneda`.  The natural\n-- | transformation from `Coyoneda f ~> g` is given by `lowerCoyoneda <<<\n-- | hoistCoyoneda nat`:\n-- | ```purescript\n-- | lowerCoyoneda <<< hoistCoyoneda nat <<< liftCoyoneda $ fi\n-- | = lowerCoyoneda (hoistCoyoneda nat (Coyoneda $ mkExists $ CoyonedaF identity fi))    (by definition of liftCoyoneda)\n-- | = lowerCoyoneda (coyoneda identity (nat fi))                                         (by definition of hoistCoyoneda)\n-- | = unCoyoneda map (coyoneda identity (nat fi))                                        (by definition of lowerCoyoneda)\n-- | = unCoyoneda map (Coyoneda $ mkExists $ CoyonedaF  identity (nat fi))                (by definition of coyoneda)\n-- | = map identity (nat fi)                                                              (by definition of unCoyoneda)\n-- | = nat fi                                                                       (since g is a Functor)\n-- | ```\nnewtype Coyoneda f a = Coyoneda (Exists (CoyonedaF f a))\n\ninstance eqCoyoneda :: (Functor f, Eq1 f, Eq a) => Eq (Coyoneda f a) where\n  eq x y = lowerCoyoneda x `eq1` lowerCoyoneda y\n\ninstance eq1Coyoneda :: (Functor f, Eq1 f) => Eq1 (Coyoneda f) where\n  eq1 = eq\n\ninstance ordCoyoneda :: (Functor f, Ord1 f, Ord a) => Ord (Coyoneda f a) where\n  compare x y = lowerCoyoneda x `compare1` lowerCoyoneda y\n\ninstance ord1Coyoneda :: (Functor f, Ord1 f) => Ord1 (Coyoneda f) where\n  compare1 = compare\n\ninstance functorCoyoneda :: Functor (Coyoneda f) where\n  map f (Coyoneda e) = runExists (\\(CoyonedaF k fi) -> coyoneda (f <<< k) fi) e\n\ninstance invatiantCoyoneda :: Invariant (Coyoneda f) where\n  imap = imapF\n\ninstance applyCoyoneda :: Apply f => Apply (Coyoneda f) where\n  apply f g = liftCoyoneda $ lowerCoyoneda f <*> lowerCoyoneda g\n\ninstance applicativeCoyoneda :: Applicative f => Applicative (Coyoneda f) where\n  pure = liftCoyoneda <<< pure\n\ninstance altCoyoneda :: Alt f => Alt (Coyoneda f) where\n  alt x y = liftCoyoneda $ alt (lowerCoyoneda x) (lowerCoyoneda y)\n\ninstance plusCoyoneda :: Plus f => Plus (Coyoneda f) where\n  empty = liftCoyoneda empty\n\ninstance alternativeCoyoneda :: Alternative f => Alternative (Coyoneda f)\n\ninstance bindCoyoneda :: Bind f => Bind (Coyoneda f) where\n  bind (Coyoneda e) f =\n    liftCoyoneda $\n      runExists (\\(CoyonedaF k fi) -> lowerCoyoneda <<< f <<< k =<< fi) e\n\n-- | When `f` is a Monad then it is a functor as well.  In this case\n-- | `liftCoyoneda` is not only a functor isomorphism but also a monad\n-- | isomorphism, i.e. the following law holds\n-- | ```purescript\n-- | liftCoyoneda fa >>= liftCoyoneda <<< g = liftCoyoneda $ fa >>= g\n-- | ```\ninstance monadCoyoneda :: Monad f => Monad (Coyoneda f)\n\ninstance monadTransCoyoneda :: MonadTrans Coyoneda where\n  lift = liftCoyoneda\n\ninstance monadPlusCoyoneda :: MonadPlus f => MonadPlus (Coyoneda f)\n\ninstance extendCoyoneda :: Extend w => Extend (Coyoneda w) where\n  extend f (Coyoneda e) =\n    runExists (\\(CoyonedaF k fi) -> liftCoyoneda $ f <<< coyoneda k <<= fi) e\n\n-- | As in the monad case: if `w` is a comonad, then it is a functor, thus\n-- | `liftCoyoneda` is an iso of functors, but moreover it is an iso of\n-- | comonads, i.e. the following law holds:\n-- | ```purescript\n-- | g <<= liftCoyoneda w = liftCoyoneda $ g <<< liftCoyoneda <<= w\n-- | ```\ninstance comonadCoyoneda :: Comonad w => Comonad (Coyoneda w) where\n  extract (Coyoneda e) = runExists (\\(CoyonedaF k fi) -> k $ extract fi) e\n\ninstance foldableCoyoneda :: Foldable f => Foldable (Coyoneda f) where\n  foldr f z = unCoyoneda \\k -> foldr (f <<< k) z\n  foldl f z = unCoyoneda \\k -> foldl (\\x -> f x <<< k) z\n  foldMap f = unCoyoneda \\k -> foldMap (f <<< k)\n\ninstance traversableCoyoneda :: Traversable f => Traversable (Coyoneda f) where\n  traverse f = unCoyoneda \\k -> map liftCoyoneda <<< traverse (f <<< k)\n  sequence = unCoyoneda \\k -> map liftCoyoneda <<< traverse k\n\ninstance foldable1Coyoneda :: Foldable1 f => Foldable1 (Coyoneda f) where\n  foldMap1 f = unCoyoneda \\k -> foldMap1 (f <<< k)\n  foldr1 = foldr1Default\n  foldl1 = foldl1Default\n\ninstance traversable1Coyoneda :: Traversable1 f => Traversable1 (Coyoneda f) where\n  traverse1 f = unCoyoneda \\k -> map liftCoyoneda <<< traverse1 (f <<< k)\n  sequence1 = unCoyoneda \\k -> map liftCoyoneda <<< sequence1 <<< map k\n\ninstance distributiveCoyoneda :: Distributive f => Distributive (Coyoneda f) where\n  collect f = liftCoyoneda <<< collect (lowerCoyoneda <<< f)\n  distribute = liftCoyoneda <<< collect lowerCoyoneda\n\n-- | Construct a value of type `Coyoneda f b` from a mapping function and a\n-- | value of type `f a`.\ncoyoneda :: forall f a b. (a -> b) -> f a -> Coyoneda f b\ncoyoneda k fi = Coyoneda $ mkExists $ CoyonedaF k fi\n\n-- | Deconstruct a value of `Coyoneda a` to retrieve the mapping function and\n-- | original value.\nunCoyoneda :: forall f a r. (forall b. (b -> a) -> f b -> r) -> Coyoneda f a -> r\nunCoyoneda f (Coyoneda e) = runExists (\\(CoyonedaF k fi) -> f k fi) e\n\n-- | Lift a value described by the type constructor `f` to `Coyoneda f`.\n-- |\n-- | Note that for any functor `f` `liftCoyoneda` has a right inverse\n-- | `lowerCoyoneda`:\n-- | ```purescript\n-- | liftCoyoneda <<< lowerCoyoneda $ (Coyoneda e)\n-- | = liftCoyoneda <<< unCoyoneda map $ (Coyoneda e)\n-- | = liftCoyonead (runExists (\\(CoyonedaF k fi) -> map k fi) e)\n-- | = liftCoyonead (Coyoneda e)\n-- | = coyoneda identity (Coyoneda e)\n-- | = Coyoneda e\n-- | ```\n-- | Moreover if `f` is a `Functor` then `liftCoyoneda` is an isomorphism of\n-- | functors with inverse `lowerCoyoneda`:  we already showed that\n-- | `lowerCoyoneda <<< hoistCoyoneda identity = lowerCoyoneda` is its left inverse\n-- | whenever `f` is a functor.\nliftCoyoneda :: forall f. f ~> Coyoneda f\nliftCoyoneda = coyoneda identity\n\n-- | Lower a value of type `Coyoneda f a` to the `Functor` `f`.\nlowerCoyoneda :: forall f. Functor f => Coyoneda f ~> f\nlowerCoyoneda = unCoyoneda map\n\n-- | Use a natural transformation to change the generating type constructor of a\n-- | `Coyoneda`.\nhoistCoyoneda :: forall f g. (f ~> g) -> Coyoneda f ~> Coyoneda g\nhoistCoyoneda nat (Coyoneda e) =\n  runExists (\\(CoyonedaF k fi) -> coyoneda k (nat fi)) e\n", "module Halogen.Data.Slot\n  ( Slot\n  , SlotStorage\n  , empty\n  , lookup\n  , insert\n  , pop\n  , slots\n  , foreachSlot\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (traverse_)\nimport Data.Map (Map)\nimport Data.Map as Map\nimport Data.Maybe (Maybe(..))\nimport Data.Monoid.Alternate (Alternate(..))\nimport Data.Newtype (un)\nimport Data.Symbol (class IsSymbol, reflectSymbol)\nimport Data.Tuple (Tuple(..))\nimport Halogen.Data.OrdBox (OrdBox, mkOrdBox, unOrdBox)\nimport Prim.Row as Row\nimport Type.Proxy (Proxy)\nimport Unsafe.Coerce (unsafeCoerce)\n\nforeign import data Any :: Type\n\n-- | A type which records the queries, output messages, and slot identifier for\n-- | a particular slot (ie. a location in HTML where a component is rendered).\n-- | For example:\n-- |\n-- | ```purescript\n-- | type ButtonSlot slot = Slot Button.Query Button.Output slot\n-- |\n-- | -- A component using this slot type can have one type of child component,\n-- | -- which supports `Button.Query` queries, `Button.Output` outputs, and\n-- | -- which can be uniquely identified by an integer.\n-- | type Slots = ( button :: ButtonSlot Int )\n-- | ```\n-- |\n-- | - `query` represents the requests that can be made of this component\n-- | - `output` represents the output messages that can be raised by this component\n-- | - `slot` represents the unique identifier for this component\ndata Slot :: (Type -> Type) -> Type -> Type -> Type\ndata Slot (query :: Type -> Type) output slot\n\nnewtype SlotStorage (slots :: Row Type) (slot :: (Type -> Type) -> Type -> Type) =\n  SlotStorage (Map (Tuple String (OrdBox Any)) Any)\n\nempty :: forall slots slot. SlotStorage slots slot\nempty = SlotStorage Map.empty\n\nlookup\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> s\n  -> SlotStorage slots slot\n  -> Maybe (slot query output)\nlookup sym key (SlotStorage m) =\n  coerceSlot (Map.lookup (Tuple (reflectSymbol sym) (coerceBox (mkOrdBox key))) m)\n  where\n  coerceSlot :: Maybe Any -> Maybe (slot query output)\n  coerceSlot = unsafeCoerce\n\n  coerceBox :: OrdBox s -> OrdBox Any\n  coerceBox = unsafeCoerce\n\npop\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> s\n  -> SlotStorage slots slot\n  -> Maybe (Tuple (slot query output) (SlotStorage slots slot))\npop sym key (SlotStorage m) =\n  coercePop (Map.pop (Tuple (reflectSymbol sym) (coerceBox (mkOrdBox key))) m)\n  where\n  coercePop :: Maybe (Tuple Any (Map (Tuple String (OrdBox Any)) Any)) -> Maybe (Tuple (slot query output) (SlotStorage slots slot))\n  coercePop = unsafeCoerce\n\n  coerceBox :: OrdBox s -> OrdBox Any\n  coerceBox = unsafeCoerce\n\ninsert\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> s\n  -> slot query output\n  -> SlotStorage slots slot\n  -> SlotStorage slots slot\ninsert sym key val (SlotStorage m) =\n  SlotStorage (Map.insert (Tuple (reflectSymbol sym) (coerceBox (mkOrdBox key))) (coerceVal val) m)\n  where\n  coerceBox :: OrdBox s -> OrdBox Any\n  coerceBox = unsafeCoerce\n\n  coerceVal :: slot query output -> Any\n  coerceVal = unsafeCoerce\n\nslots\n  :: forall sym px slots slot query output s\n   . Row.Cons sym (Slot query output s) px slots\n  => IsSymbol sym\n  => Ord s\n  => Proxy sym\n  -> SlotStorage slots slot\n  -> Map s (slot query output)\nslots sym (SlotStorage m) = un Alternate $ Map.foldSubmap Nothing Nothing go m\n  where\n  key = reflectSymbol sym\n\n  go (Tuple key' ob) val\n    | key == key' = Alternate $ Map.singleton (unOrdBox (coerceBox ob)) (coerceVal val)\n    | otherwise = Alternate Map.empty\n\n  coerceBox :: OrdBox Any -> OrdBox s\n  coerceBox = unsafeCoerce\n\n  coerceVal :: Any -> slot query output\n  coerceVal = unsafeCoerce\n\nforeachSlot\n  :: forall m slots slot\n   . Applicative m\n  => SlotStorage slots slot\n  -> (forall query output. slot query output -> m Unit)\n  -> m Unit\nforeachSlot (SlotStorage m) k = traverse_ (k <<< coerceVal) m\n  where\n  coerceVal :: forall query output. Any -> slot query output\n  coerceVal = unsafeCoerce\n", "-- | This module defines a strict double-ended queue.\n-- |\n-- | The queue implementation is based on a pair of lists where all\n-- | operations require `O(1)` amortized time.\n-- |\n-- | However, any single `uncons` operation may run in `O(n)` time.\n-- |\n-- | See [Simple and Efficient Purely Functional Queues and Dequeues](http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf) (Okasaki 1995)\nmodule Data.CatQueue\n  ( CatQueue(..)\n  , empty\n  , null\n  , singleton\n  , length\n  , cons\n  , snoc\n  , uncons\n  , unsnoc\n  , fromFoldable\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.Apply (lift2)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.Foldable (class Foldable, foldMap, foldMapDefaultL, foldl, foldrDefault)\nimport Data.List (List(..), reverse)\nimport Data.List as L\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (class Traversable, sequenceDefault)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable, class Unfoldable1)\n\n-- | A strict double-ended queue (dequeue) representated using a pair of lists.\ndata CatQueue a = CatQueue (List a) (List a)\n\n-- | Create an empty queue.\n-- |\n-- | Running time: `O(1)`\nempty :: forall a. CatQueue a\nempty = CatQueue Nil Nil\n\n-- | Test whether a queue is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. CatQueue a -> Boolean\nnull (CatQueue Nil Nil) = true\nnull _ = false\n\n-- | Create a queue containing a single element.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> CatQueue a\nsingleton = snoc empty\n\n-- | Number of elements in queue.\n-- |\n-- | Running time: `O(n)` in length of queue.\nlength :: forall a. CatQueue a -> Int\nlength (CatQueue l r) = L.length l + L.length r\n\n-- | Append an element to the beginning of the queue, creating a new queue.\n-- |\n-- | Running time: `O(1)`\ncons :: forall a. a -> CatQueue a -> CatQueue a\ncons a (CatQueue l r) = CatQueue (Cons a l) r\n\n-- | Append an element to the end of the queue, creating a new queue.\n-- |\n-- | Running time: `O(1)`\nsnoc :: forall a. CatQueue a -> a -> CatQueue a\nsnoc (CatQueue l r) a = CatQueue l (Cons a r)\n\n-- | Decompose a queue into a `Tuple` of the first element and the rest of the queue.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nuncons :: forall a. CatQueue a -> Maybe (Tuple a (CatQueue a))\nuncons (CatQueue Nil Nil) = Nothing\nuncons (CatQueue Nil r) = uncons (CatQueue (reverse r) Nil)\nuncons (CatQueue (Cons a as) r) = Just (Tuple a (CatQueue as r))\n\n-- | Decompose a queue into a `Tuple` of the last element and the rest of the queue.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nunsnoc :: forall a. CatQueue a -> Maybe (Tuple a (CatQueue a))\nunsnoc (CatQueue l (Cons a as)) = Just (Tuple a (CatQueue l as))\nunsnoc (CatQueue Nil Nil) = Nothing\nunsnoc (CatQueue l Nil) = unsnoc (CatQueue Nil (reverse l))\n\n-- | Convert any `Foldable` into a `CatQueue`.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f a. Foldable f => f a -> CatQueue a\nfromFoldable f = foldMap singleton f\n\ncqEq :: forall a. Eq a => CatQueue a -> CatQueue a -> Boolean\ncqEq = go\n  where\n    elemEq = eq :: (a -> a -> Boolean)\n    go xs ys = case uncons xs, uncons ys of\n      Just (Tuple x xs'), Just (Tuple y ys')\n        | x `elemEq` y -> go xs' ys'\n      Nothing, Nothing -> true\n      _      , _       -> false\n\ncqCompare :: forall a. Ord a => CatQueue a -> CatQueue a -> Ordering\ncqCompare = go\n  where\n    elemCompare = compare :: (a -> a -> Ordering)\n    go xs ys = case uncons xs, uncons ys of\n      Just (Tuple x xs'), Just (Tuple y ys') ->\n        case elemCompare x y of\n             EQ       -> go xs' ys'\n             ordering -> ordering\n      Just _,   Nothing -> GT\n      Nothing,  Just _  -> LT\n      Nothing,  Nothing -> EQ\n\ninstance eqCatQueue :: Eq a => Eq (CatQueue a) where\n  eq = cqEq\n\ninstance ordCatQueue :: Ord a => Ord (CatQueue a) where\n  compare = cqCompare\n\n-- | Running time: `O(n) in the length of the second queue`\ninstance semigroupCatQueue :: Semigroup (CatQueue a) where\n  append = foldl snoc\n\ninstance monoidCatQueue :: Monoid (CatQueue a) where\n  mempty = empty\n\ninstance showCatQueue :: Show a => Show (CatQueue a) where\n  show (CatQueue l r) = \"(CatQueue \" <> show l <> \" \" <> show r <> \")\"\n\ninstance foldableCatQueue :: Foldable CatQueue where\n  foldMap = foldMapDefaultL\n  foldr f = foldrDefault f\n  foldl f = go\n    where\n    go acc q = case uncons q of\n       Just (Tuple x xs) -> go (f acc x) xs\n       Nothing -> acc\n\ninstance unfoldable1CatQueue :: Unfoldable1 CatQueue where\n  unfoldr1 f b = go b empty\n    where\n      go source memo = case f source of\n        Tuple one Nothing -> snoc memo one\n        Tuple one (Just rest) -> go rest (snoc memo one)\n\ninstance unfoldableCatQueue :: Unfoldable CatQueue where\n  unfoldr f b = go b empty\n    where\n      go source memo = case f source of\n        Nothing -> memo\n        Just (Tuple one rest) -> go rest (snoc memo one)\n\ninstance traversableCatQueue :: Traversable CatQueue where\n  traverse f =\n    map (foldl snoc empty)\n    <<< foldl (\\acc -> lift2 snoc acc <<< f) (pure empty)\n  sequence = sequenceDefault\n\ninstance functorCatQueue :: Functor CatQueue where\n  map f (CatQueue l r) = CatQueue (map f l) (map f r)\n\ninstance applyCatQueue :: Apply CatQueue where\n  apply = ap\n\ninstance applicativeCatQueue :: Applicative CatQueue where\n  pure = singleton\n\ninstance bindCatQueue :: Bind CatQueue where\n  bind = flip foldMap\n\ninstance monadCatQueue :: Monad CatQueue\n\ninstance altCatQueue :: Alt CatQueue where\n  alt = append\n\ninstance plusCatQueue :: Plus CatQueue where\n  empty = empty\n\ninstance alternativeCatQueue :: Alternative CatQueue\n\ninstance monadPlusCatQueue :: MonadPlus CatQueue\n", "-- | This module defines a strict catenable list.\n-- |\n-- | The implementation is based on a queue where all operations require\n-- | `O(1)` amortized time.\n-- |\n-- | However, any single `uncons` operation may run in `O(n)` time.\n-- |\n-- | See [Purely Functional Data Structures](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf) (Okasaki 1996)\nmodule Data.CatList\n  ( CatList(..)\n  , empty\n  , null\n  , singleton\n  , length\n  , append\n  , cons\n  , snoc\n  , uncons\n  , fromFoldable\n  ) where\n\nimport Prelude hiding (append)\n\nimport Control.Alt (class Alt)\nimport Control.Alternative (class Alternative)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.Plus (class Plus)\nimport Data.CatQueue as Q\nimport Data.Foldable (class Foldable, foldMapDefaultL)\nimport Data.Foldable as Foldable\nimport Data.List as L\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (sequence, traverse, class Traversable)\nimport Data.Tuple (Tuple(..))\nimport Data.Unfoldable (class Unfoldable)\nimport Data.Unfoldable1 (class Unfoldable1)\n\n-- | A strict catenable list.\n-- |\n-- | `CatList` may be empty, represented by `CatNil`.\n-- |\n-- | `CatList` may be non-empty, represented by `CatCons`. The `CatCons`\n-- | data constructor takes the first element of the list and a queue of\n-- | `CatList`.\ndata CatList a = CatNil | CatCons a (Q.CatQueue (CatList a))\n\n-- | Create an empty catenable list.\n-- |\n-- | Running time: `O(1)`\nempty :: forall a. CatList a\nempty = CatNil\n\n-- | Test whether a catenable list is empty.\n-- |\n-- | Running time: `O(1)`\nnull :: forall a. CatList a -> Boolean\nnull CatNil = true\nnull _ = false\n\n-- | Number of elements in queue.\n-- |\n-- | Running time: `O(n)` in length of queue.\nlength :: forall a. CatList a -> Int\nlength = Foldable.length\n\n-- | Append all elements of a catenable list to the end of another\n-- | catenable list, create a new catenable list.\n-- |\n-- | Running time: `O(1)`\nappend :: forall a. CatList a -> CatList a -> CatList a\nappend = link\n\n-- | Append an element to the beginning of the catenable list, creating a new\n-- | catenable list.\n-- |\n-- | Running time: `O(1)`\ncons :: forall a. a -> CatList a -> CatList a\ncons a cat = append (CatCons a Q.empty) cat\n\n-- | Create a catenable list with a single item.\n-- |\n-- | Running time: `O(1)`\nsingleton :: forall a. a -> CatList a\nsingleton a = cons a CatNil\n\n-- | Append an element to the end of the catenable list, creating a new\n-- | catenable list.\n-- |\n-- | Running time: `O(1)`\nsnoc :: forall a. CatList a -> a -> CatList a\nsnoc cat a = append cat (CatCons a Q.empty)\n\n-- | Decompose a catenable list into a `Tuple` of the first element and\n-- | the rest of the catenable list.\n-- |\n-- | Running time: `O(1)`\n-- |\n-- | Note that any single operation may run in `O(n)`.\nuncons :: forall a. CatList a -> Maybe (Tuple a (CatList a))\nuncons CatNil = Nothing\nuncons (CatCons a q) = Just (Tuple a (if Q.null q then CatNil else (foldr link CatNil q)))\n\n-- | Links two catenable lists by making appending the queue in the\n-- | first catenable list to the second catenable list. This operation\n-- | creates a new catenable list.\n-- |\n-- | Running time: `O(1)`\nlink :: forall a. CatList a -> CatList a -> CatList a\nlink CatNil cat = cat\nlink cat CatNil = cat\nlink (CatCons a q) cat = CatCons a (Q.snoc q cat)\n\n-- | Tail recursive version of foldr on `CatList`.\n-- |\n-- | Ensures foldl on `List` is tail-recursive.\nfoldr :: forall a. (CatList a -> CatList a -> CatList a) -> CatList a -> Q.CatQueue (CatList a) -> CatList a\nfoldr k b q = go q L.Nil\n  where\n  go :: Q.CatQueue (CatList a) -> L.List (CatList a -> CatList a) -> CatList a\n  go xs ys = case Q.uncons xs of\n                  Nothing -> foldl (\\x i -> i x) b ys\n                  Just (Tuple a rest) -> go rest (L.Cons (k a) ys)\n\n  foldl :: forall b c. (c -> b -> c) -> c -> L.List b -> c\n  foldl _ c L.Nil = c\n  foldl k' c (L.Cons b' as) = foldl k' (k' c b') as\n\n-- | Convert any `Foldable` into a `CatList`.\n-- |\n-- | Running time: `O(n)`\nfromFoldable :: forall f. Foldable f => f ~> CatList\nfromFoldable f = Foldable.foldMap singleton f\n\nfoldMap :: forall a m. Monoid m => (a -> m) -> CatList a -> m\nfoldMap _ CatNil = mempty\nfoldMap f (CatCons a q) =\n  let d = if Q.null q then CatNil else (foldr link CatNil q)\n  in f a <> foldMap f d\n\n-- | Running time: `O(1)`\ninstance semigroupCatList :: Semigroup (CatList a) where\n  append = append\n\ninstance monoidCatList :: Monoid (CatList a) where\n  mempty = CatNil\n\ninstance showCatList :: Show a => Show (CatList a) where\n  show CatNil = \"CatNil\"\n  show (CatCons a as) = \"(CatList \" <> show a <> \" \" <> show as <> \")\"\n\ninstance foldableCatList :: Foldable CatList where\n  foldMap = foldMapDefaultL\n  foldr f s l = Foldable.foldrDefault f s l\n  foldl f = go\n    where\n    go acc q = case uncons q of\n       Just (Tuple x xs) -> go (f acc x) xs\n       Nothing -> acc\n\ninstance unfoldableCatList :: Unfoldable CatList where\n  unfoldr f b = go b CatNil\n    where\n      go source memo = case f source of\n        Nothing -> memo\n        Just (Tuple one rest) -> go rest (snoc memo one)\n\ninstance unfoldable1CatList :: Unfoldable1 CatList where\n  unfoldr1 f b = go b CatNil\n    where\n      go source memo = case f source of\n        Tuple one Nothing -> snoc memo one\n        Tuple one (Just rest) -> go rest (snoc memo one)\n\ninstance traversableCatList :: Traversable CatList where\n  traverse _ CatNil = pure CatNil\n  traverse f (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in cons <$> f a <*> traverse f d\n  sequence CatNil = pure CatNil\n  sequence (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in cons <$> a <*> sequence d\n\ninstance functorCatList :: Functor CatList where\n  map _ CatNil = CatNil\n  map f (CatCons a q) =\n    let d = if Q.null q then CatNil else (foldr link CatNil q)\n    in f a `cons` map f d\n\ninstance applyCatList :: Apply CatList where\n  apply = ap\n\ninstance applicativeCatList :: Applicative CatList where\n  pure = singleton\n\ninstance bindCatList :: Bind CatList where\n  bind = flip foldMap\n\ninstance monadCatList :: Monad CatList\n\ninstance altCatList :: Alt CatList where\n  alt = append\n\ninstance plusCatList :: Plus CatList where\n  empty = empty\n\ninstance alternativeCatList :: Alternative CatList\n\ninstance monadPlusCatList :: MonadPlus CatList\n", "module Halogen.Query.ChildQuery where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Halogen.Data.Slot (SlotStorage)\nimport Unsafe.Coerce (unsafeCoerce)\n\ndata ChildQueryBox :: Row Type -> Type -> Type\ndata ChildQueryBox (ps :: Row Type) a\n\ndata ChildQuery ps g o a f b =\n  ChildQuery\n    (forall slot m. Applicative m => (slot g o -> m (Maybe b)) -> SlotStorage ps slot -> m (f b))\n    (g b)\n    (f b -> a)\n\ninstance functorChildQuery :: Functor (ChildQueryBox ps) where\n  map f = unChildQueryBox \\(ChildQuery u q k) ->\n    mkChildQueryBox (ChildQuery u q (f <<< k))\n\nmkChildQueryBox\n  :: forall ps g o a f b\n   . ChildQuery ps g o a f b\n  -> ChildQueryBox ps a\nmkChildQueryBox = unsafeCoerce\n\nunChildQueryBox\n  :: forall ps a r\n   . (forall g o f b. ChildQuery ps g o a f b -> r)\n  -> ChildQueryBox ps a\n  -> r\nunChildQueryBox = unsafeCoerce\n", "export function reallyUnsafeRefEq(a) {\n  return function (b) {\n    return a === b;\n  };\n}\n", "module Unsafe.Reference\n  ( unsafeRefEq\n  , reallyUnsafeRefEq\n  , UnsafeRefEq(..)\n  , UnsafeRefEqFallback(..)\n  ) where\n\nimport Prelude\n\n-- | Compares two values of the same type using strict (`===`) equality.\nunsafeRefEq :: forall a. a -> a -> Boolean\nunsafeRefEq = reallyUnsafeRefEq\n\n-- | Compares two values of different types using strict (`===`) equality.\nforeign import reallyUnsafeRefEq :: forall a b. a -> b -> Boolean\n\n-- | The `Eq` instance is defined by `unsafeRefEq`.\nnewtype UnsafeRefEq a = UnsafeRefEq a\n\ninstance eqUnsafeRefEq :: Eq (UnsafeRefEq a) where\n  eq (UnsafeRefEq l) (UnsafeRefEq r) = unsafeRefEq l r\n\n-- | The `Eq` instance first checks `unsafeRefEq`, if `false` falls back to\n-- | the underlying `Eq` instance.\nnewtype UnsafeRefEqFallback a = UnsafeRefEqFallback a\n\ninstance eqUnsafeRefEqFallback ::\n  Eq a =>\n  Eq (UnsafeRefEqFallback a) where\n  eq (UnsafeRefEqFallback l) (UnsafeRefEqFallback r) =\n    unsafeRefEq l r || l == r\n\n", "module Halogen.Query.HalogenQ where\n\nimport Prelude\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Coyoneda (Coyoneda)\n\ndata HalogenQ query action input a\n  = Initialize a\n  | Finalize a\n  | Receive input a\n  | Action action a\n  | Query (Coyoneda query a) (Unit -> a)\n\ninstance bifunctorHalogenQ :: Bifunctor (HalogenQ query action) where\n  bimap f g = case _ of\n    Initialize a -> Initialize (g a)\n    Finalize a -> Finalize (g a)\n    Receive i a -> Receive (f i) (g a)\n    Action action a -> Action action (g a)\n    Query fa k -> Query (map g fa) (map g k)\n\nderive instance functorHalogenQ :: Functor (HalogenQ query action input)\n", "module Halogen.VDom.Thunk\n  ( Thunk\n  , buildThunk\n  , runThunk\n  , hoist\n  , mapThunk\n  , thunked\n  , thunk1\n  , thunk2\n  , thunk3\n  ) where\n\nimport Prelude\n\nimport Data.Function.Uncurried as Fn\nimport Effect.Uncurried as EFn\nimport Halogen.VDom as V\nimport Halogen.VDom.Machine as M\nimport Halogen.VDom.Util as Util\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM.Node (Node)\n\nforeign import data ThunkArg \u2237 Type\n\nforeign import data ThunkId \u2237 Type\n\ndata Thunk :: (Type -> Type) -> Type -> Type\ndata Thunk f i = Thunk ThunkId (Fn.Fn2 ThunkArg ThunkArg Boolean) (ThunkArg \u2192 f i) ThunkArg\n\nunsafeThunkId \u2237 \u2200 a. a \u2192 ThunkId\nunsafeThunkId = unsafeCoerce\n\ninstance functorThunk \u2237 Functor f \u21D2 Functor (Thunk f) where\n  map f (Thunk a b c d) = Thunk a b (c >>> map f) d\n\nhoist \u2237 \u2200 f g. (f ~> g) \u2192 Thunk f ~> Thunk g\nhoist = mapThunk\n\nmapThunk \u2237 \u2200 f g i j. (f i -> g j) \u2192 Thunk f i -> Thunk g j\nmapThunk k (Thunk a b c d) = Thunk a b (c >>> k) d\n\nthunk \u2237 \u2200 a f i. Fn.Fn4 ThunkId (Fn.Fn2 a a Boolean) (a \u2192 f i) a (Thunk f i)\nthunk = Fn.mkFn4 \\tid eqFn f a \u2192\n  Thunk tid\n    (unsafeCoerce eqFn \u2237 Fn.Fn2 ThunkArg ThunkArg Boolean)\n    (unsafeCoerce f \u2237 ThunkArg \u2192 f i)\n    (unsafeCoerce a \u2237 ThunkArg)\n\nthunked \u2237 \u2200 a f i. (a \u2192 a \u2192 Boolean) \u2192 (a \u2192 f i) \u2192 a \u2192 Thunk f i\nthunked eqFn f =\n  let\n    tid = unsafeThunkId { f }\n    eqFn' = Fn.mkFn2 eqFn\n  in\n    \\a \u2192 Fn.runFn4 thunk tid eqFn' f a\n\nthunk1 \u2237 \u2200 a f i. Fn.Fn2 (a \u2192 f i) a (Thunk f i)\nthunk1 = Fn.mkFn2 \\f a \u2192 Fn.runFn4 thunk (unsafeThunkId f) Util.refEq f a\n\nthunk2 \u2237 \u2200 a b f i. Fn.Fn3 (a \u2192 b \u2192 f i) a b (Thunk f i)\nthunk2 =\n  let\n    eqFn = Fn.mkFn2 \\a b \u2192\n      Fn.runFn2 Util.refEq a._1 b._1 &&\n      Fn.runFn2 Util.refEq a._2 b._2\n  in\n    Fn.mkFn3 \\f a b \u2192\n      Fn.runFn4 thunk (unsafeThunkId f) eqFn (\\{ _1, _2 } \u2192 f _1 _2) { _1: a, _2: b }\n\nthunk3 \u2237 \u2200 a b c f i. Fn.Fn4 (a \u2192 b \u2192 c \u2192 f i) a b c (Thunk f i)\nthunk3 =\n  let\n    eqFn = Fn.mkFn2 \\a b \u2192\n      Fn.runFn2 Util.refEq a._1 b._1 &&\n      Fn.runFn2 Util.refEq a._2 b._2 &&\n      Fn.runFn2 Util.refEq a._3 b._3\n  in\n    Fn.mkFn4 \\f a b c \u2192\n      Fn.runFn4 thunk (unsafeThunkId f) eqFn (\\{ _1, _2, _3 } \u2192 f _1 _2 _3) { _1: a, _2: b, _3: c }\n\nrunThunk \u2237 \u2200 f i. Thunk f i \u2192 f i\nrunThunk (Thunk _ _ render arg) = render arg\n\nunsafeEqThunk \u2237 \u2200 f i. Fn.Fn2 (Thunk f i) (Thunk f i) Boolean\nunsafeEqThunk = Fn.mkFn2 \\(Thunk a1 b1 _ d1) (Thunk a2 b2 _ d2) \u2192\n  Fn.runFn2 Util.refEq a1 a2 &&\n  Fn.runFn2 Util.refEq b1 b2 &&\n  Fn.runFn2 b1 d1 d2\n\ntype ThunkState :: (Type -> Type) -> Type -> Type -> Type -> Type\ntype ThunkState f i a w =\n  { thunk \u2237 Thunk f i\n  , vdom \u2237 M.Step (V.VDom a w) Node\n  }\n\nbuildThunk\n  \u2237 \u2200 f i a w\n  . (f i \u2192 V.VDom a w)\n  \u2192 V.VDomSpec a w\n  \u2192 V.Machine (Thunk f i) Node\nbuildThunk toVDom = renderThunk\n  where\n  renderThunk \u2237 V.VDomSpec a w \u2192 V.Machine (Thunk f i) Node\n  renderThunk spec = EFn.mkEffectFn1 \\t \u2192 do\n    vdom \u2190 EFn.runEffectFn1 (V.buildVDom spec) (toVDom (runThunk t))\n    pure $ M.mkStep $ M.Step (M.extract vdom) { thunk: t, vdom } patchThunk haltThunk\n\n  patchThunk \u2237 EFn.EffectFn2 (ThunkState f i a w) (Thunk f i) (V.Step (Thunk f i) Node)\n  patchThunk = EFn.mkEffectFn2 \\state t2 \u2192 do\n    let { vdom: prev, thunk: t1 } = state\n    if Fn.runFn2 unsafeEqThunk t1 t2\n      then pure $ M.mkStep $ M.Step (M.extract prev) state patchThunk haltThunk\n      else do\n        vdom \u2190 EFn.runEffectFn2 M.step prev (toVDom (runThunk t2))\n        pure $ M.mkStep $ M.Step (M.extract vdom) { vdom, thunk: t2 } patchThunk haltThunk\n\n  haltThunk \u2237 EFn.EffectFn1 (ThunkState f i a w) Unit\n  haltThunk = EFn.mkEffectFn1 \\state \u2192 do\n    EFn.runEffectFn1 M.halt state.vdom\n", "module Halogen.HTML.Elements\n  ( Node\n  , Leaf\n  , element\n  , elementNS\n  , keyed\n  , keyedNS\n  , withKeys\n  , withKeys_\n  , a\n  , a_\n  , abbr\n  , abbr_\n  , address\n  , address_\n  , area\n  , article\n  , article_\n  , aside\n  , aside_\n  , audio\n  , audio_\n  , b\n  , b_\n  , base\n  , bdi\n  , bdi_\n  , bdo\n  , bdo_\n  , blockquote\n  , blockquote_\n  , body\n  , body_\n  , br\n  , br_\n  , button\n  , button_\n  , canvas\n  , caption\n  , caption_\n  , cite\n  , cite_\n  , code\n  , code_\n  , col\n  , colgroup\n  , colgroup_\n  , command\n  , datalist\n  , datalist_\n  , dd\n  , dd_\n  , del\n  , del_\n  , details\n  , details_\n  , dfn\n  , dfn_\n  , dialog\n  , dialog_\n  , div\n  , div_\n  , dl\n  , dl_\n  , dt\n  , dt_\n  , em\n  , em_\n  , embed\n  , embed_\n  , fieldset\n  , fieldset_\n  , figcaption\n  , figcaption_\n  , figure\n  , figure_\n  , footer\n  , footer_\n  , form\n  , form_\n  , h1\n  , h1_\n  , h2\n  , h2_\n  , h3\n  , h3_\n  , h4\n  , h4_\n  , h5\n  , h5_\n  , h6\n  , h6_\n  , head\n  , head_\n  , header\n  , header_\n  , hr\n  , hr_\n  , html\n  , html_\n  , i\n  , i_\n  , iframe\n  , img\n  , input\n  , ins\n  , ins_\n  , kbd\n  , kbd_\n  , label\n  , label_\n  , legend\n  , legend_\n  , li\n  , li_\n  , link\n  , main\n  , main_\n  , map\n  , map_\n  , mark\n  , mark_\n  , menu\n  , menu_\n  , menuitem\n  , menuitem_\n  , meta\n  , meter\n  , meter_\n  , nav\n  , nav_\n  , noscript\n  , noscript_\n  , object\n  , object_\n  , ol\n  , ol_\n  , optgroup\n  , optgroup_\n  , option\n  , option_\n  , output\n  , output_\n  , p\n  , p_\n  , param\n  , pre\n  , pre_\n  , progress\n  , progress_\n  , q\n  , q_\n  , rp\n  , rp_\n  , rt\n  , rt_\n  , ruby\n  , ruby_\n  , samp\n  , samp_\n  , script\n  , script_\n  , section\n  , section_\n  , select\n  , select_\n  , small\n  , small_\n  , source\n  , span\n  , span_\n  , strong\n  , strong_\n  , style\n  , style_\n  , sub\n  , sub_\n  , summary\n  , summary_\n  , sup\n  , sup_\n  , table\n  , table_\n  , tbody\n  , tbody_\n  , td\n  , td_\n  , textarea\n  , tfoot\n  , tfoot_\n  , th\n  , th_\n  , thead\n  , thead_\n  , time\n  , time_\n  , title\n  , title_\n  , tr\n  , tr_\n  , track\n  , u\n  , u_\n  , ul\n  , ul_\n  , var\n  , var_\n  , video\n  , video_\n  , wbr\n  ) where\n\nimport Prelude ((#), (>>>), pure)\nimport Data.Maybe (Maybe(Nothing))\nimport Data.Tuple (Tuple)\n\nimport DOM.HTML.Indexed as I\n\nimport Halogen.HTML.Core (ElemName(..), HTML(..), Namespace, Prop)\nimport Halogen.HTML.Core as Core\nimport Halogen.HTML.Properties (IProp)\nimport Halogen.Query.Input (Input)\nimport Halogen.VDom as VDom\n\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | An HTML element that admits children.\ntype Node r w i = Array (IProp r i) -> Array (HTML w i) -> HTML w i\n\n-- | An HTML element that does not admit children.\ntype Leaf r w i = Array (IProp r i) -> HTML w i\n\n-- | Creates an HTML element that expects indexed properties.\nelement :: forall r w i. ElemName -> Array (IProp r i) -> Array (HTML w i) -> HTML w i\nelement =\n  Core.element Nothing #\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (HTML w i) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (HTML w i)\n        -> HTML w i\n    )\n\n-- | Creates a Namespaced HTML element that expects indexed properties.\nelementNS :: forall r w i. Namespace -> ElemName -> Array (IProp r i) -> Array (HTML w i) -> HTML w i\nelementNS =\n  pure >>> Core.element >>>\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (HTML w i) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (HTML w i)\n        -> HTML w i\n    )\n\n-- | Creates an HTML element that expects indexed properties, with keyed\n-- | children.\nkeyed :: forall r w i. ElemName -> Array (IProp r i) -> Array (Tuple String (HTML w i)) -> HTML w i\nkeyed =\n  Core.keyed Nothing #\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (Tuple String (HTML w i)) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (Tuple String (HTML w i))\n        -> HTML w i\n    )\n\n-- | Creates a Namespaced HTML element that expects indexed properties, with\n-- | keyed children.\nkeyedNS :: forall r w i. Namespace -> ElemName -> Array (IProp r i) -> Array (Tuple String (HTML w i)) -> HTML w i\nkeyedNS =\n  pure >>> Core.keyed >>>\n    ( unsafeCoerce\n        :: (ElemName -> Array (Prop i) -> Array (Tuple String (HTML w i)) -> HTML w i)\n        -> ElemName\n        -> Array (IProp r i)\n        -> Array (Tuple String (HTML w i))\n        -> HTML w i\n    )\n\nwithKeys :: forall r w i. (Array (IProp r i) -> Array (HTML w i) -> HTML w i) -> Array (IProp r i) -> Array (Tuple String (HTML w i)) -> HTML w i\nwithKeys ctor props children =\n  case ctor props [] of\n    HTML (VDom.Elem x y z _) -> HTML (VDom.Keyed x y z (coe children))\n    h -> h\n  where\n  coe :: Array (Tuple String (HTML w i)) -> Array (Tuple String (VDom.VDom (Array (Prop (Input i))) w))\n  coe = unsafeCoerce\n\nwithKeys_ :: forall w i. (Array (HTML w i) -> HTML w i) -> Array (Tuple String (HTML w i)) -> HTML w i\nwithKeys_ ctor children =\n  case ctor [] of\n    HTML (VDom.Elem x y z _) -> HTML (VDom.Keyed x y z (coe children))\n    h -> h\n  where\n  coe :: Array (Tuple String (HTML w i)) -> Array (Tuple String (VDom.VDom (Array (Prop (Input i))) w))\n  coe = unsafeCoerce\n\na :: forall w i. Node I.HTMLa w i\na = element (ElemName \"a\")\n\na_ :: forall w i. Array (HTML w i) -> HTML w i\na_ = a []\n\nabbr :: forall w i. Node I.HTMLabbr w i\nabbr = element (ElemName \"abbr\")\n\nabbr_ :: forall w i. Array (HTML w i) -> HTML w i\nabbr_ = abbr []\n\naddress :: forall w i. Node I.HTMLaddress w i\naddress = element (ElemName \"address\")\n\naddress_ :: forall w i. Array (HTML w i) -> HTML w i\naddress_ = address []\n\narea :: forall w i. Leaf I.HTMLarea w i\narea props = element (ElemName \"area\") props []\n\narticle :: forall w i. Node I.HTMLarticle w i\narticle = element (ElemName \"article\")\n\narticle_ :: forall w i. Array (HTML w i) -> HTML w i\narticle_ = article []\n\naside :: forall w i. Node I.HTMLaside w i\naside = element (ElemName \"aside\")\n\naside_ :: forall w i. Array (HTML w i) -> HTML w i\naside_ = aside []\n\naudio :: forall w i. Node I.HTMLaudio w i\naudio = element (ElemName \"audio\")\n\naudio_ :: forall w i. Array (HTML w i) -> HTML w i\naudio_ = audio []\n\nb :: forall w i. Node I.HTMLb w i\nb = element (ElemName \"b\")\n\nb_ :: forall w i. Array (HTML w i) -> HTML w i\nb_ = b []\n\nbase :: forall w i. Leaf I.HTMLbase w i\nbase props = element (ElemName \"base\") props []\n\nbdi :: forall w i. Node I.HTMLbdi w i\nbdi = element (ElemName \"bdi\")\n\nbdi_ :: forall w i. Array (HTML w i) -> HTML w i\nbdi_ = bdi []\n\nbdo :: forall w i. Node I.HTMLbdo w i\nbdo = element (ElemName \"bdo\")\n\nbdo_ :: forall w i. Array (HTML w i) -> HTML w i\nbdo_ = bdo []\n\nblockquote :: forall w i. Node I.HTMLblockquote w i\nblockquote = element (ElemName \"blockquote\")\n\nblockquote_ :: forall w i. Array (HTML w i) -> HTML w i\nblockquote_ = blockquote []\n\nbody :: forall w i. Node I.HTMLbody w i\nbody = element (ElemName \"body\")\n\nbody_ :: forall w i. Array (HTML w i) -> HTML w i\nbody_ = body []\n\nbr :: forall w i. Leaf I.HTMLbr w i\nbr props = element (ElemName \"br\") props []\n\nbr_ :: forall w i. HTML w i\nbr_ = br []\n\nbutton :: forall w i. Node I.HTMLbutton w i\nbutton = element (ElemName \"button\")\n\nbutton_ :: forall w i. Array (HTML w i) -> HTML w i\nbutton_ = button []\n\ncanvas :: forall w i. Leaf I.HTMLcanvas w i\ncanvas props = element (ElemName \"canvas\") props []\n\ncaption :: forall w i. Node I.HTMLcaption w i\ncaption = element (ElemName \"caption\")\n\ncaption_ :: forall w i. Array (HTML w i) -> HTML w i\ncaption_ = caption []\n\ncite :: forall w i. Node I.HTMLcite w i\ncite = element (ElemName \"cite\")\n\ncite_ :: forall w i. Array (HTML w i) -> HTML w i\ncite_ = cite []\n\ncode :: forall w i. Node I.HTMLcode w i\ncode = element (ElemName \"code\")\n\ncode_ :: forall w i. Array (HTML w i) -> HTML w i\ncode_ = code []\n\ncol :: forall w i. Leaf I.HTMLcol w i\ncol props = element (ElemName \"col\") props []\n\ncolgroup :: forall w i. Node I.HTMLcolgroup w i\ncolgroup = element (ElemName \"colgroup\")\n\ncolgroup_ :: forall w i. Array (HTML w i) -> HTML w i\ncolgroup_ = colgroup []\n\ncommand :: forall w i. Leaf I.HTMLcommand w i\ncommand props = element (ElemName \"command\") props []\n\ndatalist :: forall w i. Node I.HTMLdatalist w i\ndatalist = element (ElemName \"datalist\")\n\ndatalist_ :: forall w i. Array (HTML w i) -> HTML w i\ndatalist_ = datalist []\n\ndd :: forall w i. Node I.HTMLdd w i\ndd = element (ElemName \"dd\")\n\ndd_ :: forall w i. Array (HTML w i) -> HTML w i\ndd_ = dd []\n\ndel :: forall w i. Node I.HTMLdel w i\ndel = element (ElemName \"del\")\n\ndel_ :: forall w i. Array (HTML w i) -> HTML w i\ndel_ = del []\n\ndetails :: forall w i. Node I.HTMLdetails w i\ndetails = element (ElemName \"details\")\n\ndetails_ :: forall w i. Array (HTML w i) -> HTML w i\ndetails_ = details []\n\ndfn :: forall w i. Node I.HTMLdfn w i\ndfn = element (ElemName \"dfn\")\n\ndfn_ :: forall w i. Array (HTML w i) -> HTML w i\ndfn_ = dfn []\n\ndialog :: forall w i. Node I.HTMLdialog w i\ndialog = element (ElemName \"dialog\")\n\ndialog_ :: forall w i. Array (HTML w i) -> HTML w i\ndialog_ = dialog []\n\ndiv :: forall w i. Node I.HTMLdiv w i\ndiv = element (ElemName \"div\")\n\ndiv_ :: forall w i. Array (HTML w i) -> HTML w i\ndiv_ = div []\n\ndl :: forall w i. Node I.HTMLdl w i\ndl = element (ElemName \"dl\")\n\ndl_ :: forall w i. Array (HTML w i) -> HTML w i\ndl_ = dl []\n\ndt :: forall w i. Node (I.HTMLdt) w i\ndt = element (ElemName \"dt\")\n\ndt_ :: forall w i. Array (HTML w i) -> HTML w i\ndt_ = dt []\n\nem :: forall w i. Node I.HTMLem w i\nem = element (ElemName \"em\")\n\nem_ :: forall w i. Array (HTML w i) -> HTML w i\nem_ = em []\n\nembed :: forall w i. Node I.HTMLembed w i\nembed = element (ElemName \"embed\")\n\nembed_ :: forall w i. Array (HTML w i) -> HTML w i\nembed_ = embed []\n\nfieldset :: forall w i. Node I.HTMLfieldset w i\nfieldset = element (ElemName \"fieldset\")\n\nfieldset_ :: forall w i. Array (HTML w i) -> HTML w i\nfieldset_ = fieldset []\n\nfigcaption :: forall w i. Node I.HTMLfigcaption w i\nfigcaption = element (ElemName \"figcaption\")\n\nfigcaption_ :: forall w i. Array (HTML w i) -> HTML w i\nfigcaption_ = figcaption []\n\nfigure :: forall w i. Node I.HTMLfigure w i\nfigure = element (ElemName \"figure\")\n\nfigure_ :: forall w i. Array (HTML w i) -> HTML w i\nfigure_ = figure []\n\nfooter :: forall w i. Node I.HTMLfooter w i\nfooter = element (ElemName \"footer\")\n\nfooter_ :: forall w i. Array (HTML w i) -> HTML w i\nfooter_ = footer []\n\nform :: forall w i. Node I.HTMLform w i\nform = element (ElemName \"form\")\n\nform_ :: forall w i. Array (HTML w i) -> HTML w i\nform_ = form []\n\nh1 :: forall w i. Node I.HTMLh1 w i\nh1 = element (ElemName \"h1\")\n\nh1_ :: forall w i. Array (HTML w i) -> HTML w i\nh1_ = h1 []\n\nh2 :: forall w i. Node I.HTMLh2 w i\nh2 = element (ElemName \"h2\")\n\nh2_ :: forall w i. Array (HTML w i) -> HTML w i\nh2_ = h2 []\n\nh3 :: forall w i. Node I.HTMLh3 w i\nh3 = element (ElemName \"h3\")\n\nh3_ :: forall w i. Array (HTML w i) -> HTML w i\nh3_ = h3 []\n\nh4 :: forall w i. Node I.HTMLh4 w i\nh4 = element (ElemName \"h4\")\n\nh4_ :: forall w i. Array (HTML w i) -> HTML w i\nh4_ = h4 []\n\nh5 :: forall w i. Node I.HTMLh5 w i\nh5 = element (ElemName \"h5\")\n\nh5_ :: forall w i. Array (HTML w i) -> HTML w i\nh5_ = h5 []\n\nh6 :: forall w i. Node I.HTMLh6 w i\nh6 = element (ElemName \"h6\")\n\nh6_ :: forall w i. Array (HTML w i) -> HTML w i\nh6_ = h6 []\n\nhead :: forall w i. Node I.HTMLhead w i\nhead = element (ElemName \"head\")\n\nhead_ :: forall w i. Array (HTML w i) -> HTML w i\nhead_ = head []\n\nheader :: forall w i. Node I.HTMLheader w i\nheader = element (ElemName \"header\")\n\nheader_ :: forall w i. Array (HTML w i) -> HTML w i\nheader_ = header []\n\nhr :: forall w i. Leaf I.HTMLhr w i\nhr props = element (ElemName \"hr\") props []\n\nhr_ :: forall w i. HTML w i\nhr_ = hr []\n\nhtml :: forall w i. Node I.HTMLhtml w i\nhtml = element (ElemName \"html\")\n\nhtml_ :: forall w i. Array (HTML w i) -> HTML w i\nhtml_ = html []\n\ni :: forall w i. Node I.HTMLi w i\ni = element (ElemName \"i\")\n\ni_ :: forall w i. Array (HTML w i) -> HTML w i\ni_ = i []\n\niframe :: forall w i. Leaf I.HTMLiframe w i\niframe props = element (ElemName \"iframe\") props []\n\nimg :: forall w i. Leaf I.HTMLimg w i\nimg props = element (ElemName \"img\") props []\n\ninput :: forall w i. Leaf I.HTMLinput w i\ninput props = element (ElemName \"input\") props []\n\nins :: forall w i. Node I.HTMLins w i\nins = element (ElemName \"ins\")\n\nins_ :: forall w i. Array (HTML w i) -> HTML w i\nins_ = ins []\n\nkbd :: forall w i. Node I.HTMLkbd w i\nkbd = element (ElemName \"kbd\")\n\nkbd_ :: forall w i. Array (HTML w i) -> HTML w i\nkbd_ = kbd []\n\nlabel :: forall w i. Node I.HTMLlabel w i\nlabel = element (ElemName \"label\")\n\nlabel_ :: forall w i. Array (HTML w i) -> HTML w i\nlabel_ = label []\n\nlegend :: forall w i. Node I.HTMLlegend w i\nlegend = element (ElemName \"legend\")\n\nlegend_ :: forall w i. Array (HTML w i) -> HTML w i\nlegend_ = legend []\n\nli :: forall w i. Node I.HTMLli w i\nli = element (ElemName \"li\")\n\nli_ :: forall w i. Array (HTML w i) -> HTML w i\nli_ = li []\n\nlink :: forall w i. Leaf I.HTMLlink w i\nlink props = element (ElemName \"link\") props []\n\nmain :: forall w i. Node I.HTMLmain w i\nmain = element (ElemName \"main\")\n\nmain_ :: forall w i. Array (HTML w i) -> HTML w i\nmain_ = main []\n\nmap :: forall w i. Node I.HTMLmap w i\nmap = element (ElemName \"map\")\n\nmap_ :: forall w i. Array (HTML w i) -> HTML w i\nmap_ = map []\n\nmark :: forall w i. Node I.HTMLmark w i\nmark = element (ElemName \"mark\")\n\nmark_ :: forall w i. Array (HTML w i) -> HTML w i\nmark_ = mark []\n\nmenu :: forall w i. Node I.HTMLmenu w i\nmenu = element (ElemName \"menu\")\n\nmenu_ :: forall w i. Array (HTML w i) -> HTML w i\nmenu_ = menu []\n\nmenuitem :: forall w i. Node I.HTMLmenuitem w i\nmenuitem = element (ElemName \"menuitem\")\n\nmenuitem_ :: forall w i. Array (HTML w i) -> HTML w i\nmenuitem_ = menuitem []\n\nmeta :: forall w i. Leaf I.HTMLmeta w i\nmeta props = element (ElemName \"meta\") props []\n\nmeter :: forall w i. Node I.HTMLmeter w i\nmeter = element (ElemName \"meter\")\n\nmeter_ :: forall w i. Array (HTML w i) -> HTML w i\nmeter_ = meter []\n\nnav :: forall w i. Node I.HTMLnav w i\nnav = element (ElemName \"nav\")\n\nnav_ :: forall w i. Array (HTML w i) -> HTML w i\nnav_ = nav []\n\nnoscript :: forall w i. Node I.HTMLnoscript w i\nnoscript = element (ElemName \"noscript\")\n\nnoscript_ :: forall w i. Array (HTML w i) -> HTML w i\nnoscript_ = noscript []\n\nobject :: forall w i. Node I.HTMLobject w i\nobject = element (ElemName \"object\")\n\nobject_ :: forall w i. Array (HTML w i) -> HTML w i\nobject_ = object []\n\nol :: forall w i. Node I.HTMLol w i\nol = element (ElemName \"ol\")\n\nol_ :: forall w i. Array (HTML w i) -> HTML w i\nol_ = ol []\n\noptgroup :: forall w i. Node I.HTMLoptgroup w i\noptgroup = element (ElemName \"optgroup\")\n\noptgroup_ :: forall w i. Array (HTML w i) -> HTML w i\noptgroup_ = optgroup []\n\noption :: forall w i. Node I.HTMLoption w i\noption = element (ElemName \"option\")\n\noption_ :: forall w i. Array (HTML w i) -> HTML w i\noption_ = option []\n\noutput :: forall w i. Node I.HTMLoutput w i\noutput = element (ElemName \"output\")\n\noutput_ :: forall w i. Array (HTML w i) -> HTML w i\noutput_ = output []\n\np :: forall w i. Node I.HTMLp w i\np = element (ElemName \"p\")\n\np_ :: forall w i. Array (HTML w i) -> HTML w i\np_ = p []\n\nparam :: forall w i. Leaf I.HTMLparam w i\nparam props = element (ElemName \"param\") props []\n\npre :: forall w i. Node I.HTMLpre w i\npre = element (ElemName \"pre\")\n\npre_ :: forall w i. Array (HTML w i) -> HTML w i\npre_ = pre []\n\nprogress :: forall w i. Node I.HTMLprogress w i\nprogress = element (ElemName \"progress\")\n\nprogress_ :: forall w i. Array (HTML w i) -> HTML w i\nprogress_ = progress []\n\nq :: forall w i. Node I.HTMLq w i\nq = element (ElemName \"q\")\n\nq_ :: forall w i. Array (HTML w i) -> HTML w i\nq_ = q []\n\nrp :: forall w i. Node I.HTMLrp w i\nrp = element (ElemName \"rp\")\n\nrp_ :: forall w i. Array (HTML w i) -> HTML w i\nrp_ = rp []\n\nrt :: forall w i. Node I.HTMLrt w i\nrt = element (ElemName \"rt\")\n\nrt_ :: forall w i. Array (HTML w i) -> HTML w i\nrt_ = rt []\n\nruby :: forall w i. Node I.HTMLruby w i\nruby = element (ElemName \"ruby\")\n\nruby_ :: forall w i. Array (HTML w i) -> HTML w i\nruby_ = ruby []\n\nsamp :: forall w i. Node I.HTMLsamp w i\nsamp = element (ElemName \"samp\")\n\nsamp_ :: forall w i. Array (HTML w i) -> HTML w i\nsamp_ = samp []\n\nscript :: forall w i. Node I.HTMLscript w i\nscript = element (ElemName \"script\")\n\nscript_ :: forall w i. Array (HTML w i) -> HTML w i\nscript_ = script []\n\nsection :: forall w i. Node I.HTMLsection w i\nsection = element (ElemName \"section\")\n\nsection_ :: forall w i. Array (HTML w i) -> HTML w i\nsection_ = section []\n\nselect :: forall w i. Node I.HTMLselect w i\nselect = element (ElemName \"select\")\n\nselect_ :: forall w i. Array (HTML w i) -> HTML w i\nselect_ = select []\n\nsmall :: forall w i. Node I.HTMLsmall w i\nsmall = element (ElemName \"small\")\n\nsmall_ :: forall w i. Array (HTML w i) -> HTML w i\nsmall_ = small []\n\nsource :: forall w i. Leaf I.HTMLsource w i\nsource props = element (ElemName \"source\") props []\n\nspan :: forall w i. Node I.HTMLspan w i\nspan = element (ElemName \"span\")\n\nspan_ :: forall w i. Array (HTML w i) -> HTML w i\nspan_ = span []\n\nstrong :: forall w i. Node I.HTMLstrong w i\nstrong = element (ElemName \"strong\")\n\nstrong_ :: forall w i. Array (HTML w i) -> HTML w i\nstrong_ = strong []\n\nstyle :: forall w i. Node I.HTMLstyle w i\nstyle = element (ElemName \"style\")\n\nstyle_ :: forall w i. Array (HTML w i) -> HTML w i\nstyle_ = style []\n\nsub :: forall w i. Node I.HTMLsub w i\nsub = element (ElemName \"sub\")\n\nsub_ :: forall w i. Array (HTML w i) -> HTML w i\nsub_ = sub []\n\nsummary :: forall w i. Node I.HTMLsummary w i\nsummary = element (ElemName \"summary\")\n\nsummary_ :: forall w i. Array (HTML w i) -> HTML w i\nsummary_ = summary []\n\nsup :: forall w i. Node I.HTMLsup w i\nsup = element (ElemName \"sup\")\n\nsup_ :: forall w i. Array (HTML w i) -> HTML w i\nsup_ = sup []\n\ntable :: forall w i. Node I.HTMLtable w i\ntable = element (ElemName \"table\")\n\ntable_ :: forall w i. Array (HTML w i) -> HTML w i\ntable_ = table []\n\ntbody :: forall w i. Node I.HTMLtbody w i\ntbody = element (ElemName \"tbody\")\n\ntbody_ :: forall w i. Array (HTML w i) -> HTML w i\ntbody_ = tbody []\n\ntd :: forall w i. Node I.HTMLtd w i\ntd = element (ElemName \"td\")\n\ntd_ :: forall w i. Array (HTML w i) -> HTML w i\ntd_ = td []\n\ntextarea :: forall w i. Leaf I.HTMLtextarea w i\ntextarea es = element (ElemName \"textarea\") es []\n\ntfoot :: forall w i. Node I.HTMLtfoot w i\ntfoot = element (ElemName \"tfoot\")\n\ntfoot_ :: forall w i. Array (HTML w i) -> HTML w i\ntfoot_ = tfoot []\n\nth :: forall w i. Node I.HTMLth w i\nth = element (ElemName \"th\")\n\nth_ :: forall w i. Array (HTML w i) -> HTML w i\nth_ = th []\n\nthead :: forall w i. Node I.HTMLthead w i\nthead = element (ElemName \"thead\")\n\nthead_ :: forall w i. Array (HTML w i) -> HTML w i\nthead_ = thead []\n\ntime :: forall w i. Node I.HTMLtime w i\ntime = element (ElemName \"time\")\n\ntime_ :: forall w i. Array (HTML w i) -> HTML w i\ntime_ = time []\n\ntitle :: forall w i. Node I.HTMLtitle w i\ntitle = element (ElemName \"title\")\n\ntitle_ :: forall w i. Array (HTML w i) -> HTML w i\ntitle_ = title []\n\ntr :: forall w i. Node I.HTMLtr w i\ntr = element (ElemName \"tr\")\n\ntr_ :: forall w i. Array (HTML w i) -> HTML w i\ntr_ = tr []\n\ntrack :: forall w i. Leaf I.HTMLtrack w i\ntrack props = element (ElemName \"track\") props []\n\nu :: forall w i. Node I.HTMLu w i\nu = element (ElemName \"u\")\n\nu_ :: forall w i. Array (HTML w i) -> HTML w i\nu_ = u []\n\nul :: forall w i. Node I.HTMLul w i\nul = element (ElemName \"ul\")\n\nul_ :: forall w i. Array (HTML w i) -> HTML w i\nul_ = ul []\n\nvar :: forall w i. Node I.HTMLvar w i\nvar = element (ElemName \"var\")\n\nvar_ :: forall w i. Array (HTML w i) -> HTML w i\nvar_ = var []\n\nvideo :: forall w i. Node I.HTMLvideo w i\nvideo = element (ElemName \"video\")\n\nvideo_ :: forall w i. Array (HTML w i) -> HTML w i\nvideo_ = video []\n\nwbr :: forall w i. Leaf I.HTMLwbr w i\nwbr props = element (ElemName \"wbr\") props []\n", "module Halogen.Query.Event where\n\nimport Prelude\n\nimport Data.Foldable (traverse_)\nimport Data.Maybe (Maybe)\nimport Halogen.Subscription as HS\nimport Web.Event.Event as Event\nimport Web.Event.EventTarget as EventTarget\n\n-- | Constructs an `Emitter` for a DOM event. Accepts a function that maps event\n-- | values to a `Maybe`-wrapped action, allowing it to filter events if\n-- | necessary.\neventListener\n  :: forall a\n   . Event.EventType\n  -> EventTarget.EventTarget\n  -> (Event.Event -> Maybe a)\n  -> HS.Emitter a\neventListener eventType target f =\n  HS.makeEmitter \\push -> do\n    listener <- EventTarget.eventListener \\ev -> traverse_ push (f ev)\n    EventTarget.addEventListener eventType listener false target\n    pure do\n      EventTarget.removeEventListener eventType listener false target\n", "-- | Gesso Canvas is a Halogen component that handles creating a canvas element,\n-- | calling requestAnimationFrame, attaching events, and running render and\n-- | update functions.\nmodule Gesso.Canvas\n  ( Action\n  , Input\n  , Query(..)\n  , Slot\n  , Output(..)\n  , _gessoCanvas\n  , component\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (foldr, traverse_)\nimport Data.Function (on)\nimport Data.List (List, (:))\nimport Data.List as List\nimport Data.Maybe (Maybe(..), maybe)\nimport Data.Traversable (for, traverse)\nimport Data.Tuple (Tuple)\nimport Data.Tuple.Nested ((/\\))\nimport Effect (Effect)\nimport Effect.Aff.Class (class MonadAff)\nimport Gesso.Application as App\nimport Gesso.Canvas.Element as GEl\nimport Gesso.Dimensions as Dims\nimport Gesso.Interactions as GI\nimport Gesso.Time as T\nimport Graphics.Canvas (Context2D)\nimport Halogen (liftEffect)\nimport Halogen as H\nimport Halogen.HTML (memoized, canvas) as HH\nimport Halogen.HTML.Properties (id, tabIndex)\nimport Halogen.Query.Event as HE\nimport Halogen.Subscription as HS\nimport Type.Proxy (Proxy(..))\nimport Web.Event.Event (EventType(..))\nimport Web.HTML (window)\nimport Web.HTML.Window (toEventTarget)\n\n-- | The Halogen slot type for Canvas, which is used to include it inside\n-- | another Halogen component.\ntype Slot input output slot = H.Slot (Query input) (Output output) slot\n\n-- | A proxy type for Canvas provided for convenience, for use with Slot.\n_gessoCanvas = Proxy :: Proxy \"gessoCanvas\"\n\n-- | The internal state of the Canvas component\n-- |\n-- | - `name` is the name of the application, which doubles as the HTML `id` for\n-- |   the canvas element.\n-- | - `app` is an `AppSpec`.\n-- | - `localState` is the state of the application.\n-- | - `viewBox` is the position and dimensions of the drawing area.\n-- | - `interactions` is the events attached to the canvas element.\n-- | - `dom`: DOM-related fields available after initialization:\n-- |   - `clientRect` is the actual position and dimensions of the canvas\n-- |     element.\n-- |   - `canvas` is the canvas element.\n-- |   - `context` is the `Context2D` for the canvas element.\n-- |   - `scaler` is the scaler record that converts between viewbox and client\n-- |     rect coordinates.\n-- | - `subscriptions`: Event subscriptions created during initialization and\n-- |   kept until the application is destroyed.\n-- |   - `resize` is a subscription to window resize events, to re-check the\n-- |     `clientRect` and recreate the `scaler`.\n-- |   - `emitter` is a subscription to a listener/emitter pair used to send\n-- |     Actions from `requestAnimationFrame` callbacks to the component.\n-- | - `queuedUpdates` is a list of interactions and Query inputs waiting to be\n-- |   applied.\n-- | - `processingUpdates` is a list of interactions and Query inputs that have\n-- |   been passed to the animation frame to be applied, but which may not have\n-- |   been applied yet.\n-- | - `rafId` is the ID of the most recently requested animation frame. It's\n-- |   set when `requestAnimationFrame` is called and cleared when the animation\n-- |   frame callback runs.\ntype State localState appInput appOutput =\n  { name :: String\n  , app :: App.AppSpec Context2D localState appInput appOutput\n  , localState :: localState\n  , viewBox :: Dims.ViewBox\n  , interactions :: GI.Interactions localState (Action localState)\n  , dom ::\n      Maybe\n        { clientRect :: Dims.ClientRect\n        , canvas :: GEl.Canvas\n        , context :: Context2D\n        , scaler :: Dims.Scaler\n        }\n  , subscriptions ::\n      Maybe\n        { resize :: H.SubscriptionId\n        , emitter :: H.SubscriptionId\n        }\n  , queuedUpdates :: List (App.UpdateFunction localState)\n  , processingUpdates :: List (App.UpdateFunction localState)\n  , rafId :: Maybe T.RequestAnimationFrameId\n  }\n\n-- | See [`handleAction`](#v:handleAction)\ndata Action localState\n  = Initialize\n  | HandleResize\n  | FirstTick (Action localState -> Effect Unit)\n  | Tick (Action localState -> Effect Unit) T.Last\n  | Finalize\n  | StateUpdated T.Delta Dims.Scaler localState\n  | QueueUpdate (App.UpdateFunction localState)\n  | UpdatesProcessed\n  | FrameRequested T.RequestAnimationFrameId\n  | FrameFired\n\n-- | The component's output type is defined by the `OutputProducer` in the\n-- | `Application.AppSpec`.\nnewtype Output appOutput = Output appOutput\n\n-- | The component's input type is defined by the `InputReceiver` in the\n-- | `Application.AppSpec`.\ndata Query appInput a = Input appInput a\n\n-- | The input provided when the Canvas component is created. Because, of these\n-- | fields, the only one that should be changed from outside the component is\n-- | `localState`, the component has no `receive` defined in its `EvalSpec` (see\n-- | [`component`](#v:component)'s use of `defaultEval`) so that this input is\n-- | only read once.\n-- |\n-- | Instead, for outside changes to `localState`, an `input` function can be\n-- | provided in the `AppSpec`, and the `input` function will have access to the\n-- | same arguments as a regular update function.\n-- |\n-- | - `name` is the name of the application, which doubles as the HTML `id` for\n-- |   the canvas element. (Related:\n-- |   https://github.com/smilack/purescript-gesso/issues/4)\n-- | - `app` is the Application Spec.\n-- | - `localState` is the initial local state for the application.\n-- | - `viewBox` is the desired dimensions for the drawing surface.\n-- | - `interactions` is the events which will be attached to the\n-- |    canvas element.\ntype Input localState appInput appOutput =\n  { name :: String\n  , app :: App.AppSpec Context2D localState appInput appOutput\n  , localState :: localState\n  , viewBox :: Dims.ViewBox\n  , interactions :: GI.Interactions localState (Action localState)\n  }\n\n-- | Definition of the Canvas component. `render` is memoized so that it only\n-- | re-renders when the dimensions of the canvas element change.\ncomponent\n  :: forall localState appInput appOutput m\n   . MonadAff m\n  => H.Component (Query appInput) (Input localState appInput appOutput) (Output appOutput) m\ncomponent =\n  H.mkComponent\n    { initialState\n    , render: HH.memoized (eq `on` (_.dom >>> map _.clientRect)) render\n    , eval:\n        H.mkEval\n          $ H.defaultEval\n              { handleAction = handleAction\n              , handleQuery = handleQuery\n              , initialize = Just Initialize\n              , finalize = Just Finalize\n              }\n    }\n\n-- | Get initial state for Canvas. Most values are copied directly from the\n-- | input. The rest require Effects and are created in\n-- | [`initialize`](#v:initialize), except for the update queues, which start\n-- | empty.\ninitialState\n  :: forall localState appInput appOutput\n   . Input localState appInput appOutput\n  -> State localState appInput appOutput\ninitialState { name, app, localState, viewBox, interactions } =\n  { name\n  , app\n  , localState\n  , viewBox\n  , interactions\n  , dom: Nothing\n  , subscriptions: Nothing\n  , queuedUpdates: List.Nil\n  , processingUpdates: List.Nil\n  , rafId: Nothing\n  }\n\n-- | Render Canvas component. The `width` and `height` attributes may be\n-- | different from the CSS width and height. The CSS controls the area that the\n-- | element takes up on the page, while the HTML attributes control the\n-- | coordinate system of the drawing area.\nrender\n  :: forall localState appInput appOutput slots m\n   . State localState appInput appOutput\n  -> H.ComponentHTML (Action localState) slots m\nrender { name, dom, app, interactions } =\n  HH.canvas $ [ id name, GEl.style app.window, tabIndex 0 ]\n    <> GI.toProps QueueUpdate interactions\n    <> maybe [] Dims.toSizeProps (dom <#> _.clientRect)\n\n-- | - `Initialize`: Create `subscriptions` and `dom` records, then recurse with\n-- |   `FirstTick` to request the first animation frame.\n-- | - `HandleResize`: Window resized, get new client rect and recalculate\n-- |   `scaler` functions.\n-- | - `FirstTick`: Request an animation frame that only checks the time and\n-- |   then starts the `Tick` loop, so that `Tick` can start out knowing the\n-- |   frame timing.\n-- | - `Tick`: Request an animation frame. When animating, `Tick` passes the\n-- |   animation frame timestamp to itself so it can calculate the delta between\n-- |   frames.\n-- | - `Finalize`: Unsubscribe from window resize events and listener/emitter.\n-- | - `QueueUpdate`: An event (interaction or input) fired, add the handler to\n-- |   a queue to be run on the next animation frame.\n-- | - `UpdatesProcessed`: The `processingUpdates` queue was successfully\n-- |   processed in an animation frame, so those updates can be discarded.\n-- | - `StateUpdated`: The local state is changing. Save it and tell\n-- |   `Application` to handle output.\n-- | - `FrameRequested`: An animation frame has been requested, save its ID.\n-- | - `FrameFired`: The requested animation frame has fired, forget its ID.\nhandleAction\n  :: forall localState appInput appOutput slots m\n   . MonadAff m\n  => Action localState\n  -> H.HalogenM (State localState appInput appOutput) (Action localState) slots (Output appOutput) m Unit\nhandleAction = case _ of\n  Initialize -> initialize >>= (FirstTick >>> handleAction)\n\n  HandleResize -> updateClientRect\n\n  FirstTick notify -> H.liftEffect $ getFirstFrame notify\n\n  Tick notify lastTime -> H.gets _.dom >>= case _ of\n    -- if we get to this point and the dom stuff isn't available, something's\n    --   wrong, so just close\n    Nothing -> handleAction Finalize\n\n    -- otherwise, update and render\n    Just dom -> do\n      { localState, app, queuedUpdates, processingUpdates } <- H.get\n      -- Prepend any newly queued updates to the list of updates we've tried to\n      --   process, then empty the main queue and replace the processing queue\n      --   with the sum of both.\n      let\n        tryUpdates = queuedUpdates <> processingUpdates\n      H.modify_\n        ( _\n            { queuedUpdates = List.Nil\n            , processingUpdates = tryUpdates\n            }\n        )\n      H.liftEffect $ queueAnimationFrame\n        lastTime\n        dom.context\n        dom.scaler\n        tryUpdates\n        localState\n        app\n        notify\n\n  Finalize -> unsubscribe\n\n  -- Hold on to interactions/inputs until the next tick, then pass them into rAF\n  QueueUpdate handlerFn -> do\n    queuedUpdates <- H.gets _.queuedUpdates\n    H.modify_ (_ { queuedUpdates = handlerFn : queuedUpdates })\n\n  -- The interactions passed into an animation frame have been processed and are\n  --   no longer needed.\n  UpdatesProcessed -> H.modify_ (_ { processingUpdates = List.Nil })\n\n  StateUpdated delta scaler localState' -> saveNewState delta scaler localState'\n\n  FrameRequested rafId -> H.modify_ (_ { rafId = Just rafId })\n\n  FrameFired -> H.modify_ (_ { rafId = Nothing })\n\n-- | Subscribe to window resize events. Get the `canvas` element and its\n-- | `Context2D` and `clientRect`. Create scaling functions based on the\n-- | `viewBox` and `clientRect`.\ninitialize\n  :: forall localState appInput appOutput slots output m\n   . MonadAff m\n  => H.HalogenM\n       (State localState appInput appOutput)\n       (Action localState)\n       slots\n       output\n       m\n       (Action localState -> Effect Unit)\ninitialize = do\n  { notify, subscriptions } <- mkSubs\n  dom <- H.liftEffect <<< mkDom =<< H.get\n  H.modify_ (_ { dom = dom, subscriptions = Just subscriptions })\n  pure notify\n  where\n  mkSubs = do\n    notifications <- H.liftEffect HS.create\n    emitter <- H.subscribe notifications.emitter\n    resize <- subscribeResize\n    pure\n      { notify: HS.notify notifications.listener\n      , subscriptions: { resize, emitter }\n      }\n\n  mkDom { name, viewBox } = do\n    context <- GEl.getContextByAppName name\n    canvas <- GEl.getCanvasByAppName name\n    clientRect <- traverse GEl.getCanvasClientRect canvas\n    let scaler = Dims.mkScaler viewBox <$> clientRect\n    pure $\n      { clientRect: _, canvas: _, context: _, scaler: _ }\n        <$> clientRect\n        <*> canvas\n        <*> context\n        <*> scaler\n\n-- | The reusable chunk of requesting an animation frame:\n-- |\n-- | 1. Request the frame and tell the component that the frame was requested.\n-- | 2. When the frame fires, notify the component that the frame has fired and\n-- |    then call the provided callback function.\n-- | 3. After running the callback, tell the component to start the next Tick.\nrequestAnimationFrame\n  :: forall localState\n   . (T.Now -> Effect Unit)\n  -> (Action localState -> Effect Unit)\n  -> Effect Unit\nrequestAnimationFrame callback notify =\n  window\n    >>= T.requestAnimationFrame callbackWrapper\n    >>= (FrameRequested >>> notify)\n  where\n  callbackWrapper timestamp =\n    notify FrameFired\n      *> callback timestamp\n      *> tick timestamp\n\n  tick = notify <<< Tick notify <<< T.elapse\n\n-- | Request one animation frame in order to get a timestamp to start counting\n-- | from.\ngetFirstFrame\n  :: forall localState\n   . (Action localState -> Effect Unit)\n  -> Effect Unit\ngetFirstFrame = requestAnimationFrame (const $ pure unit)\n\n-- | Runs update and render functions:\n-- |\n-- | `updateAndRender` takes the list of queued update handlers and prepends the\n-- | component's update function. It folds over the list, calling each update\n-- | function, and tracking whether any of them changes the state. If one does,\n-- | a `StateUpdated` action is emitted, which will persist the change back to\n-- | the component and cause the component to check whether the change needs to\n-- | be outputted. Next, an action is emitted to let the component know that the\n-- | updates in the `processingUpdates` queue are complete. Finally, it calls\n-- | the app's render function.\nqueueAnimationFrame\n  :: forall localState appInput appOutput\n   . T.Last\n  -> Context2D\n  -> Dims.Scaler\n  -> List (App.UpdateFunction localState)\n  -> localState\n  -> App.AppSpec Context2D localState appInput appOutput\n  -> (Action localState -> Effect Unit)\n  -> Effect Unit\nqueueAnimationFrame lastTime context scaler queuedUpdates localState app notify =\n  requestAnimationFrame rafCallback notify\n  where\n  rafCallback :: T.Now -> Effect Unit\n  rafCallback timestamp = updateAndRender (T.delta timestamp lastTime)\n\n  -- TODO: There's a better way to do this and `applyUpdate`. Writer monad?\n  updateAndRender :: T.Delta -> Effect Unit\n  updateAndRender delta = do\n    changed /\\ state' <-\n      foldr\n        (applyUpdate delta)\n        (pure (DidNotChange /\\ localState))\n        (app.update : queuedUpdates)\n\n    case changed of\n      Changed -> notify $ StateUpdated delta scaler state'\n      DidNotChange -> pure unit\n\n    notify UpdatesProcessed\n\n    app.render state' delta scaler context\n\n  applyUpdate\n    :: T.Delta\n    -> App.UpdateFunction localState\n    -> Effect (Tuple StateChanged localState)\n    -> Effect (Tuple StateChanged localState)\n  applyUpdate delta update s = do\n    (_ /\\ state) <- s\n\n    mstate' <- update delta scaler state\n\n    case mstate' of\n      Just state' -> pure $ Changed /\\ state'\n      Nothing -> s\n\n-- | A simple type to track whether the local state changed while running\n-- | interactions and updates.\ndata StateChanged\n  = Changed\n  | DidNotChange\n\n-- | Get a new `clientRect` for the `canvas` element and create a new scaler for\n-- | it, saving both to the component state.\nupdateClientRect\n  :: forall localState appInput appOutput action slots output m\n   . MonadAff m\n  => H.HalogenM (State localState appInput appOutput) action slots output m Unit\nupdateClientRect = do\n  dom' <- H.liftEffect <<< updateDom =<< H.get\n  H.modify_ (_ { dom = dom' })\n  where\n  updateDom { viewBox, dom } = for dom \\d -> do\n    clientRect <- GEl.getCanvasClientRect d.canvas\n    pure d\n      { clientRect = clientRect\n      , scaler = Dims.mkScaler viewBox clientRect\n      }\n\n-- | Unsubscribe from window resize events and paired listener/emitter.\nunsubscribe\n  :: forall localState appInput appOutput action slots output m\n   . MonadAff m\n  => H.HalogenM (State localState appInput appOutput) action slots output m Unit\nunsubscribe =\n  H.gets _.subscriptions\n    >>= traverse_ \\subs -> do\n      H.unsubscribe subs.resize\n      H.unsubscribe subs.emitter\n\n-- | Subscribe to window resize events and fire the `HandleResize` `Action` when\n-- | they occur.\nsubscribeResize\n  :: forall localState appInput appOutput slots output m\n   . MonadAff m\n  => H.HalogenM (State localState appInput appOutput) (Action localState) slots output m H.SubscriptionId\nsubscribeResize = do\n  wnd <- H.liftEffect window\n  H.subscribe\n    $ HE.eventListener\n        (EventType \"resize\")\n        (toEventTarget wnd)\n        (const $ Just HandleResize)\n\n-- | Save the updated local state of the application. Compare the old and new\n-- | states in the `OutputProducer` function and send output, if necessary.\nsaveNewState\n  :: forall localState appInput appOutput slots m\n   . MonadAff m\n  => T.Delta\n  -> Dims.Scaler\n  -> localState\n  -> H.HalogenM (State localState appInput appOutput) (Action localState) slots (Output appOutput) m Unit\nsaveNewState delta scaler state' = do\n  { app: { output }, localState } <- H.get\n  H.modify_ (_ { localState = state' })\n  mOutput <- liftEffect $ output delta scaler localState state'\n  traverse_ (H.raise <<< Output) mOutput\n\n-- | Receiving input from the host application. Convert it into an `Update` and\n-- | call `handleAction` to add it to the update queue.\nhandleQuery\n  :: forall localState appInput appOutput slots a m\n   . MonadAff m\n  => Query appInput a\n  -> H.HalogenM (State localState appInput appOutput) (Action localState) slots (Output appOutput) m (Maybe a)\nhandleQuery (Input inData a) = do\n  { app: { input } } <- H.get\n  handleAction $ QueueUpdate $ input inData\n  pure (Just a)\n", "module Control.Monad.Fork.Class where\n\nimport Prelude hiding (join)\n\nimport Effect.Aff as Aff\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError)\nimport Control.Monad.Reader.Trans (ReaderT(..), runReaderT)\nimport Control.Monad.Trans.Class (lift)\n\n-- | Represents Monads which can be forked asynchronously.\n-- |\n-- | Laws:\n-- |\n-- | ```purescript\n-- | -- Unjoined suspension is a no-op\n-- | suspend a1 *> suspend a2 = suspend a2\n-- |\n-- | -- Suspend/join is identity\n-- | suspend >=> join = id\n-- |\n-- | -- Fork/join is identity\n-- | fork >=> join = id\n-- |\n-- | -- Join is idempotent\n-- | join t *> join t = join t\n-- | ```\nclass (Monad m, Functor f) <= MonadFork f m | m -> f where\n  suspend :: forall a. m a -> m (f a)\n  fork :: forall a. m a -> m (f a)\n  join :: forall a. f a -> m a\n\ninstance monadForkAff :: MonadFork Aff.Fiber Aff.Aff where\n  suspend = Aff.suspendAff\n  fork = Aff.forkAff\n  join = Aff.joinFiber\n\ninstance monadForkReaderT :: MonadFork f m => MonadFork f (ReaderT r m) where\n  suspend (ReaderT ma) = ReaderT (suspend <<< ma)\n  fork (ReaderT ma) = ReaderT (fork <<< ma)\n  join = lift <<< join\n\n-- | Represents Monads which can be killed after being forked.\n-- |\n-- | Laws:\n-- |\n-- | ```purescript\n-- | -- Killed suspension is an exception\n-- | suspend a >>= \\f -> kill e f *> join f = throwError e\n-- |\n-- | -- Suspend/kill is unit\n-- | suspend a >>= kill e = pure unit\n-- | ```\nclass (MonadFork f m, MonadThrow e m) <= MonadKill e f m | m -> e f where\n  kill :: forall a. e -> f a -> m Unit\n\ninstance monadKillAff :: MonadKill Aff.Error Aff.Fiber Aff.Aff where\n  kill = Aff.killFiber\n\ninstance monadKillReaderT :: MonadKill e f m => MonadKill e f (ReaderT r m) where\n  kill e = lift <<< kill e\n\ndata BracketCondition e a\n  = Completed a\n  | Failed e\n  | Killed e\n\n-- | Represents Monads which support cleanup in the presence of async\n-- | exceptions.\n-- |\n-- | Laws:\n-- | ```purescript\n-- | bracket a k \\_ -> pure r\n-- |   = uninterruptible (a >>= k (Completed r))\n-- |\n-- | -- Release failed\n-- | bracket a k \\_ -> throwError e\n-- |   = uninterruptible (a >>= k (Failed e) *> throwError e)\n-- |\n-- | -- Release killed\n-- | fork (bracket a k \\_ -> never) >>= \\f -> kill e f *> void (try (join f))\n-- |   = uninterruptible (a >>= k (Killed e))\n-- | ```\nclass (MonadKill e f m, MonadError e m) <= MonadBracket e f m | m -> e f where\n  bracket :: forall r a. m r -> (BracketCondition e a -> r -> m Unit) -> (r -> m a) -> m a\n  uninterruptible :: forall a. m a -> m a\n  never :: forall a. m a\n\ninstance monadBracketAff :: MonadBracket Aff.Error Aff.Fiber Aff.Aff where\n  bracket acquire release run =\n    Aff.generalBracket acquire\n      { completed: release <<< Completed\n      , failed: release <<< Failed\n      , killed: release <<< Killed\n      }\n      run\n  uninterruptible = Aff.invincible\n  never = Aff.never\n\ninstance monadBracketReaderT :: MonadBracket e f m => MonadBracket e f (ReaderT r m) where\n  bracket (ReaderT acquire) release run = ReaderT \\r ->\n    bracket (acquire r)\n      (\\c a -> runReaderT (release c a) r)\n      (\\a -> runReaderT (run a) r)\n  uninterruptible k = ReaderT \\r ->\n    uninterruptible (runReaderT k r)\n  never = lift never\n", "module Halogen.Aff.Driver.State\n  ( LifecycleHandlers\n  , DriverState(..)\n  , mapDriverState\n  , DriverStateRef(..)\n  , DriverStateRec\n  , DriverStateX\n  , unDriverStateX\n  , mkDriverStateXRef\n  , RenderStateX\n  , renderStateX\n  , renderStateX_\n  , unRenderStateX\n  , initDriverState\n  ) where\n\nimport Prelude\n\nimport Data.List (List(..))\nimport Data.Map as M\nimport Data.Maybe (Maybe(..))\nimport Data.Traversable (traverse_)\nimport Effect (Effect)\nimport Effect.Aff (Aff, Fiber)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Halogen.Component (ComponentSpec)\nimport Halogen.Data.Slot (SlotStorage)\nimport Halogen.Data.Slot as SlotStorage\nimport Halogen.Query.HalogenM (ForkId, SubscriptionId)\nimport Halogen.Subscription as HS\nimport Unsafe.Coerce (unsafeCoerce)\nimport Web.DOM (Element)\n\ntype LifecycleHandlers =\n  { initializers :: List (Aff Unit)\n  , finalizers :: List (Aff Unit)\n  }\n\nnewtype DriverState r s f act ps i o = DriverState (DriverStateRec r s f act ps i o)\n\ntype DriverStateRec r s f act ps i o =\n  { component :: ComponentSpec s f act ps i o Aff\n  , state :: s\n  , refs :: M.Map String Element\n  , children :: SlotStorage ps (DriverStateRef r)\n  , childrenIn :: Ref (SlotStorage ps (DriverStateRef r))\n  , childrenOut :: Ref (SlotStorage ps (DriverStateRef r))\n  , selfRef :: Ref (DriverState r s f act ps i o)\n  , handlerRef :: Ref (o -> Aff Unit)\n  , pendingQueries :: Ref (Maybe (List (Aff Unit)))\n  , pendingOuts :: Ref (Maybe (List (Aff Unit)))\n  , pendingHandlers :: Ref (Maybe (List (Aff Unit)))\n  , rendering :: Maybe (r s act ps o)\n  , fresh :: Ref Int\n  , subscriptions :: Ref (Maybe (M.Map SubscriptionId HS.Subscription))\n  , forks :: Ref (M.Map ForkId (Fiber Unit))\n  , lifecycleHandlers :: Ref LifecycleHandlers\n  }\n\nmapDriverState\n  :: forall r s f act ps i o\n   . (DriverStateRec r s f act ps i o -> DriverStateRec r s f act ps i o)\n  -> DriverState r s f act ps i o\n  -> DriverState r s f act ps i o\nmapDriverState f (DriverState ds) = DriverState (f ds)\n\nnewtype DriverStateRef r f o = DriverStateRef (Ref (DriverStateX r f o))\n\n-- | A version of `DriverState` with the aspects relating to child components\n-- | existentially hidden.\ndata DriverStateX\n  (r :: Type -> Type -> Row Type -> Type -> Type)\n  (f :: Type -> Type)\n  (o :: Type)\n\nmkDriverStateXRef\n  :: forall r s f act ps i o\n   . Ref (DriverState r s f act ps i o)\n  -> Ref (DriverStateX r f o)\nmkDriverStateXRef = unsafeCoerce\n\nunDriverStateX\n  :: forall r f i o x\n   . (forall s act ps. DriverStateRec r s f act ps i o -> x)\n  -> DriverStateX r f o\n  -> x\nunDriverStateX = unsafeCoerce\n\n-- | A wrapper of `r` from `DriverState` with the aspects relating to child\n-- | components existentially hidden.\ndata RenderStateX (r :: Type -> Type -> Row Type -> Type -> Type)\n\nmkRenderStateX\n  :: forall r s f ps o m\n   . m (r s f ps o)\n  -> m (RenderStateX r)\nmkRenderStateX = unsafeCoerce\n\nunRenderStateX\n  :: forall r x\n   . (forall s f ps o. r s f ps o -> x)\n  -> RenderStateX r\n  -> x\nunRenderStateX = unsafeCoerce\n\nrenderStateX\n  :: forall m r f o\n   . Functor m\n  => (forall s act ps. Maybe (r s act ps o) -> m (r s act ps o))\n  -> DriverStateX r f o\n  -> m (RenderStateX r)\nrenderStateX f = unDriverStateX \\st ->\n  mkRenderStateX (f st.rendering)\n\nrenderStateX_\n  :: forall m r f o\n   . Applicative m\n  => (forall s act ps. r s act ps o -> m Unit)\n  -> DriverStateX r f o\n  -> m Unit\nrenderStateX_ f = unDriverStateX \\st -> traverse_ f st.rendering\n\ninitDriverState\n  :: forall r s f act ps i o\n   . ComponentSpec s f act ps i o Aff\n  -> i\n  -> (o -> Aff Unit)\n  -> Ref LifecycleHandlers\n  -> Effect (Ref (DriverStateX r f o))\ninitDriverState component input handler lchs = do\n  selfRef <- Ref.new (unsafeCoerce {})\n  childrenIn <- Ref.new SlotStorage.empty\n  childrenOut <- Ref.new SlotStorage.empty\n  handlerRef <- Ref.new handler\n  pendingQueries <- Ref.new (Just Nil)\n  pendingOuts <- Ref.new (Just Nil)\n  pendingHandlers <- Ref.new Nothing\n  fresh <- Ref.new 1\n  subscriptions <- Ref.new (Just M.empty)\n  forks <- Ref.new M.empty\n  let\n    ds :: DriverStateRec r s f act ps i o\n    ds =\n      { component\n      , state: component.initialState input\n      , refs: M.empty\n      , children: SlotStorage.empty\n      , childrenIn\n      , childrenOut\n      , selfRef\n      , handlerRef\n      , pendingQueries\n      , pendingOuts\n      , pendingHandlers\n      , rendering: Nothing\n      , fresh\n      , subscriptions\n      , forks\n      , lifecycleHandlers: lchs\n      }\n  Ref.write (DriverState ds) selfRef\n  pure $ mkDriverStateXRef selfRef\n", "module Halogen.Aff.Driver.Eval\n  ( Renderer\n  , evalF\n  , evalQ\n  , evalM\n  , handleLifecycle\n  , queueOrRun\n  , handleAff\n  ) where\n\nimport Prelude\n\nimport Control.Applicative.Free (hoistFreeAp, retractFreeAp)\nimport Control.Monad.Fork.Class (fork)\nimport Control.Monad.Free (foldFree)\nimport Control.Parallel (parSequence_, parallel, sequential)\nimport Data.Coyoneda (liftCoyoneda)\nimport Data.Either (either)\nimport Data.Foldable (traverse_)\nimport Data.List (List, (:))\nimport Data.List as L\nimport Data.Map as M\nimport Data.Maybe (Maybe(..))\nimport Data.Tuple (Tuple(..))\nimport Effect (Effect)\nimport Effect.Aff (Aff, error, finally, joinFiber, killFiber, runAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Exception (throwException)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Halogen.Aff.Driver.State (DriverState(..), DriverStateRef(..), LifecycleHandlers, mapDriverState, unDriverStateX)\nimport Halogen.Query.ChildQuery as CQ\nimport Halogen.Query.HalogenM (ForkId(..), HalogenAp(..), HalogenF(..), HalogenM(..), SubscriptionId(..))\nimport Halogen.Query.HalogenQ as HQ\nimport Halogen.Query.Input (Input)\nimport Halogen.Query.Input as Input\nimport Halogen.Subscription as HS\nimport Unsafe.Reference (unsafeRefEq)\n\ntype Renderer r =\n  forall s f act ps i o\n   . Ref LifecycleHandlers\n  -> Ref (DriverState r s f act ps i o)\n  -> Effect Unit\n\nevalF\n  :: forall r s f act ps i o\n   . Renderer r\n  -> Ref (DriverState r s f act ps i o)\n  -> Input act\n  -> Aff Unit\nevalF render ref = case _ of\n  Input.RefUpdate (Input.RefLabel p) el -> do\n    liftEffect $ flip Ref.modify_ ref $ mapDriverState \\st ->\n      st { refs = M.alter (const el) p st.refs }\n  Input.Action act -> do\n    DriverState st <- liftEffect (Ref.read ref)\n    evalM render ref (st.component.eval (HQ.Action act unit))\n\nevalQ\n  :: forall r s f act ps i o a\n   . Renderer r\n  -> Ref (DriverState r s f act ps i o)\n  -> f a\n  -> Aff (Maybe a)\nevalQ render ref q = do\n  DriverState st <- liftEffect (Ref.read ref)\n  evalM render ref (st.component.eval (HQ.Query (Just <$> liftCoyoneda q) (const Nothing)))\n\nevalM\n  :: forall r s f act ps i o a\n   . Renderer r\n  -> Ref (DriverState r s f act ps i o)\n  -> HalogenM s act ps o Aff a\n  -> Aff a\nevalM render initRef (HalogenM hm) = foldFree (go initRef) hm\n  where\n  go\n    :: forall s' f' act' ps' i' o' a'\n     . Ref (DriverState r s' f' act' ps' i' o')\n    -> HalogenF s' act' ps' o' Aff a'\n    -> Aff a'\n  go ref = case _ of\n    State f -> do\n      DriverState (st@{ state, lifecycleHandlers }) <- liftEffect (Ref.read ref)\n      case f state of\n        Tuple a state'\n          | unsafeRefEq state state' -> pure a\n          | otherwise -> do\n              liftEffect $ Ref.write (DriverState (st { state = state' })) ref\n              handleLifecycle lifecycleHandlers (render lifecycleHandlers ref)\n              pure a\n    Subscribe fes k -> do\n      sid <- fresh SubscriptionId ref\n      finalize <- liftEffect $ HS.subscribe (fes sid) \\act ->\n        handleAff $ evalF render ref (Input.Action act)\n      DriverState ({ subscriptions }) <- liftEffect (Ref.read ref)\n      liftEffect $ Ref.modify_ (map (M.insert sid finalize)) subscriptions\n      pure (k sid)\n    Unsubscribe sid next -> do\n      liftEffect $ unsubscribe sid ref\n      pure next\n    Lift aff ->\n      aff\n    ChildQuery cq ->\n      evalChildQuery ref cq\n    Raise o a -> do\n      DriverState { handlerRef, pendingOuts } <- liftEffect (Ref.read ref)\n      handler <- liftEffect (Ref.read handlerRef)\n      queueOrRun pendingOuts (handler o)\n      pure a\n    Par (HalogenAp p) ->\n      sequential $ retractFreeAp $ hoistFreeAp (parallel <<< evalM render ref) p\n    Fork hmu k -> do\n      fid <- fresh ForkId ref\n      DriverState ({ forks }) <- liftEffect (Ref.read ref)\n      doneRef <- liftEffect (Ref.new false)\n      fiber <- fork $ finally\n        ( liftEffect do\n            Ref.modify_ (M.delete fid) forks\n            Ref.write true doneRef\n        )\n        (evalM render ref hmu)\n      liftEffect $ unlessM (Ref.read doneRef) do\n        Ref.modify_ (M.insert fid fiber) forks\n      pure (k fid)\n    Join fid a -> do\n      DriverState { forks } <- liftEffect (Ref.read ref)\n      forkMap <- liftEffect (Ref.read forks)\n      traverse_ joinFiber (M.lookup fid forkMap)\n      pure a\n    Kill fid a -> do\n      DriverState ({ forks }) <- liftEffect (Ref.read ref)\n      forkMap <- liftEffect (Ref.read forks)\n      traverse_ (killFiber (error \"Cancelled\")) (M.lookup fid forkMap)\n      pure a\n    GetRef (Input.RefLabel p) k -> do\n      DriverState { refs } <- liftEffect (Ref.read ref)\n      pure $ k $ M.lookup p refs\n\n  evalChildQuery\n    :: forall s' f' act' ps' i' o' a'\n     . Ref (DriverState r s' f' act' ps' i' o')\n    -> CQ.ChildQueryBox ps' a'\n    -> Aff a'\n  evalChildQuery ref cqb = do\n    DriverState st <- liftEffect (Ref.read ref)\n    cqb # CQ.unChildQueryBox \\(CQ.ChildQuery unpack query reply) -> do\n      let\n        evalChild (DriverStateRef var) = parallel do\n          dsx <- liftEffect (Ref.read var)\n          unDriverStateX (\\ds -> evalQ render ds.selfRef query) dsx\n      reply <$> sequential (unpack evalChild st.children)\n\nunsubscribe\n  :: forall r s' f' act' ps' i' o'\n   . SubscriptionId\n  -> Ref (DriverState r s' f' act' ps' i' o')\n  -> Effect Unit\nunsubscribe sid ref = do\n  DriverState ({ subscriptions }) <- Ref.read ref\n  subs <- Ref.read subscriptions\n  traverse_ HS.unsubscribe (M.lookup sid =<< subs)\n\nhandleLifecycle :: Ref LifecycleHandlers -> Effect ~> Aff\nhandleLifecycle lchs f = do\n  liftEffect $ Ref.write { initializers: L.Nil, finalizers: L.Nil } lchs\n  result <- liftEffect f\n  { initializers, finalizers } <- liftEffect $ Ref.read lchs\n  traverse_ fork finalizers\n  parSequence_ initializers\n  pure result\n\nfresh\n  :: forall r s f act ps i o a\n   . (Int -> a)\n  -> Ref (DriverState r s f act ps i o)\n  -> Aff a\nfresh f ref = do\n  DriverState st <- liftEffect (Ref.read ref)\n  liftEffect $ Ref.modify' (\\i -> { state: i + 1, value: f i }) st.fresh\n\nqueueOrRun\n  :: Ref (Maybe (List (Aff Unit)))\n  -> Aff Unit\n  -> Aff Unit\nqueueOrRun ref au =\n  liftEffect (Ref.read ref) >>= case _ of\n    Nothing -> au\n    Just p -> liftEffect $ Ref.write (Just (au : p)) ref\n\n-- We could perhaps do something more intelligent now this isn't baked into\n-- the virtual-dom rendering. It hasn't really been a problem so far though.\nhandleAff :: forall a. Aff a -> Effect Unit\nhandleAff = runAff_ (either throwException (const (pure unit)))\n", "module Halogen.Aff.Driver\n  ( RenderSpec\n  , runUI\n  , module Halogen\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Fork.Class (fork)\nimport Control.Monad.Rec.Class (Step(..), tailRecM)\nimport Control.Parallel (parSequence_)\nimport Data.List ((:))\nimport Data.List as L\nimport Data.Map as M\nimport Data.Maybe (Maybe(..), maybe, isJust, isNothing)\nimport Data.Traversable (for_, traverse_)\nimport Data.Tuple (Tuple(..))\nimport Effect (Effect)\nimport Effect.Aff (Aff, killFiber)\nimport Effect.Class (liftEffect)\nimport Effect.Console (warn)\nimport Effect.Exception (error, throw)\nimport Effect.Ref (Ref)\nimport Effect.Ref as Ref\nimport Halogen (HalogenIO)\nimport Halogen.Aff.Driver.Eval as Eval\nimport Halogen.Aff.Driver.State (DriverState(..), DriverStateRef(..), DriverStateX, LifecycleHandlers, RenderStateX, initDriverState, mapDriverState, renderStateX, renderStateX_, unDriverStateX)\nimport Halogen.Component (Component, ComponentSlot, ComponentSlotBox, unComponent, unComponentSlot)\nimport Halogen.Data.Slot as Slot\nimport Halogen.HTML.Core as HC\nimport Halogen.Query.HalogenQ as HQ\nimport Halogen.Query.Input (Input)\nimport Halogen.Query.Input as Input\nimport Halogen.Subscription as HS\n\n-- | `RenderSpec` allows for alternative driver implementations without the need\n-- | to provide all of the driver machinery again, focusing just on the code\n-- | needed to render components.\n-- |\n-- | The type variables are as follows:\n-- | - `h` is the type of value being rendered (`Halogen.HTML.Core.HTML`, for\n-- |   example).\n-- | - `r` is the type for the \"render state\" for the driver. This is a value\n-- |   that is stored for each component, that allows the driver to persist\n-- |   state between each rendering of a component. This will differ entirely\n-- |   for each driver. `r` accepts a number of parameters that will be\n-- |   explained below.\n-- |\n-- | The \"inner\" type variables, used by `r` and the other functions are as\n-- | follows:\n-- | - `s` is the state type for the component.\n-- | - `act` is the action type for the component\n-- | - `ps` is the set of slots for addressing child components\n-- | - `o` is the output message type for the component\n-- |\n-- | Note that none of these variables can escape `RenderSpec`'s functions. They\n-- | need to be instantiated with each function call, as the same `RenderSpec`\n-- | is used to deal with all components in the hierarchy.\n-- |\n-- | The `render` function is the main part of the spec, it accepts:\n-- | - A \"handler\" function, for evaluating component queries. This is used to\n-- |   implement event handlers in HTML-based drivers.\n-- | - A \"child\" function for dealing with the rendering of children, returning\n-- |   the render state for the child component in an existentially hidden\n-- |   package. This return value would commonly be used to extract the rendered\n-- |   subtree for the child to graft it in place of the child slot. The\n-- |   existential package can be unwrapped with `Halogen.Aff.Driver.State.unRenderStateX`.\n-- | - The `h` value to render, parameterised by the slot type for the\n-- |   component's children. This slot type is what the \"child\" function\n-- |   accepts.\n-- | - The previous render state for the component. If the component has not\n-- |   previously been initalized, this will be `Nothing`.\n-- |\n-- | The render function then returns the updated (or initial) render state for\n-- | the component, which will be fed back into `render` the next time the\n-- | component needs to update.\n-- |\n-- | The `renderChild` function's behaviour will be highly dependant on the\n-- | particular driver implementing `RenderSpec`. Its purpose is to take a\n-- | driver render state for a component and produce a new one that may remap\n-- | the rendered value to be something more suitable for grafting during\n-- | `render` of the parent. For the built-in `halogen-vdom` driver this is\n-- | just `identity`. For the `virtual-dom` driver it wraps the rendered HTML\n-- | in a widget, to prevent the `virtual-dom` algorithm from re-diffing\n-- | values that we know are unchanged.\n-- |\n-- | The `removeChild` function is for drivers that need to perform some special\n-- | cleanup when removing a component from the hierarchy. In the `halogen-vdom`\n-- | driver this actually performs the `removeChild` from the DOM. For the\n-- | `virtual-dom` driver nothing needs to happen here, so it is\n-- | `const (pure unit)`.\n-- |\n-- | The `dispose` function is called when the top level component is disposed of\n-- | via `HalogenIO`.\ntype RenderSpec r =\n  { render ::\n      forall s act ps o\n       . (Input act -> Effect Unit)\n      -> (ComponentSlotBox ps Aff act -> Effect (RenderStateX r))\n      -> HC.HTML (ComponentSlot ps Aff act) act\n      -> Maybe (r s act ps o)\n      -> Effect (r s act ps o)\n  , renderChild :: forall s act ps o. r s act ps o -> r s act ps o\n  , removeChild :: forall s act ps o. r s act ps o -> Effect Unit\n  , dispose :: forall s act ps o. r s act ps o -> Effect Unit\n  }\n\nrunUI\n  :: forall r f i o\n   . RenderSpec r\n  -> Component f i o Aff\n  -> i\n  -> Aff (HalogenIO f o Aff)\nrunUI renderSpec component i = do\n  lchs <- liftEffect newLifecycleHandlers\n  disposed <- liftEffect $ Ref.new false\n  Eval.handleLifecycle lchs do\n    sio <- HS.create\n    dsx <- Ref.read =<< runComponent lchs (liftEffect <<< HS.notify sio.listener) i component\n    dsx # unDriverStateX \\st -> pure\n      { query: evalDriver disposed st.selfRef\n      , messages: sio.emitter\n      , dispose: dispose disposed lchs dsx\n      }\n  where\n  evalDriver\n    :: forall s f' act ps i' o'\n     . Ref Boolean\n    -> Ref (DriverState r s f' act ps i' o')\n    -> (forall a. f' a -> Aff (Maybe a))\n  evalDriver disposed ref q =\n    liftEffect (Ref.read disposed) >>=\n      if _ then pure Nothing\n      else Eval.evalQ render ref q\n\n  runComponent\n    :: forall f' i' o'\n     . Ref LifecycleHandlers\n    -> (o' -> Aff Unit)\n    -> i'\n    -> Component f' i' o' Aff\n    -> Effect (Ref (DriverStateX r f' o'))\n  runComponent lchs handler j = unComponent \\c -> do\n    lchs' <- newLifecycleHandlers\n    var <- initDriverState c j handler lchs'\n    pre <- Ref.read lchs\n    Ref.write { initializers: L.Nil, finalizers: pre.finalizers } lchs\n    unDriverStateX (render lchs <<< _.selfRef) =<< Ref.read var\n    squashChildInitializers lchs pre.initializers =<< Ref.read var\n    pure var\n\n  render\n    :: forall s f' act ps i' o'\n     . Ref LifecycleHandlers\n    -> Ref (DriverState r s f' act ps i' o')\n    -> Effect Unit\n  render lchs var = Ref.read var >>= \\(DriverState ds) -> do\n    shouldProcessHandlers <- isNothing <$> Ref.read ds.pendingHandlers\n    when shouldProcessHandlers $ Ref.write (Just L.Nil) ds.pendingHandlers\n    Ref.write Slot.empty ds.childrenOut\n    Ref.write ds.children ds.childrenIn\n\n    let\n      -- The following 3 defs are working around a capture bug, see #586\n      pendingHandlers = identity ds.pendingHandlers\n      pendingQueries = identity ds.pendingQueries\n      selfRef = identity ds.selfRef\n\n      handler :: Input act -> Aff Unit\n      handler = Eval.queueOrRun pendingHandlers <<< void <<< Eval.evalF render selfRef\n\n      childHandler :: act -> Aff Unit\n      childHandler = Eval.queueOrRun pendingQueries <<< handler <<< Input.Action\n\n    rendering <-\n      renderSpec.render\n        (Eval.handleAff <<< handler)\n        (renderChild lchs childHandler ds.childrenIn ds.childrenOut)\n        (ds.component.render ds.state)\n        ds.rendering\n\n    children <- Ref.read ds.childrenOut\n    childrenIn <- Ref.read ds.childrenIn\n\n    Slot.foreachSlot childrenIn \\(DriverStateRef childVar) -> do\n      childDS <- Ref.read childVar\n      renderStateX_ renderSpec.removeChild childDS\n      finalize lchs childDS\n\n    flip Ref.modify_ ds.selfRef $ mapDriverState \\ds' ->\n      ds' { rendering = Just rendering, children = children }\n\n    when shouldProcessHandlers do\n      flip tailRecM unit \\_ -> do\n        handlers <- Ref.read pendingHandlers\n        Ref.write (Just L.Nil) pendingHandlers\n        traverse_ (Eval.handleAff <<< traverse_ fork <<< L.reverse) handlers\n        mmore <- Ref.read pendingHandlers\n        if maybe false L.null mmore then Ref.write Nothing pendingHandlers $> Done unit\n        else pure $ Loop unit\n\n  renderChild\n    :: forall ps act\n     . Ref LifecycleHandlers\n    -> (act -> Aff Unit)\n    -> Ref (Slot.SlotStorage ps (DriverStateRef r))\n    -> Ref (Slot.SlotStorage ps (DriverStateRef r))\n    -> ComponentSlotBox ps Aff act\n    -> Effect (RenderStateX r)\n  renderChild lchs handler childrenInRef childrenOutRef =\n    unComponentSlot \\slot -> do\n      childrenIn <- slot.pop <$> Ref.read childrenInRef\n      var <- case childrenIn of\n        Just (Tuple (DriverStateRef existing) childrenIn') -> do\n          Ref.write childrenIn' childrenInRef\n          dsx <- Ref.read existing\n          dsx # unDriverStateX \\st -> do\n            flip Ref.write st.handlerRef $ maybe (pure unit) handler <<< slot.output\n            Eval.handleAff $ Eval.evalM render st.selfRef (st.component.eval (HQ.Receive slot.input unit))\n          pure existing\n        Nothing ->\n          runComponent lchs (maybe (pure unit) handler <<< slot.output) slot.input slot.component\n      isDuplicate <- isJust <<< slot.get <$> Ref.read childrenOutRef\n      when isDuplicate\n        $ warn \"Halogen: Duplicate slot address was detected during rendering, unexpected results may occur\"\n      Ref.modify_ (slot.set $ DriverStateRef var) childrenOutRef\n      Ref.read var >>= renderStateX case _ of\n        Nothing -> throw \"Halogen internal error: child was not initialized in renderChild\"\n        Just r -> pure (renderSpec.renderChild r)\n\n  squashChildInitializers\n    :: forall f' o'\n     . Ref LifecycleHandlers\n    -> L.List (Aff Unit)\n    -> DriverStateX r f' o'\n    -> Effect Unit\n  squashChildInitializers lchs preInits =\n    unDriverStateX \\st -> do\n      let parentInitializer = Eval.evalM render st.selfRef (st.component.eval (HQ.Initialize unit))\n      lchs # Ref.modify_ \\handlers ->\n        { initializers:\n            ( do\n                parSequence_ (L.reverse handlers.initializers)\n                parentInitializer\n                liftEffect do\n                  handlePending st.pendingQueries\n                  handlePending st.pendingOuts\n            ) : preInits\n        , finalizers: handlers.finalizers\n        }\n\n  finalize\n    :: forall f' o'\n     . Ref LifecycleHandlers\n    -> DriverStateX r f' o'\n    -> Effect Unit\n  finalize lchs = do\n    unDriverStateX \\st -> do\n      cleanupSubscriptionsAndForks (DriverState st)\n      let f = Eval.evalM render st.selfRef (st.component.eval (HQ.Finalize unit))\n      lchs # Ref.modify_ \\handlers ->\n        { initializers: handlers.initializers\n        , finalizers: f : handlers.finalizers\n        }\n      Slot.foreachSlot st.children \\(DriverStateRef ref) -> do\n        dsx <- Ref.read ref\n        finalize lchs dsx\n\n  dispose\n    :: forall f' o'\n     . Ref Boolean\n    -> Ref LifecycleHandlers\n    -> DriverStateX r f' o'\n    -> Aff Unit\n  dispose disposed lchs dsx = Eval.handleLifecycle lchs do\n    Ref.read disposed >>=\n      if _ then\n        pure unit\n      else do\n        Ref.write true disposed\n        finalize lchs dsx\n        dsx # unDriverStateX \\{ selfRef } -> do\n          (DriverState ds) <- liftEffect $ Ref.read selfRef\n          for_ ds.rendering renderSpec.dispose\n\nnewLifecycleHandlers :: Effect (Ref LifecycleHandlers)\nnewLifecycleHandlers = Ref.new { initializers: L.Nil, finalizers: L.Nil }\n\nhandlePending :: Ref (Maybe (L.List (Aff Unit))) -> Effect Unit\nhandlePending ref = do\n  queue <- Ref.read ref\n  Ref.write Nothing ref\n  for_ queue (Eval.handleAff <<< traverse_ fork <<< L.reverse)\n\ncleanupSubscriptionsAndForks\n  :: forall r s f act ps i o\n   . DriverState r s f act ps i o\n  -> Effect Unit\ncleanupSubscriptionsAndForks (DriverState ds) = do\n  traverse_ (traverse_ HS.unsubscribe) =<< Ref.read ds.subscriptions\n  Ref.write Nothing ds.subscriptions\n  traverse_ (Eval.handleAff <<< killFiber (error \"finalized\")) =<< Ref.read ds.forks\n  Ref.write M.empty ds.forks\n", "module Halogen.Aff.Util\n  ( awaitLoad\n  , awaitBody\n  , selectElement\n  , runHalogenAff\n  ) where\n\nimport Prelude\n\nimport Control.Monad.Error.Class (throwError)\nimport Data.Either (Either(..), either)\nimport Data.Maybe (Maybe, maybe)\nimport Effect (Effect)\nimport Effect.Aff (Aff, effectCanceler, makeAff, nonCanceler, runAff_)\nimport Effect.Class (liftEffect)\nimport Effect.Exception (throwException, error)\nimport Web.DOM.ParentNode (QuerySelector(..), querySelector)\nimport Web.Event.EventTarget (addEventListener, eventListener, removeEventListener)\nimport Web.HTML (window)\nimport Web.HTML.Event.EventTypes as ET\nimport Web.HTML.HTMLDocument (readyState)\nimport Web.HTML.HTMLDocument as HTMLDocument\nimport Web.HTML.HTMLDocument.ReadyState (ReadyState(..))\nimport Web.HTML.HTMLElement (HTMLElement)\nimport Web.HTML.HTMLElement as HTMLElement\nimport Web.HTML.Window as Window\n\n-- | Waits for the document to load.\nawaitLoad :: Aff Unit\nawaitLoad = makeAff \\callback -> do\n  rs <- readyState =<< Window.document =<< window\n  case rs of\n    Loading -> do\n      et <- Window.toEventTarget <$> window\n      listener <- eventListener (\\_ -> callback (Right unit))\n      addEventListener ET.domcontentloaded listener false et\n      pure $ effectCanceler (removeEventListener ET.domcontentloaded listener false et)\n    _ -> do\n      callback (Right unit)\n      pure nonCanceler\n\n-- | Waits for the document to load and then finds the `body` element.\nawaitBody :: Aff HTMLElement\nawaitBody = do\n  awaitLoad\n  body <- selectElement (QuerySelector \"body\")\n  maybe (throwError (error \"Could not find body\")) pure body\n\n-- | Tries to find an element in the document.\nselectElement :: QuerySelector -> Aff (Maybe HTMLElement)\nselectElement query = do\n  mel <- liftEffect do\n    (querySelector query <<< HTMLDocument.toParentNode <=< Window.document) =<< window\n  pure $ HTMLElement.fromElement =<< mel\n\n-- | Runs an `Aff` value of the type commonly used by Halogen components. Any\n-- | unhandled errors will be re-thrown as exceptions.\nrunHalogenAff :: forall x. Aff x -> Effect Unit\nrunHalogenAff = runAff_ (either throwException (const (pure unit)))\n", "var getEffProp = function (name) {\n  return function (node) {\n    return function () {\n      return node[name];\n    };\n  };\n};\n\nexport function nodeTypeIndex(node) {\n  return node.nodeType;\n}\n\nexport function nodeName(node) {\n  return node.nodeName;\n}\n\nexport const baseURI = getEffProp(\"baseURI\");\nexport const _ownerDocument = getEffProp(\"ownerDocument\");\nexport const _parentNode = getEffProp(\"parentNode\");\nexport const _parentElement = getEffProp(\"parentElement\");\n\nexport function hasChildNodes(node) {\n  return function () {\n    return node.hasChildNodes();\n  };\n}\n\nexport const childNodes = getEffProp(\"childNodes\");\nexport const _firstChild = getEffProp(\"firstChild\");\nexport const _lastChild = getEffProp(\"lastChild\");\nexport const _previousSibling = getEffProp(\"previousSibling\");\nexport const _nextSibling = getEffProp(\"nextSibling\");\nexport const _nodeValue = getEffProp(\"nodeValue\");\n\nexport function setNodeValue(value) {\n  return function (node) {\n    return function () {\n      node.nodeValue = value;\n    };\n  };\n}\n\nexport const textContent = getEffProp(\"textContent\");\n\nexport function setTextContent(value) {\n  return function (node) {\n    return function () {\n      node.textContent = value;\n    };\n  };\n}\n\nexport function normalize(node) {\n  return function () {\n    node.normalize();\n  };\n}\n\nexport function clone(node) {\n  return function () {\n    return node.cloneNode(false);\n  };\n}\n\nexport function deepClone(node) {\n  return function () {\n    return node.cloneNode(true);\n  };\n}\n\nexport function isEqualNode(node1) {\n  return function (node2) {\n    return function () {\n      return node1.isEqualNode(node2);\n    };\n  };\n}\n\nexport function compareDocumentPositionBits(node1) {\n  return function (node2) {\n    return function () {\n      return node1.compareDocumentPosition(node2);\n    };\n  };\n}\n\nexport function contains(node1) {\n  return function (node2) {\n    return function () {\n      return node1.contains(node2);\n    };\n  };\n}\n\nexport function _lookupPrefix(prefix) {\n  return function (node) {\n    return function () {\n      return node.lookupPrefix(prefix);\n    };\n  };\n}\n\nexport function _lookupNamespaceURI(ns) {\n  return function (node) {\n    return function () {\n      return node.lookupNamespaceURI(ns);\n    };\n  };\n}\n\nexport function isDefaultNamespace(ns) {\n  return function (node) {\n    return function () {\n      return node.isDefaultNamespace(ns);\n    };\n  };\n}\n\nexport function insertBefore(node1) {\n  return function (node2) {\n    return function (parent) {\n      return function () {\n        parent.insertBefore(node1, node2);\n      };\n    };\n  };\n}\n\nexport function appendChild(node) {\n  return function (parent) {\n    return function () {\n      parent.appendChild(node);\n    };\n  };\n}\n\nexport function replaceChild(newChild) {\n  return function (oldChild) {\n    return function (parent) {\n      return function () {\n        parent.replaceChild(newChild, oldChild);\n      };\n    };\n  };\n}\n\nexport function removeChild(node) {\n  return function (parent) {\n    return function () {\n      parent.removeChild(node);\n    };\n  };\n}\n", "module Example.Hello.Main where\n\nimport Effect (Effect)\nimport Gesso as Gesso\nimport Gesso.Application as Gesso.Application\nimport Gesso.Canvas as Gesso.Canvas\nimport Gesso.Dimensions as Gesso.Dimensions\nimport Gesso.Interactions as Gesso.Interactions\nimport Gesso.Time as Gesso.Time\nimport Graphics.Canvas as Graphics.Canvas\nimport Prelude (Unit, unit, bind)\n\nmain :: Effect Unit\nmain =\n  Gesso.runGessoAff do\n    body <- Gesso.awaitBody\n    Gesso.run Gesso.canvas canvasInput body\n\n-- Gesso.Canvas.Input's type variables are:\n--   - local state (state held in canvas and given to update/render)\n--   - input (type used to send data into canvas)\n--   - output (type canvas uses to send data out)\ncanvasInput :: forall i o. Gesso.Canvas.Input Unit i o\ncanvasInput =\n  { name: \"hello\"\n  , localState: unit\n  , app:\n      Gesso.Application.defaultApp\n        { window = Gesso.Application.Fullscreen\n        , render = render\n        }\n  , viewBox: Gesso.Dimensions.p1080\n  , interactions: Gesso.Interactions.default\n  }\n\nrender :: Unit -> Gesso.Time.Delta -> Gesso.Dimensions.Scaler -> Graphics.Canvas.Context2D -> Effect Unit\nrender _ _ _ context = do\n  Graphics.Canvas.fillText context \"hello world\" 500.0 500.0\n", "import { main } from './output/Example.Hello.Main/index.js';main();"],
  "mappings": "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",
  "names": ["i", "i", "b", "a", "i", "a", "b", "pure1", "a", "a", "Aff", "nonCanceler", "error", "left", "size", "thunk", "i", "kill", "k", "step", "fail", "run", "result", "sequential", "join", "par", "cb", "head", "tail", "kills", "kid", "value", "options", "b", "a", "eq", "i", "i", "compare3", "append1", "a", "identity", "map", "a", "a", "ref", "a", "__do", "unsafeCoerce", "b", "a", "b", "a", "modify_", "map", "append", "bind", "map", "a", "mempty", "init", "i", "go", "append", "a", "foldMap2", "map", "traverse_1", "__do", "a", "pure2", "liftEffect", "liftEffect", "pure", "bindFlipped", "go", "a", "pure2", "pure2", "singleton", "a", "empty", "oneOf", "alt", "pure", "append1", "foldMap1", "b", "foldl", "foldr", "foldl", "foldr", "b", "rev", "go", "append2", "value", "i", "empty", "i", "i", "compare", "from", "i", "a", "b", "a", "b", "compare", "singleton", "a", "i", "singleton", "top", "bottom", "round", "map", "second", "append1", "append2", "lookup", "fromString", "intercalate", "fromString", "append", "compare", "a", "b", "singleton", "value", "map1", "apply", "bind", "fromString", "fromString1", "unsafeCoerce", "show", "append2", "i", "fromString", "i", "fromString", "key", "fromString", "top", "key", "fromString", "append1", "append2", "a", "b", "fold1", "map", "intercalate", "apply", "append1", "sort", "map1", "fromString", "map1", "foldl1", "append", "map2", "map", "collect", "p", "bind1", "q", "map1", "oneOf", "intercalate", "foldMap2", "a", "fold2", "append2", "map2", "fold1", "append", "value", "fromString", "fromString1", "width", "height", "a", "unsafeCoerce", "a", "extract", "Elem", "unsafeCoerce", "go", "Elem", "map", "map1", "bimap", "key", "forE", "a", "b", "i", "i", "a", "refEq", "b", "name", "attr", "unsafeFreeze", "unsafeCoerce", "name", "rect", "name", "selector", "map", "unsafeCoerce", "state", "parent", "Elem", "extract", "children", "child", "value", "value", "reverse", "go", "$$null", "singleton", "cons", "lookup", "addEventListener", "target", "removeEventListener", "Property", "key", "unsafeCoerce", "unsafeCoerce", "Property", "handler", "state", "lookup", "refEq", "__do", "ref", "Property", "element", "name", "children", "prop", "prop", "width", "id", "prop2", "height", "attr", "width", "height", "width", "round", "height", "width", "height", "go", "th", "p", "id", "Just", "Nothing", "text", "id", "map", "unsafeCoerce", "unsafeCoerce", "value", "toNode", "unsafeCoerce", "mkEffectFn1", "document", "window", "unsafeCoerce", "size", "discard", "attr", "name", "traverse", "map", "document", "map1", "append", "map", "window", "requestAnimationFrame", "singleton", "height", "lookup", "go", "compare", "insert", "go", "singleton", "compare", "go", "append1", "empty", "$$delete", "go", "compare", "compare", "traverse_", "empty", "cons", "apply", "go", "pure", "singleton", "identity", "uncons", "reverse", "snoc", "a", "$$null", "empty", "snoc", "foldr", "b", "q", "foldl", "go", "uncons", "i", "empty", "append", "append", "snoc", "a", "append", "empty", "v2", "append", "uncons", "a", "empty", "snoc", "go", "map1", "pure1", "unsafeCoerce", "a", "b", "a", "coerce", "create", "__do", "a", "Lift", "ChildQuery", "unsubscribe", "subscribe", "Lift", "Action", "Query", "unsafeCoerce", "refEq", "a", "a", "state", "unsafeCoerce", "voidLeft", "traverse_", "Action", "Query", "map", "unsafeCoerce", "element", "element", "eventListener", "target", "push", "__do", "Initialize", "Finalize", "$$for", "__do", "unsubscribe", "delta", "modify_", "requestAnimationFrame", "notify", "bind", "append", "id", "toSizeProps", "mapFlipped", "pure", "bind1", "liftEffect", "create", "canvas", "map", "bindFlipped", "gets", "get", "append1", "unsafeCoerce", "component", "input", "handler", "__do", "fresh", "unsubscribe", "ref", "__do", "liftEffect", "discard1", "traverse_2", "fork", "i", "render", "q", "Query", "map", "parallel", "bind1", "go", "map2", "insert", "Lift", "ChildQuery", "handler", "sequential", "retractFreeAp", "pure", "lookup2", "Action", "ref", "__do", "traverse_", "fork", "reverse", "renderSpec", "component", "i", "render", "handler", "pre", "$$var", "pure1", "renderStateX", "pure", "$$void", "children", "tailRecM", "$$null", "q", "for_", "query", "pure1", "__do", "discard", "body", "pure", "getEffProp", "name", "getEffProp", "getEffProp", "getEffProp", "parent", "removeChild", "parent", "parentNode", "map", "map", "$$void", "pure", "removeChild", "__do", "handler", "document", "buildWidget", "buildThunk", "unwrap", "step", "render", "child", "extract", "toNode", "parent", "runUI", "component", "i", "element", "run", "component", "input", "element", "canvas", "render", "main", "body", "main"]
}
